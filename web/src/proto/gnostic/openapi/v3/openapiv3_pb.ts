// Copyright 2020 Google LLC. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file gnostic/openapi/v3/openapiv3.proto (package gnostic.openapi.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Any as Any$1 } from "../../../google/protobuf/any_pb.js";

/**
 * @generated from message gnostic.openapi.v3.AdditionalPropertiesItem
 */
export class AdditionalPropertiesItem extends Message<AdditionalPropertiesItem> {
  /**
   * @generated from oneof gnostic.openapi.v3.AdditionalPropertiesItem.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
     */
    value: SchemaOrReference;
    case: "schemaOrReference";
  } | {
    /**
     * @generated from field: bool boolean = 2;
     */
    value: boolean;
    case: "boolean";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AdditionalPropertiesItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.AdditionalPropertiesItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema_or_reference", kind: "message", T: SchemaOrReference, oneof: "oneof" },
    { no: 2, name: "boolean", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalPropertiesItem {
    return new AdditionalPropertiesItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalPropertiesItem {
    return new AdditionalPropertiesItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalPropertiesItem {
    return new AdditionalPropertiesItem().fromJsonString(jsonString, options);
  }

  static equals(a: AdditionalPropertiesItem | PlainMessage<AdditionalPropertiesItem> | undefined, b: AdditionalPropertiesItem | PlainMessage<AdditionalPropertiesItem> | undefined): boolean {
    return proto3.util.equals(AdditionalPropertiesItem, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.Any
 */
export class Any extends Message<Any> {
  /**
   * @generated from field: google.protobuf.Any value = 1;
   */
  value?: Any$1;

  /**
   * @generated from field: string yaml = 2;
   */
  yaml = "";

  constructor(data?: PartialMessage<Any>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Any";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: Any$1 },
    { no: 2, name: "yaml", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Any {
    return new Any().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Any {
    return new Any().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Any {
    return new Any().fromJsonString(jsonString, options);
  }

  static equals(a: Any | PlainMessage<Any> | undefined, b: Any | PlainMessage<Any> | undefined): boolean {
    return proto3.util.equals(Any, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.AnyOrExpression
 */
export class AnyOrExpression extends Message<AnyOrExpression> {
  /**
   * @generated from oneof gnostic.openapi.v3.AnyOrExpression.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.Any any = 1;
     */
    value: Any;
    case: "any";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Expression expression = 2;
     */
    value: Expression;
    case: "expression";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AnyOrExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.AnyOrExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "any", kind: "message", T: Any, oneof: "oneof" },
    { no: 2, name: "expression", kind: "message", T: Expression, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnyOrExpression {
    return new AnyOrExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnyOrExpression {
    return new AnyOrExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnyOrExpression {
    return new AnyOrExpression().fromJsonString(jsonString, options);
  }

  static equals(a: AnyOrExpression | PlainMessage<AnyOrExpression> | undefined, b: AnyOrExpression | PlainMessage<AnyOrExpression> | undefined): boolean {
    return proto3.util.equals(AnyOrExpression, a, b);
  }
}

/**
 * A map of possible out-of band callbacks related to the parent operation. Each value in the map is a Path Item Object that describes a set of requests that may be initiated by the API provider and the expected responses. The key value used to identify the callback object is an expression, evaluated at runtime, that identifies a URL to use for the callback operation.
 *
 * @generated from message gnostic.openapi.v3.Callback
 */
export class Callback extends Message<Callback> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedPathItem path = 1;
   */
  path: NamedPathItem[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 2;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Callback>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Callback";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "message", T: NamedPathItem, repeated: true },
    { no: 2, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Callback {
    return new Callback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Callback {
    return new Callback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Callback {
    return new Callback().fromJsonString(jsonString, options);
  }

  static equals(a: Callback | PlainMessage<Callback> | undefined, b: Callback | PlainMessage<Callback> | undefined): boolean {
    return proto3.util.equals(Callback, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.CallbackOrReference
 */
export class CallbackOrReference extends Message<CallbackOrReference> {
  /**
   * @generated from oneof gnostic.openapi.v3.CallbackOrReference.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.Callback callback = 1;
     */
    value: Callback;
    case: "callback";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Reference reference = 2;
     */
    value: Reference;
    case: "reference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CallbackOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.CallbackOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "callback", kind: "message", T: Callback, oneof: "oneof" },
    { no: 2, name: "reference", kind: "message", T: Reference, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallbackOrReference {
    return new CallbackOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallbackOrReference {
    return new CallbackOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallbackOrReference {
    return new CallbackOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: CallbackOrReference | PlainMessage<CallbackOrReference> | undefined, b: CallbackOrReference | PlainMessage<CallbackOrReference> | undefined): boolean {
    return proto3.util.equals(CallbackOrReference, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.CallbacksOrReferences
 */
export class CallbacksOrReferences extends Message<CallbacksOrReferences> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedCallbackOrReference additional_properties = 1;
   */
  additionalProperties: NamedCallbackOrReference[] = [];

  constructor(data?: PartialMessage<CallbacksOrReferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.CallbacksOrReferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedCallbackOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallbacksOrReferences {
    return new CallbacksOrReferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallbacksOrReferences {
    return new CallbacksOrReferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallbacksOrReferences {
    return new CallbacksOrReferences().fromJsonString(jsonString, options);
  }

  static equals(a: CallbacksOrReferences | PlainMessage<CallbacksOrReferences> | undefined, b: CallbacksOrReferences | PlainMessage<CallbacksOrReferences> | undefined): boolean {
    return proto3.util.equals(CallbacksOrReferences, a, b);
  }
}

/**
 * Holds a set of reusable objects for different aspects of the OAS. All objects defined within the components object will have no effect on the API unless they are explicitly referenced from properties outside the components object.
 *
 * @generated from message gnostic.openapi.v3.Components
 */
export class Components extends Message<Components> {
  /**
   * @generated from field: gnostic.openapi.v3.SchemasOrReferences schemas = 1;
   */
  schemas?: SchemasOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.ResponsesOrReferences responses = 2;
   */
  responses?: ResponsesOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.ParametersOrReferences parameters = 3;
   */
  parameters?: ParametersOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.ExamplesOrReferences examples = 4;
   */
  examples?: ExamplesOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.RequestBodiesOrReferences request_bodies = 5;
   */
  requestBodies?: RequestBodiesOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.HeadersOrReferences headers = 6;
   */
  headers?: HeadersOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.SecuritySchemesOrReferences security_schemes = 7;
   */
  securitySchemes?: SecuritySchemesOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.LinksOrReferences links = 8;
   */
  links?: LinksOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
   */
  callbacks?: CallbacksOrReferences;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 10;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Components>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Components";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schemas", kind: "message", T: SchemasOrReferences },
    { no: 2, name: "responses", kind: "message", T: ResponsesOrReferences },
    { no: 3, name: "parameters", kind: "message", T: ParametersOrReferences },
    { no: 4, name: "examples", kind: "message", T: ExamplesOrReferences },
    { no: 5, name: "request_bodies", kind: "message", T: RequestBodiesOrReferences },
    { no: 6, name: "headers", kind: "message", T: HeadersOrReferences },
    { no: 7, name: "security_schemes", kind: "message", T: SecuritySchemesOrReferences },
    { no: 8, name: "links", kind: "message", T: LinksOrReferences },
    { no: 9, name: "callbacks", kind: "message", T: CallbacksOrReferences },
    { no: 10, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Components {
    return new Components().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Components {
    return new Components().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Components {
    return new Components().fromJsonString(jsonString, options);
  }

  static equals(a: Components | PlainMessage<Components> | undefined, b: Components | PlainMessage<Components> | undefined): boolean {
    return proto3.util.equals(Components, a, b);
  }
}

/**
 * Contact information for the exposed API.
 *
 * @generated from message gnostic.openapi.v3.Contact
 */
export class Contact extends Message<Contact> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * @generated from field: string email = 3;
   */
  email = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Contact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Contact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Contact {
    return new Contact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Contact {
    return new Contact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Contact {
    return new Contact().fromJsonString(jsonString, options);
  }

  static equals(a: Contact | PlainMessage<Contact> | undefined, b: Contact | PlainMessage<Contact> | undefined): boolean {
    return proto3.util.equals(Contact, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.DefaultType
 */
export class DefaultType extends Message<DefaultType> {
  /**
   * @generated from oneof gnostic.openapi.v3.DefaultType.oneof
   */
  oneof: {
    /**
     * @generated from field: double number = 1;
     */
    value: number;
    case: "number";
  } | {
    /**
     * @generated from field: bool boolean = 2;
     */
    value: boolean;
    case: "boolean";
  } | {
    /**
     * @generated from field: string string = 3;
     */
    value: string;
    case: "string";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DefaultType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.DefaultType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "number", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "oneof" },
    { no: 2, name: "boolean", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "oneof" },
    { no: 3, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DefaultType {
    return new DefaultType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DefaultType {
    return new DefaultType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DefaultType {
    return new DefaultType().fromJsonString(jsonString, options);
  }

  static equals(a: DefaultType | PlainMessage<DefaultType> | undefined, b: DefaultType | PlainMessage<DefaultType> | undefined): boolean {
    return proto3.util.equals(DefaultType, a, b);
  }
}

/**
 * When request bodies or response payloads may be one of a number of different schemas, a `discriminator` object can be used to aid in serialization, deserialization, and validation.  The discriminator is a specific object in a schema which is used to inform the consumer of the specification of an alternative schema based on the value associated with it.  When using the discriminator, _inline_ schemas will not be considered.
 *
 * @generated from message gnostic.openapi.v3.Discriminator
 */
export class Discriminator extends Message<Discriminator> {
  /**
   * @generated from field: string property_name = 1;
   */
  propertyName = "";

  /**
   * @generated from field: gnostic.openapi.v3.Strings mapping = 2;
   */
  mapping?: Strings;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 3;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Discriminator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Discriminator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mapping", kind: "message", T: Strings },
    { no: 3, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Discriminator {
    return new Discriminator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Discriminator {
    return new Discriminator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Discriminator {
    return new Discriminator().fromJsonString(jsonString, options);
  }

  static equals(a: Discriminator | PlainMessage<Discriminator> | undefined, b: Discriminator | PlainMessage<Discriminator> | undefined): boolean {
    return proto3.util.equals(Discriminator, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.Document
 */
export class Document extends Message<Document> {
  /**
   * @generated from field: string openapi = 1;
   */
  openapi = "";

  /**
   * @generated from field: gnostic.openapi.v3.Info info = 2;
   */
  info?: Info;

  /**
   * @generated from field: repeated gnostic.openapi.v3.Server servers = 3;
   */
  servers: Server[] = [];

  /**
   * @generated from field: gnostic.openapi.v3.Paths paths = 4;
   */
  paths?: Paths;

  /**
   * @generated from field: gnostic.openapi.v3.Components components = 5;
   */
  components?: Components;

  /**
   * @generated from field: repeated gnostic.openapi.v3.SecurityRequirement security = 6;
   */
  security: SecurityRequirement[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.Tag tags = 7;
   */
  tags: Tag[] = [];

  /**
   * @generated from field: gnostic.openapi.v3.ExternalDocs external_docs = 8;
   */
  externalDocs?: ExternalDocs;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 9;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Document>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Document";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "openapi", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "info", kind: "message", T: Info },
    { no: 3, name: "servers", kind: "message", T: Server, repeated: true },
    { no: 4, name: "paths", kind: "message", T: Paths },
    { no: 5, name: "components", kind: "message", T: Components },
    { no: 6, name: "security", kind: "message", T: SecurityRequirement, repeated: true },
    { no: 7, name: "tags", kind: "message", T: Tag, repeated: true },
    { no: 8, name: "external_docs", kind: "message", T: ExternalDocs },
    { no: 9, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Document {
    return new Document().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Document {
    return new Document().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Document {
    return new Document().fromJsonString(jsonString, options);
  }

  static equals(a: Document | PlainMessage<Document> | undefined, b: Document | PlainMessage<Document> | undefined): boolean {
    return proto3.util.equals(Document, a, b);
  }
}

/**
 * A single encoding definition applied to a single schema property.
 *
 * @generated from message gnostic.openapi.v3.Encoding
 */
export class Encoding extends Message<Encoding> {
  /**
   * @generated from field: string content_type = 1;
   */
  contentType = "";

  /**
   * @generated from field: gnostic.openapi.v3.HeadersOrReferences headers = 2;
   */
  headers?: HeadersOrReferences;

  /**
   * @generated from field: string style = 3;
   */
  style = "";

  /**
   * @generated from field: bool explode = 4;
   */
  explode = false;

  /**
   * @generated from field: bool allow_reserved = 5;
   */
  allowReserved = false;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 6;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Encoding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Encoding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "headers", kind: "message", T: HeadersOrReferences },
    { no: 3, name: "style", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "explode", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "allow_reserved", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Encoding {
    return new Encoding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Encoding {
    return new Encoding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Encoding {
    return new Encoding().fromJsonString(jsonString, options);
  }

  static equals(a: Encoding | PlainMessage<Encoding> | undefined, b: Encoding | PlainMessage<Encoding> | undefined): boolean {
    return proto3.util.equals(Encoding, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.Encodings
 */
export class Encodings extends Message<Encodings> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedEncoding additional_properties = 1;
   */
  additionalProperties: NamedEncoding[] = [];

  constructor(data?: PartialMessage<Encodings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Encodings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedEncoding, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Encodings {
    return new Encodings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Encodings {
    return new Encodings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Encodings {
    return new Encodings().fromJsonString(jsonString, options);
  }

  static equals(a: Encodings | PlainMessage<Encodings> | undefined, b: Encodings | PlainMessage<Encodings> | undefined): boolean {
    return proto3.util.equals(Encodings, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.Example
 */
export class Example extends Message<Example> {
  /**
   * @generated from field: string summary = 1;
   */
  summary = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: gnostic.openapi.v3.Any value = 3;
   */
  value?: Any;

  /**
   * @generated from field: string external_value = 4;
   */
  externalValue = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Example>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Example";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "summary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "message", T: Any },
    { no: 4, name: "external_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Example {
    return new Example().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Example {
    return new Example().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Example {
    return new Example().fromJsonString(jsonString, options);
  }

  static equals(a: Example | PlainMessage<Example> | undefined, b: Example | PlainMessage<Example> | undefined): boolean {
    return proto3.util.equals(Example, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.ExampleOrReference
 */
export class ExampleOrReference extends Message<ExampleOrReference> {
  /**
   * @generated from oneof gnostic.openapi.v3.ExampleOrReference.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.Example example = 1;
     */
    value: Example;
    case: "example";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Reference reference = 2;
     */
    value: Reference;
    case: "reference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExampleOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ExampleOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "example", kind: "message", T: Example, oneof: "oneof" },
    { no: 2, name: "reference", kind: "message", T: Reference, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExampleOrReference {
    return new ExampleOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExampleOrReference {
    return new ExampleOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExampleOrReference {
    return new ExampleOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: ExampleOrReference | PlainMessage<ExampleOrReference> | undefined, b: ExampleOrReference | PlainMessage<ExampleOrReference> | undefined): boolean {
    return proto3.util.equals(ExampleOrReference, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.ExamplesOrReferences
 */
export class ExamplesOrReferences extends Message<ExamplesOrReferences> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedExampleOrReference additional_properties = 1;
   */
  additionalProperties: NamedExampleOrReference[] = [];

  constructor(data?: PartialMessage<ExamplesOrReferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ExamplesOrReferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedExampleOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExamplesOrReferences {
    return new ExamplesOrReferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExamplesOrReferences {
    return new ExamplesOrReferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExamplesOrReferences {
    return new ExamplesOrReferences().fromJsonString(jsonString, options);
  }

  static equals(a: ExamplesOrReferences | PlainMessage<ExamplesOrReferences> | undefined, b: ExamplesOrReferences | PlainMessage<ExamplesOrReferences> | undefined): boolean {
    return proto3.util.equals(ExamplesOrReferences, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.Expression
 */
export class Expression extends Message<Expression> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny additional_properties = 1;
   */
  additionalProperties: NamedAny[] = [];

  constructor(data?: PartialMessage<Expression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Expression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Expression {
    return new Expression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Expression {
    return new Expression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Expression {
    return new Expression().fromJsonString(jsonString, options);
  }

  static equals(a: Expression | PlainMessage<Expression> | undefined, b: Expression | PlainMessage<Expression> | undefined): boolean {
    return proto3.util.equals(Expression, a, b);
  }
}

/**
 * Allows referencing an external resource for extended documentation.
 *
 * @generated from message gnostic.openapi.v3.ExternalDocs
 */
export class ExternalDocs extends Message<ExternalDocs> {
  /**
   * @generated from field: string description = 1;
   */
  description = "";

  /**
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 3;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<ExternalDocs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ExternalDocs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExternalDocs {
    return new ExternalDocs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExternalDocs {
    return new ExternalDocs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExternalDocs {
    return new ExternalDocs().fromJsonString(jsonString, options);
  }

  static equals(a: ExternalDocs | PlainMessage<ExternalDocs> | undefined, b: ExternalDocs | PlainMessage<ExternalDocs> | undefined): boolean {
    return proto3.util.equals(ExternalDocs, a, b);
  }
}

/**
 * The Header Object follows the structure of the Parameter Object with the following changes:  1. `name` MUST NOT be specified, it is given in the corresponding `headers` map. 1. `in` MUST NOT be specified, it is implicitly in `header`. 1. All traits that are affected by the location MUST be applicable to a location of `header` (for example, `style`).
 *
 * @generated from message gnostic.openapi.v3.Header
 */
export class Header extends Message<Header> {
  /**
   * @generated from field: string description = 1;
   */
  description = "";

  /**
   * @generated from field: bool required = 2;
   */
  required = false;

  /**
   * @generated from field: bool deprecated = 3;
   */
  deprecated = false;

  /**
   * @generated from field: bool allow_empty_value = 4;
   */
  allowEmptyValue = false;

  /**
   * @generated from field: string style = 5;
   */
  style = "";

  /**
   * @generated from field: bool explode = 6;
   */
  explode = false;

  /**
   * @generated from field: bool allow_reserved = 7;
   */
  allowReserved = false;

  /**
   * @generated from field: gnostic.openapi.v3.SchemaOrReference schema = 8;
   */
  schema?: SchemaOrReference;

  /**
   * @generated from field: gnostic.openapi.v3.Any example = 9;
   */
  example?: Any;

  /**
   * @generated from field: gnostic.openapi.v3.ExamplesOrReferences examples = 10;
   */
  examples?: ExamplesOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.MediaTypes content = 11;
   */
  content?: MediaTypes;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 12;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Header>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Header";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "required", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "deprecated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "allow_empty_value", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "style", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "explode", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "allow_reserved", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "schema", kind: "message", T: SchemaOrReference },
    { no: 9, name: "example", kind: "message", T: Any },
    { no: 10, name: "examples", kind: "message", T: ExamplesOrReferences },
    { no: 11, name: "content", kind: "message", T: MediaTypes },
    { no: 12, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Header {
    return new Header().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Header {
    return new Header().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Header {
    return new Header().fromJsonString(jsonString, options);
  }

  static equals(a: Header | PlainMessage<Header> | undefined, b: Header | PlainMessage<Header> | undefined): boolean {
    return proto3.util.equals(Header, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.HeaderOrReference
 */
export class HeaderOrReference extends Message<HeaderOrReference> {
  /**
   * @generated from oneof gnostic.openapi.v3.HeaderOrReference.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.Header header = 1;
     */
    value: Header;
    case: "header";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Reference reference = 2;
     */
    value: Reference;
    case: "reference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<HeaderOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.HeaderOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: Header, oneof: "oneof" },
    { no: 2, name: "reference", kind: "message", T: Reference, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeaderOrReference {
    return new HeaderOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeaderOrReference {
    return new HeaderOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeaderOrReference {
    return new HeaderOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: HeaderOrReference | PlainMessage<HeaderOrReference> | undefined, b: HeaderOrReference | PlainMessage<HeaderOrReference> | undefined): boolean {
    return proto3.util.equals(HeaderOrReference, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.HeadersOrReferences
 */
export class HeadersOrReferences extends Message<HeadersOrReferences> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedHeaderOrReference additional_properties = 1;
   */
  additionalProperties: NamedHeaderOrReference[] = [];

  constructor(data?: PartialMessage<HeadersOrReferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.HeadersOrReferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedHeaderOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeadersOrReferences {
    return new HeadersOrReferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeadersOrReferences {
    return new HeadersOrReferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeadersOrReferences {
    return new HeadersOrReferences().fromJsonString(jsonString, options);
  }

  static equals(a: HeadersOrReferences | PlainMessage<HeadersOrReferences> | undefined, b: HeadersOrReferences | PlainMessage<HeadersOrReferences> | undefined): boolean {
    return proto3.util.equals(HeadersOrReferences, a, b);
  }
}

/**
 * The object provides metadata about the API. The metadata MAY be used by the clients if needed, and MAY be presented in editing or documentation generation tools for convenience.
 *
 * @generated from message gnostic.openapi.v3.Info
 */
export class Info extends Message<Info> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: string terms_of_service = 3;
   */
  termsOfService = "";

  /**
   * @generated from field: gnostic.openapi.v3.Contact contact = 4;
   */
  contact?: Contact;

  /**
   * @generated from field: gnostic.openapi.v3.License license = 5;
   */
  license?: License;

  /**
   * @generated from field: string version = 6;
   */
  version = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 7;
   */
  specificationExtension: NamedAny[] = [];

  /**
   * @generated from field: string summary = 8;
   */
  summary = "";

  constructor(data?: PartialMessage<Info>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Info";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "terms_of_service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "contact", kind: "message", T: Contact },
    { no: 5, name: "license", kind: "message", T: License },
    { no: 6, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
    { no: 8, name: "summary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info {
    return new Info().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info {
    return new Info().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info {
    return new Info().fromJsonString(jsonString, options);
  }

  static equals(a: Info | PlainMessage<Info> | undefined, b: Info | PlainMessage<Info> | undefined): boolean {
    return proto3.util.equals(Info, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.ItemsItem
 */
export class ItemsItem extends Message<ItemsItem> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.SchemaOrReference schema_or_reference = 1;
   */
  schemaOrReference: SchemaOrReference[] = [];

  constructor(data?: PartialMessage<ItemsItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ItemsItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema_or_reference", kind: "message", T: SchemaOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ItemsItem {
    return new ItemsItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ItemsItem {
    return new ItemsItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ItemsItem {
    return new ItemsItem().fromJsonString(jsonString, options);
  }

  static equals(a: ItemsItem | PlainMessage<ItemsItem> | undefined, b: ItemsItem | PlainMessage<ItemsItem> | undefined): boolean {
    return proto3.util.equals(ItemsItem, a, b);
  }
}

/**
 * License information for the exposed API.
 *
 * @generated from message gnostic.openapi.v3.License
 */
export class License extends Message<License> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 3;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<License>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.License";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License {
    return new License().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License {
    return new License().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License {
    return new License().fromJsonString(jsonString, options);
  }

  static equals(a: License | PlainMessage<License> | undefined, b: License | PlainMessage<License> | undefined): boolean {
    return proto3.util.equals(License, a, b);
  }
}

/**
 * The `Link object` represents a possible design-time link for a response. The presence of a link does not guarantee the caller's ability to successfully invoke it, rather it provides a known relationship and traversal mechanism between responses and other operations.  Unlike _dynamic_ links (i.e. links provided **in** the response payload), the OAS linking mechanism does not require link information in the runtime response.  For computing links, and providing instructions to execute them, a runtime expression is used for accessing values in an operation and using them as parameters while invoking the linked operation.
 *
 * @generated from message gnostic.openapi.v3.Link
 */
export class Link extends Message<Link> {
  /**
   * @generated from field: string operation_ref = 1;
   */
  operationRef = "";

  /**
   * @generated from field: string operation_id = 2;
   */
  operationId = "";

  /**
   * @generated from field: gnostic.openapi.v3.AnyOrExpression parameters = 3;
   */
  parameters?: AnyOrExpression;

  /**
   * @generated from field: gnostic.openapi.v3.AnyOrExpression request_body = 4;
   */
  requestBody?: AnyOrExpression;

  /**
   * @generated from field: string description = 5;
   */
  description = "";

  /**
   * @generated from field: gnostic.openapi.v3.Server server = 6;
   */
  server?: Server;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 7;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Link>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Link";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "parameters", kind: "message", T: AnyOrExpression },
    { no: 4, name: "request_body", kind: "message", T: AnyOrExpression },
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "server", kind: "message", T: Server },
    { no: 7, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Link {
    return new Link().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Link {
    return new Link().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Link {
    return new Link().fromJsonString(jsonString, options);
  }

  static equals(a: Link | PlainMessage<Link> | undefined, b: Link | PlainMessage<Link> | undefined): boolean {
    return proto3.util.equals(Link, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.LinkOrReference
 */
export class LinkOrReference extends Message<LinkOrReference> {
  /**
   * @generated from oneof gnostic.openapi.v3.LinkOrReference.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.Link link = 1;
     */
    value: Link;
    case: "link";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Reference reference = 2;
     */
    value: Reference;
    case: "reference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LinkOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.LinkOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "link", kind: "message", T: Link, oneof: "oneof" },
    { no: 2, name: "reference", kind: "message", T: Reference, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinkOrReference {
    return new LinkOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinkOrReference {
    return new LinkOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinkOrReference {
    return new LinkOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: LinkOrReference | PlainMessage<LinkOrReference> | undefined, b: LinkOrReference | PlainMessage<LinkOrReference> | undefined): boolean {
    return proto3.util.equals(LinkOrReference, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.LinksOrReferences
 */
export class LinksOrReferences extends Message<LinksOrReferences> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedLinkOrReference additional_properties = 1;
   */
  additionalProperties: NamedLinkOrReference[] = [];

  constructor(data?: PartialMessage<LinksOrReferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.LinksOrReferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedLinkOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinksOrReferences {
    return new LinksOrReferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinksOrReferences {
    return new LinksOrReferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinksOrReferences {
    return new LinksOrReferences().fromJsonString(jsonString, options);
  }

  static equals(a: LinksOrReferences | PlainMessage<LinksOrReferences> | undefined, b: LinksOrReferences | PlainMessage<LinksOrReferences> | undefined): boolean {
    return proto3.util.equals(LinksOrReferences, a, b);
  }
}

/**
 * Each Media Type Object provides schema and examples for the media type identified by its key.
 *
 * @generated from message gnostic.openapi.v3.MediaType
 */
export class MediaType extends Message<MediaType> {
  /**
   * @generated from field: gnostic.openapi.v3.SchemaOrReference schema = 1;
   */
  schema?: SchemaOrReference;

  /**
   * @generated from field: gnostic.openapi.v3.Any example = 2;
   */
  example?: Any;

  /**
   * @generated from field: gnostic.openapi.v3.ExamplesOrReferences examples = 3;
   */
  examples?: ExamplesOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.Encodings encoding = 4;
   */
  encoding?: Encodings;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<MediaType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.MediaType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "message", T: SchemaOrReference },
    { no: 2, name: "example", kind: "message", T: Any },
    { no: 3, name: "examples", kind: "message", T: ExamplesOrReferences },
    { no: 4, name: "encoding", kind: "message", T: Encodings },
    { no: 5, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MediaType {
    return new MediaType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MediaType {
    return new MediaType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MediaType {
    return new MediaType().fromJsonString(jsonString, options);
  }

  static equals(a: MediaType | PlainMessage<MediaType> | undefined, b: MediaType | PlainMessage<MediaType> | undefined): boolean {
    return proto3.util.equals(MediaType, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.MediaTypes
 */
export class MediaTypes extends Message<MediaTypes> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedMediaType additional_properties = 1;
   */
  additionalProperties: NamedMediaType[] = [];

  constructor(data?: PartialMessage<MediaTypes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.MediaTypes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedMediaType, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MediaTypes {
    return new MediaTypes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MediaTypes {
    return new MediaTypes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MediaTypes {
    return new MediaTypes().fromJsonString(jsonString, options);
  }

  static equals(a: MediaTypes | PlainMessage<MediaTypes> | undefined, b: MediaTypes | PlainMessage<MediaTypes> | undefined): boolean {
    return proto3.util.equals(MediaTypes, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of Any as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedAny
 */
export class NamedAny extends Message<NamedAny> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.Any value = 2;
   */
  value?: Any;

  constructor(data?: PartialMessage<NamedAny>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedAny";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: Any },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedAny {
    return new NamedAny().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedAny {
    return new NamedAny().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedAny {
    return new NamedAny().fromJsonString(jsonString, options);
  }

  static equals(a: NamedAny | PlainMessage<NamedAny> | undefined, b: NamedAny | PlainMessage<NamedAny> | undefined): boolean {
    return proto3.util.equals(NamedAny, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of CallbackOrReference as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedCallbackOrReference
 */
export class NamedCallbackOrReference extends Message<NamedCallbackOrReference> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.CallbackOrReference value = 2;
   */
  value?: CallbackOrReference;

  constructor(data?: PartialMessage<NamedCallbackOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedCallbackOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: CallbackOrReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedCallbackOrReference {
    return new NamedCallbackOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedCallbackOrReference {
    return new NamedCallbackOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedCallbackOrReference {
    return new NamedCallbackOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: NamedCallbackOrReference | PlainMessage<NamedCallbackOrReference> | undefined, b: NamedCallbackOrReference | PlainMessage<NamedCallbackOrReference> | undefined): boolean {
    return proto3.util.equals(NamedCallbackOrReference, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of Encoding as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedEncoding
 */
export class NamedEncoding extends Message<NamedEncoding> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.Encoding value = 2;
   */
  value?: Encoding;

  constructor(data?: PartialMessage<NamedEncoding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedEncoding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: Encoding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedEncoding {
    return new NamedEncoding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedEncoding {
    return new NamedEncoding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedEncoding {
    return new NamedEncoding().fromJsonString(jsonString, options);
  }

  static equals(a: NamedEncoding | PlainMessage<NamedEncoding> | undefined, b: NamedEncoding | PlainMessage<NamedEncoding> | undefined): boolean {
    return proto3.util.equals(NamedEncoding, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of ExampleOrReference as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedExampleOrReference
 */
export class NamedExampleOrReference extends Message<NamedExampleOrReference> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.ExampleOrReference value = 2;
   */
  value?: ExampleOrReference;

  constructor(data?: PartialMessage<NamedExampleOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedExampleOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: ExampleOrReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedExampleOrReference {
    return new NamedExampleOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedExampleOrReference {
    return new NamedExampleOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedExampleOrReference {
    return new NamedExampleOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: NamedExampleOrReference | PlainMessage<NamedExampleOrReference> | undefined, b: NamedExampleOrReference | PlainMessage<NamedExampleOrReference> | undefined): boolean {
    return proto3.util.equals(NamedExampleOrReference, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of HeaderOrReference as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedHeaderOrReference
 */
export class NamedHeaderOrReference extends Message<NamedHeaderOrReference> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.HeaderOrReference value = 2;
   */
  value?: HeaderOrReference;

  constructor(data?: PartialMessage<NamedHeaderOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedHeaderOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: HeaderOrReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedHeaderOrReference {
    return new NamedHeaderOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedHeaderOrReference {
    return new NamedHeaderOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedHeaderOrReference {
    return new NamedHeaderOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: NamedHeaderOrReference | PlainMessage<NamedHeaderOrReference> | undefined, b: NamedHeaderOrReference | PlainMessage<NamedHeaderOrReference> | undefined): boolean {
    return proto3.util.equals(NamedHeaderOrReference, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of LinkOrReference as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedLinkOrReference
 */
export class NamedLinkOrReference extends Message<NamedLinkOrReference> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.LinkOrReference value = 2;
   */
  value?: LinkOrReference;

  constructor(data?: PartialMessage<NamedLinkOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedLinkOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: LinkOrReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedLinkOrReference {
    return new NamedLinkOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedLinkOrReference {
    return new NamedLinkOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedLinkOrReference {
    return new NamedLinkOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: NamedLinkOrReference | PlainMessage<NamedLinkOrReference> | undefined, b: NamedLinkOrReference | PlainMessage<NamedLinkOrReference> | undefined): boolean {
    return proto3.util.equals(NamedLinkOrReference, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of MediaType as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedMediaType
 */
export class NamedMediaType extends Message<NamedMediaType> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.MediaType value = 2;
   */
  value?: MediaType;

  constructor(data?: PartialMessage<NamedMediaType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedMediaType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: MediaType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedMediaType {
    return new NamedMediaType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedMediaType {
    return new NamedMediaType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedMediaType {
    return new NamedMediaType().fromJsonString(jsonString, options);
  }

  static equals(a: NamedMediaType | PlainMessage<NamedMediaType> | undefined, b: NamedMediaType | PlainMessage<NamedMediaType> | undefined): boolean {
    return proto3.util.equals(NamedMediaType, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of ParameterOrReference as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedParameterOrReference
 */
export class NamedParameterOrReference extends Message<NamedParameterOrReference> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.ParameterOrReference value = 2;
   */
  value?: ParameterOrReference;

  constructor(data?: PartialMessage<NamedParameterOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedParameterOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: ParameterOrReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedParameterOrReference {
    return new NamedParameterOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedParameterOrReference {
    return new NamedParameterOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedParameterOrReference {
    return new NamedParameterOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: NamedParameterOrReference | PlainMessage<NamedParameterOrReference> | undefined, b: NamedParameterOrReference | PlainMessage<NamedParameterOrReference> | undefined): boolean {
    return proto3.util.equals(NamedParameterOrReference, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of PathItem as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedPathItem
 */
export class NamedPathItem extends Message<NamedPathItem> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.PathItem value = 2;
   */
  value?: PathItem;

  constructor(data?: PartialMessage<NamedPathItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedPathItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: PathItem },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedPathItem {
    return new NamedPathItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedPathItem {
    return new NamedPathItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedPathItem {
    return new NamedPathItem().fromJsonString(jsonString, options);
  }

  static equals(a: NamedPathItem | PlainMessage<NamedPathItem> | undefined, b: NamedPathItem | PlainMessage<NamedPathItem> | undefined): boolean {
    return proto3.util.equals(NamedPathItem, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of RequestBodyOrReference as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedRequestBodyOrReference
 */
export class NamedRequestBodyOrReference extends Message<NamedRequestBodyOrReference> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.RequestBodyOrReference value = 2;
   */
  value?: RequestBodyOrReference;

  constructor(data?: PartialMessage<NamedRequestBodyOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedRequestBodyOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: RequestBodyOrReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedRequestBodyOrReference {
    return new NamedRequestBodyOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedRequestBodyOrReference {
    return new NamedRequestBodyOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedRequestBodyOrReference {
    return new NamedRequestBodyOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: NamedRequestBodyOrReference | PlainMessage<NamedRequestBodyOrReference> | undefined, b: NamedRequestBodyOrReference | PlainMessage<NamedRequestBodyOrReference> | undefined): boolean {
    return proto3.util.equals(NamedRequestBodyOrReference, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of ResponseOrReference as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedResponseOrReference
 */
export class NamedResponseOrReference extends Message<NamedResponseOrReference> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.ResponseOrReference value = 2;
   */
  value?: ResponseOrReference;

  constructor(data?: PartialMessage<NamedResponseOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedResponseOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: ResponseOrReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedResponseOrReference {
    return new NamedResponseOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedResponseOrReference {
    return new NamedResponseOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedResponseOrReference {
    return new NamedResponseOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: NamedResponseOrReference | PlainMessage<NamedResponseOrReference> | undefined, b: NamedResponseOrReference | PlainMessage<NamedResponseOrReference> | undefined): boolean {
    return proto3.util.equals(NamedResponseOrReference, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of SchemaOrReference as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedSchemaOrReference
 */
export class NamedSchemaOrReference extends Message<NamedSchemaOrReference> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.SchemaOrReference value = 2;
   */
  value?: SchemaOrReference;

  constructor(data?: PartialMessage<NamedSchemaOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedSchemaOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: SchemaOrReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedSchemaOrReference {
    return new NamedSchemaOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedSchemaOrReference {
    return new NamedSchemaOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedSchemaOrReference {
    return new NamedSchemaOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: NamedSchemaOrReference | PlainMessage<NamedSchemaOrReference> | undefined, b: NamedSchemaOrReference | PlainMessage<NamedSchemaOrReference> | undefined): boolean {
    return proto3.util.equals(NamedSchemaOrReference, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of SecuritySchemeOrReference as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedSecuritySchemeOrReference
 */
export class NamedSecuritySchemeOrReference extends Message<NamedSecuritySchemeOrReference> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.SecuritySchemeOrReference value = 2;
   */
  value?: SecuritySchemeOrReference;

  constructor(data?: PartialMessage<NamedSecuritySchemeOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedSecuritySchemeOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: SecuritySchemeOrReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedSecuritySchemeOrReference {
    return new NamedSecuritySchemeOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedSecuritySchemeOrReference {
    return new NamedSecuritySchemeOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedSecuritySchemeOrReference {
    return new NamedSecuritySchemeOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: NamedSecuritySchemeOrReference | PlainMessage<NamedSecuritySchemeOrReference> | undefined, b: NamedSecuritySchemeOrReference | PlainMessage<NamedSecuritySchemeOrReference> | undefined): boolean {
    return proto3.util.equals(NamedSecuritySchemeOrReference, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of ServerVariable as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedServerVariable
 */
export class NamedServerVariable extends Message<NamedServerVariable> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.ServerVariable value = 2;
   */
  value?: ServerVariable;

  constructor(data?: PartialMessage<NamedServerVariable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedServerVariable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: ServerVariable },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedServerVariable {
    return new NamedServerVariable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedServerVariable {
    return new NamedServerVariable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedServerVariable {
    return new NamedServerVariable().fromJsonString(jsonString, options);
  }

  static equals(a: NamedServerVariable | PlainMessage<NamedServerVariable> | undefined, b: NamedServerVariable | PlainMessage<NamedServerVariable> | undefined): boolean {
    return proto3.util.equals(NamedServerVariable, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of string as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedString
 */
export class NamedString extends Message<NamedString> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<NamedString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedString {
    return new NamedString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedString {
    return new NamedString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedString {
    return new NamedString().fromJsonString(jsonString, options);
  }

  static equals(a: NamedString | PlainMessage<NamedString> | undefined, b: NamedString | PlainMessage<NamedString> | undefined): boolean {
    return proto3.util.equals(NamedString, a, b);
  }
}

/**
 * Automatically-generated message used to represent maps of StringArray as ordered (name,value) pairs.
 *
 * @generated from message gnostic.openapi.v3.NamedStringArray
 */
export class NamedStringArray extends Message<NamedStringArray> {
  /**
   * Map key
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Mapped value
   *
   * @generated from field: gnostic.openapi.v3.StringArray value = 2;
   */
  value?: StringArray;

  constructor(data?: PartialMessage<NamedStringArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.NamedStringArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: StringArray },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedStringArray {
    return new NamedStringArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedStringArray {
    return new NamedStringArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedStringArray {
    return new NamedStringArray().fromJsonString(jsonString, options);
  }

  static equals(a: NamedStringArray | PlainMessage<NamedStringArray> | undefined, b: NamedStringArray | PlainMessage<NamedStringArray> | undefined): boolean {
    return proto3.util.equals(NamedStringArray, a, b);
  }
}

/**
 * Configuration details for a supported OAuth Flow
 *
 * @generated from message gnostic.openapi.v3.OauthFlow
 */
export class OauthFlow extends Message<OauthFlow> {
  /**
   * @generated from field: string authorization_url = 1;
   */
  authorizationUrl = "";

  /**
   * @generated from field: string token_url = 2;
   */
  tokenUrl = "";

  /**
   * @generated from field: string refresh_url = 3;
   */
  refreshUrl = "";

  /**
   * @generated from field: gnostic.openapi.v3.Strings scopes = 4;
   */
  scopes?: Strings;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<OauthFlow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.OauthFlow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authorization_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "token_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "refresh_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "scopes", kind: "message", T: Strings },
    { no: 5, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OauthFlow {
    return new OauthFlow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OauthFlow {
    return new OauthFlow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OauthFlow {
    return new OauthFlow().fromJsonString(jsonString, options);
  }

  static equals(a: OauthFlow | PlainMessage<OauthFlow> | undefined, b: OauthFlow | PlainMessage<OauthFlow> | undefined): boolean {
    return proto3.util.equals(OauthFlow, a, b);
  }
}

/**
 * Allows configuration of the supported OAuth Flows.
 *
 * @generated from message gnostic.openapi.v3.OauthFlows
 */
export class OauthFlows extends Message<OauthFlows> {
  /**
   * @generated from field: gnostic.openapi.v3.OauthFlow implicit = 1;
   */
  implicit?: OauthFlow;

  /**
   * @generated from field: gnostic.openapi.v3.OauthFlow password = 2;
   */
  password?: OauthFlow;

  /**
   * @generated from field: gnostic.openapi.v3.OauthFlow client_credentials = 3;
   */
  clientCredentials?: OauthFlow;

  /**
   * @generated from field: gnostic.openapi.v3.OauthFlow authorization_code = 4;
   */
  authorizationCode?: OauthFlow;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<OauthFlows>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.OauthFlows";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "implicit", kind: "message", T: OauthFlow },
    { no: 2, name: "password", kind: "message", T: OauthFlow },
    { no: 3, name: "client_credentials", kind: "message", T: OauthFlow },
    { no: 4, name: "authorization_code", kind: "message", T: OauthFlow },
    { no: 5, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OauthFlows {
    return new OauthFlows().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OauthFlows {
    return new OauthFlows().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OauthFlows {
    return new OauthFlows().fromJsonString(jsonString, options);
  }

  static equals(a: OauthFlows | PlainMessage<OauthFlows> | undefined, b: OauthFlows | PlainMessage<OauthFlows> | undefined): boolean {
    return proto3.util.equals(OauthFlows, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.Object
 */
export class Object$ extends Message<Object$> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny additional_properties = 1;
   */
  additionalProperties: NamedAny[] = [];

  constructor(data?: PartialMessage<Object$>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Object";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object$ {
    return new Object$().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJsonString(jsonString, options);
  }

  static equals(a: Object$ | PlainMessage<Object$> | undefined, b: Object$ | PlainMessage<Object$> | undefined): boolean {
    return proto3.util.equals(Object$, a, b);
  }
}

/**
 * Describes a single API operation on a path.
 *
 * @generated from message gnostic.openapi.v3.Operation
 */
export class Operation extends Message<Operation> {
  /**
   * @generated from field: repeated string tags = 1;
   */
  tags: string[] = [];

  /**
   * @generated from field: string summary = 2;
   */
  summary = "";

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * @generated from field: gnostic.openapi.v3.ExternalDocs external_docs = 4;
   */
  externalDocs?: ExternalDocs;

  /**
   * @generated from field: string operation_id = 5;
   */
  operationId = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.ParameterOrReference parameters = 6;
   */
  parameters: ParameterOrReference[] = [];

  /**
   * @generated from field: gnostic.openapi.v3.RequestBodyOrReference request_body = 7;
   */
  requestBody?: RequestBodyOrReference;

  /**
   * @generated from field: gnostic.openapi.v3.Responses responses = 8;
   */
  responses?: Responses;

  /**
   * @generated from field: gnostic.openapi.v3.CallbacksOrReferences callbacks = 9;
   */
  callbacks?: CallbacksOrReferences;

  /**
   * @generated from field: bool deprecated = 10;
   */
  deprecated = false;

  /**
   * @generated from field: repeated gnostic.openapi.v3.SecurityRequirement security = 11;
   */
  security: SecurityRequirement[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.Server servers = 12;
   */
  servers: Server[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 13;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Operation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Operation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "summary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "external_docs", kind: "message", T: ExternalDocs },
    { no: 5, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "parameters", kind: "message", T: ParameterOrReference, repeated: true },
    { no: 7, name: "request_body", kind: "message", T: RequestBodyOrReference },
    { no: 8, name: "responses", kind: "message", T: Responses },
    { no: 9, name: "callbacks", kind: "message", T: CallbacksOrReferences },
    { no: 10, name: "deprecated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "security", kind: "message", T: SecurityRequirement, repeated: true },
    { no: 12, name: "servers", kind: "message", T: Server, repeated: true },
    { no: 13, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation {
    return new Operation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJsonString(jsonString, options);
  }

  static equals(a: Operation | PlainMessage<Operation> | undefined, b: Operation | PlainMessage<Operation> | undefined): boolean {
    return proto3.util.equals(Operation, a, b);
  }
}

/**
 * Describes a single operation parameter.  A unique parameter is defined by a combination of a name and location.
 *
 * @generated from message gnostic.openapi.v3.Parameter
 */
export class Parameter extends Message<Parameter> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string in = 2;
   */
  in = "";

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * @generated from field: bool required = 4;
   */
  required = false;

  /**
   * @generated from field: bool deprecated = 5;
   */
  deprecated = false;

  /**
   * @generated from field: bool allow_empty_value = 6;
   */
  allowEmptyValue = false;

  /**
   * @generated from field: string style = 7;
   */
  style = "";

  /**
   * @generated from field: bool explode = 8;
   */
  explode = false;

  /**
   * @generated from field: bool allow_reserved = 9;
   */
  allowReserved = false;

  /**
   * @generated from field: gnostic.openapi.v3.SchemaOrReference schema = 10;
   */
  schema?: SchemaOrReference;

  /**
   * @generated from field: gnostic.openapi.v3.Any example = 11;
   */
  example?: Any;

  /**
   * @generated from field: gnostic.openapi.v3.ExamplesOrReferences examples = 12;
   */
  examples?: ExamplesOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.MediaTypes content = 13;
   */
  content?: MediaTypes;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 14;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Parameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Parameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "in", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "required", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "deprecated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "allow_empty_value", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "style", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "explode", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "allow_reserved", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "schema", kind: "message", T: SchemaOrReference },
    { no: 11, name: "example", kind: "message", T: Any },
    { no: 12, name: "examples", kind: "message", T: ExamplesOrReferences },
    { no: 13, name: "content", kind: "message", T: MediaTypes },
    { no: 14, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Parameter {
    return new Parameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Parameter {
    return new Parameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Parameter {
    return new Parameter().fromJsonString(jsonString, options);
  }

  static equals(a: Parameter | PlainMessage<Parameter> | undefined, b: Parameter | PlainMessage<Parameter> | undefined): boolean {
    return proto3.util.equals(Parameter, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.ParameterOrReference
 */
export class ParameterOrReference extends Message<ParameterOrReference> {
  /**
   * @generated from oneof gnostic.openapi.v3.ParameterOrReference.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.Parameter parameter = 1;
     */
    value: Parameter;
    case: "parameter";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Reference reference = 2;
     */
    value: Reference;
    case: "reference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ParameterOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ParameterOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parameter", kind: "message", T: Parameter, oneof: "oneof" },
    { no: 2, name: "reference", kind: "message", T: Reference, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParameterOrReference {
    return new ParameterOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParameterOrReference {
    return new ParameterOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParameterOrReference {
    return new ParameterOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: ParameterOrReference | PlainMessage<ParameterOrReference> | undefined, b: ParameterOrReference | PlainMessage<ParameterOrReference> | undefined): boolean {
    return proto3.util.equals(ParameterOrReference, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.ParametersOrReferences
 */
export class ParametersOrReferences extends Message<ParametersOrReferences> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedParameterOrReference additional_properties = 1;
   */
  additionalProperties: NamedParameterOrReference[] = [];

  constructor(data?: PartialMessage<ParametersOrReferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ParametersOrReferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedParameterOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParametersOrReferences {
    return new ParametersOrReferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParametersOrReferences {
    return new ParametersOrReferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParametersOrReferences {
    return new ParametersOrReferences().fromJsonString(jsonString, options);
  }

  static equals(a: ParametersOrReferences | PlainMessage<ParametersOrReferences> | undefined, b: ParametersOrReferences | PlainMessage<ParametersOrReferences> | undefined): boolean {
    return proto3.util.equals(ParametersOrReferences, a, b);
  }
}

/**
 * Describes the operations available on a single path. A Path Item MAY be empty, due to ACL constraints. The path itself is still exposed to the documentation viewer but they will not know which operations and parameters are available.
 *
 * @generated from message gnostic.openapi.v3.PathItem
 */
export class PathItem extends Message<PathItem> {
  /**
   * @generated from field: string _ref = 1;
   */
  Ref = "";

  /**
   * @generated from field: string summary = 2;
   */
  summary = "";

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * @generated from field: gnostic.openapi.v3.Operation get = 4;
   */
  get?: Operation;

  /**
   * @generated from field: gnostic.openapi.v3.Operation put = 5;
   */
  put?: Operation;

  /**
   * @generated from field: gnostic.openapi.v3.Operation post = 6;
   */
  post?: Operation;

  /**
   * @generated from field: gnostic.openapi.v3.Operation delete = 7;
   */
  delete?: Operation;

  /**
   * @generated from field: gnostic.openapi.v3.Operation options = 8;
   */
  options?: Operation;

  /**
   * @generated from field: gnostic.openapi.v3.Operation head = 9;
   */
  head?: Operation;

  /**
   * @generated from field: gnostic.openapi.v3.Operation patch = 10;
   */
  patch?: Operation;

  /**
   * @generated from field: gnostic.openapi.v3.Operation trace = 11;
   */
  trace?: Operation;

  /**
   * @generated from field: repeated gnostic.openapi.v3.Server servers = 12;
   */
  servers: Server[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.ParameterOrReference parameters = 13;
   */
  parameters: ParameterOrReference[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 14;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<PathItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.PathItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "summary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "get", kind: "message", T: Operation },
    { no: 5, name: "put", kind: "message", T: Operation },
    { no: 6, name: "post", kind: "message", T: Operation },
    { no: 7, name: "delete", kind: "message", T: Operation },
    { no: 8, name: "options", kind: "message", T: Operation },
    { no: 9, name: "head", kind: "message", T: Operation },
    { no: 10, name: "patch", kind: "message", T: Operation },
    { no: 11, name: "trace", kind: "message", T: Operation },
    { no: 12, name: "servers", kind: "message", T: Server, repeated: true },
    { no: 13, name: "parameters", kind: "message", T: ParameterOrReference, repeated: true },
    { no: 14, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PathItem {
    return new PathItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PathItem {
    return new PathItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PathItem {
    return new PathItem().fromJsonString(jsonString, options);
  }

  static equals(a: PathItem | PlainMessage<PathItem> | undefined, b: PathItem | PlainMessage<PathItem> | undefined): boolean {
    return proto3.util.equals(PathItem, a, b);
  }
}

/**
 * Holds the relative paths to the individual endpoints and their operations. The path is appended to the URL from the `Server Object` in order to construct the full URL.  The Paths MAY be empty, due to ACL constraints.
 *
 * @generated from message gnostic.openapi.v3.Paths
 */
export class Paths extends Message<Paths> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedPathItem path = 1;
   */
  path: NamedPathItem[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 2;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Paths>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Paths";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "message", T: NamedPathItem, repeated: true },
    { no: 2, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Paths {
    return new Paths().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Paths {
    return new Paths().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Paths {
    return new Paths().fromJsonString(jsonString, options);
  }

  static equals(a: Paths | PlainMessage<Paths> | undefined, b: Paths | PlainMessage<Paths> | undefined): boolean {
    return proto3.util.equals(Paths, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.Properties
 */
export class Properties extends Message<Properties> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
   */
  additionalProperties: NamedSchemaOrReference[] = [];

  constructor(data?: PartialMessage<Properties>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Properties";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedSchemaOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Properties {
    return new Properties().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Properties {
    return new Properties().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Properties {
    return new Properties().fromJsonString(jsonString, options);
  }

  static equals(a: Properties | PlainMessage<Properties> | undefined, b: Properties | PlainMessage<Properties> | undefined): boolean {
    return proto3.util.equals(Properties, a, b);
  }
}

/**
 * A simple object to allow referencing other components in the specification, internally and externally.  The Reference Object is defined by JSON Reference and follows the same structure, behavior and rules.   For this specification, reference resolution is accomplished as defined by the JSON Reference specification and not by the JSON Schema specification.
 *
 * @generated from message gnostic.openapi.v3.Reference
 */
export class Reference extends Message<Reference> {
  /**
   * @generated from field: string _ref = 1;
   */
  Ref = "";

  /**
   * @generated from field: string summary = 2;
   */
  summary = "";

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  constructor(data?: PartialMessage<Reference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Reference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "_ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "summary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Reference {
    return new Reference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJsonString(jsonString, options);
  }

  static equals(a: Reference | PlainMessage<Reference> | undefined, b: Reference | PlainMessage<Reference> | undefined): boolean {
    return proto3.util.equals(Reference, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.RequestBodiesOrReferences
 */
export class RequestBodiesOrReferences extends Message<RequestBodiesOrReferences> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedRequestBodyOrReference additional_properties = 1;
   */
  additionalProperties: NamedRequestBodyOrReference[] = [];

  constructor(data?: PartialMessage<RequestBodiesOrReferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.RequestBodiesOrReferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedRequestBodyOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestBodiesOrReferences {
    return new RequestBodiesOrReferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestBodiesOrReferences {
    return new RequestBodiesOrReferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestBodiesOrReferences {
    return new RequestBodiesOrReferences().fromJsonString(jsonString, options);
  }

  static equals(a: RequestBodiesOrReferences | PlainMessage<RequestBodiesOrReferences> | undefined, b: RequestBodiesOrReferences | PlainMessage<RequestBodiesOrReferences> | undefined): boolean {
    return proto3.util.equals(RequestBodiesOrReferences, a, b);
  }
}

/**
 * Describes a single request body.
 *
 * @generated from message gnostic.openapi.v3.RequestBody
 */
export class RequestBody extends Message<RequestBody> {
  /**
   * @generated from field: string description = 1;
   */
  description = "";

  /**
   * @generated from field: gnostic.openapi.v3.MediaTypes content = 2;
   */
  content?: MediaTypes;

  /**
   * @generated from field: bool required = 3;
   */
  required = false;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<RequestBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.RequestBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "content", kind: "message", T: MediaTypes },
    { no: 3, name: "required", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestBody {
    return new RequestBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestBody {
    return new RequestBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestBody {
    return new RequestBody().fromJsonString(jsonString, options);
  }

  static equals(a: RequestBody | PlainMessage<RequestBody> | undefined, b: RequestBody | PlainMessage<RequestBody> | undefined): boolean {
    return proto3.util.equals(RequestBody, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.RequestBodyOrReference
 */
export class RequestBodyOrReference extends Message<RequestBodyOrReference> {
  /**
   * @generated from oneof gnostic.openapi.v3.RequestBodyOrReference.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.RequestBody request_body = 1;
     */
    value: RequestBody;
    case: "requestBody";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Reference reference = 2;
     */
    value: Reference;
    case: "reference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RequestBodyOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.RequestBodyOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request_body", kind: "message", T: RequestBody, oneof: "oneof" },
    { no: 2, name: "reference", kind: "message", T: Reference, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestBodyOrReference {
    return new RequestBodyOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestBodyOrReference {
    return new RequestBodyOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestBodyOrReference {
    return new RequestBodyOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: RequestBodyOrReference | PlainMessage<RequestBodyOrReference> | undefined, b: RequestBodyOrReference | PlainMessage<RequestBodyOrReference> | undefined): boolean {
    return proto3.util.equals(RequestBodyOrReference, a, b);
  }
}

/**
 * Describes a single response from an API Operation, including design-time, static  `links` to operations based on the response.
 *
 * @generated from message gnostic.openapi.v3.Response
 */
export class Response extends Message<Response> {
  /**
   * @generated from field: string description = 1;
   */
  description = "";

  /**
   * @generated from field: gnostic.openapi.v3.HeadersOrReferences headers = 2;
   */
  headers?: HeadersOrReferences;

  /**
   * @generated from field: gnostic.openapi.v3.MediaTypes content = 3;
   */
  content?: MediaTypes;

  /**
   * @generated from field: gnostic.openapi.v3.LinksOrReferences links = 4;
   */
  links?: LinksOrReferences;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 5;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "headers", kind: "message", T: HeadersOrReferences },
    { no: 3, name: "content", kind: "message", T: MediaTypes },
    { no: 4, name: "links", kind: "message", T: LinksOrReferences },
    { no: 5, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Response {
    return new Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJsonString(jsonString, options);
  }

  static equals(a: Response | PlainMessage<Response> | undefined, b: Response | PlainMessage<Response> | undefined): boolean {
    return proto3.util.equals(Response, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.ResponseOrReference
 */
export class ResponseOrReference extends Message<ResponseOrReference> {
  /**
   * @generated from oneof gnostic.openapi.v3.ResponseOrReference.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.Response response = 1;
     */
    value: Response;
    case: "response";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Reference reference = 2;
     */
    value: Reference;
    case: "reference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ResponseOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ResponseOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "message", T: Response, oneof: "oneof" },
    { no: 2, name: "reference", kind: "message", T: Reference, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseOrReference {
    return new ResponseOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseOrReference {
    return new ResponseOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseOrReference {
    return new ResponseOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: ResponseOrReference | PlainMessage<ResponseOrReference> | undefined, b: ResponseOrReference | PlainMessage<ResponseOrReference> | undefined): boolean {
    return proto3.util.equals(ResponseOrReference, a, b);
  }
}

/**
 * A container for the expected responses of an operation. The container maps a HTTP response code to the expected response.  The documentation is not necessarily expected to cover all possible HTTP response codes because they may not be known in advance. However, documentation is expected to cover a successful operation response and any known errors.  The `default` MAY be used as a default response object for all HTTP codes  that are not covered individually by the specification.  The `Responses Object` MUST contain at least one response code, and it  SHOULD be the response for a successful operation call.
 *
 * @generated from message gnostic.openapi.v3.Responses
 */
export class Responses extends Message<Responses> {
  /**
   * @generated from field: gnostic.openapi.v3.ResponseOrReference default = 1;
   */
  default?: ResponseOrReference;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedResponseOrReference response_or_reference = 2;
   */
  responseOrReference: NamedResponseOrReference[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 3;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Responses>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Responses";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "default", kind: "message", T: ResponseOrReference },
    { no: 2, name: "response_or_reference", kind: "message", T: NamedResponseOrReference, repeated: true },
    { no: 3, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Responses {
    return new Responses().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Responses {
    return new Responses().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Responses {
    return new Responses().fromJsonString(jsonString, options);
  }

  static equals(a: Responses | PlainMessage<Responses> | undefined, b: Responses | PlainMessage<Responses> | undefined): boolean {
    return proto3.util.equals(Responses, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.ResponsesOrReferences
 */
export class ResponsesOrReferences extends Message<ResponsesOrReferences> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedResponseOrReference additional_properties = 1;
   */
  additionalProperties: NamedResponseOrReference[] = [];

  constructor(data?: PartialMessage<ResponsesOrReferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ResponsesOrReferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedResponseOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponsesOrReferences {
    return new ResponsesOrReferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponsesOrReferences {
    return new ResponsesOrReferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponsesOrReferences {
    return new ResponsesOrReferences().fromJsonString(jsonString, options);
  }

  static equals(a: ResponsesOrReferences | PlainMessage<ResponsesOrReferences> | undefined, b: ResponsesOrReferences | PlainMessage<ResponsesOrReferences> | undefined): boolean {
    return proto3.util.equals(ResponsesOrReferences, a, b);
  }
}

/**
 * The Schema Object allows the definition of input and output data types. These types can be objects, but also primitives and arrays. This object is an extended subset of the JSON Schema Specification Wright Draft 00.  For more information about the properties, see JSON Schema Core and JSON Schema Validation. Unless stated otherwise, the property definitions follow the JSON Schema.
 *
 * @generated from message gnostic.openapi.v3.Schema
 */
export class Schema extends Message<Schema> {
  /**
   * @generated from field: bool nullable = 1;
   */
  nullable = false;

  /**
   * @generated from field: gnostic.openapi.v3.Discriminator discriminator = 2;
   */
  discriminator?: Discriminator;

  /**
   * @generated from field: bool read_only = 3;
   */
  readOnly = false;

  /**
   * @generated from field: bool write_only = 4;
   */
  writeOnly = false;

  /**
   * @generated from field: gnostic.openapi.v3.Xml xml = 5;
   */
  xml?: Xml;

  /**
   * @generated from field: gnostic.openapi.v3.ExternalDocs external_docs = 6;
   */
  externalDocs?: ExternalDocs;

  /**
   * @generated from field: gnostic.openapi.v3.Any example = 7;
   */
  example?: Any;

  /**
   * @generated from field: bool deprecated = 8;
   */
  deprecated = false;

  /**
   * @generated from field: string title = 9;
   */
  title = "";

  /**
   * @generated from field: double multiple_of = 10;
   */
  multipleOf = 0;

  /**
   * @generated from field: double maximum = 11;
   */
  maximum = 0;

  /**
   * @generated from field: bool exclusive_maximum = 12;
   */
  exclusiveMaximum = false;

  /**
   * @generated from field: double minimum = 13;
   */
  minimum = 0;

  /**
   * @generated from field: bool exclusive_minimum = 14;
   */
  exclusiveMinimum = false;

  /**
   * @generated from field: int64 max_length = 15;
   */
  maxLength = protoInt64.zero;

  /**
   * @generated from field: int64 min_length = 16;
   */
  minLength = protoInt64.zero;

  /**
   * @generated from field: string pattern = 17;
   */
  pattern = "";

  /**
   * @generated from field: int64 max_items = 18;
   */
  maxItems = protoInt64.zero;

  /**
   * @generated from field: int64 min_items = 19;
   */
  minItems = protoInt64.zero;

  /**
   * @generated from field: bool unique_items = 20;
   */
  uniqueItems = false;

  /**
   * @generated from field: int64 max_properties = 21;
   */
  maxProperties = protoInt64.zero;

  /**
   * @generated from field: int64 min_properties = 22;
   */
  minProperties = protoInt64.zero;

  /**
   * @generated from field: repeated string required = 23;
   */
  required: string[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.Any enum = 24;
   */
  enum: Any[] = [];

  /**
   * @generated from field: string type = 25;
   */
  type = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.SchemaOrReference all_of = 26;
   */
  allOf: SchemaOrReference[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.SchemaOrReference one_of = 27;
   */
  oneOf: SchemaOrReference[] = [];

  /**
   * @generated from field: repeated gnostic.openapi.v3.SchemaOrReference any_of = 28;
   */
  anyOf: SchemaOrReference[] = [];

  /**
   * @generated from field: gnostic.openapi.v3.Schema not = 29;
   */
  not?: Schema;

  /**
   * @generated from field: gnostic.openapi.v3.ItemsItem items = 30;
   */
  items?: ItemsItem;

  /**
   * @generated from field: gnostic.openapi.v3.Properties properties = 31;
   */
  properties?: Properties;

  /**
   * @generated from field: gnostic.openapi.v3.AdditionalPropertiesItem additional_properties = 32;
   */
  additionalProperties?: AdditionalPropertiesItem;

  /**
   * @generated from field: gnostic.openapi.v3.DefaultType default = 33;
   */
  default?: DefaultType;

  /**
   * @generated from field: string description = 34;
   */
  description = "";

  /**
   * @generated from field: string format = 35;
   */
  format = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 36;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Schema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Schema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nullable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "discriminator", kind: "message", T: Discriminator },
    { no: 3, name: "read_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "write_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "xml", kind: "message", T: Xml },
    { no: 6, name: "external_docs", kind: "message", T: ExternalDocs },
    { no: 7, name: "example", kind: "message", T: Any },
    { no: 8, name: "deprecated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "multiple_of", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 11, name: "maximum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "exclusive_maximum", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "minimum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 14, name: "exclusive_minimum", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "max_length", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 16, name: "min_length", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 17, name: "pattern", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "max_items", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 19, name: "min_items", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 20, name: "unique_items", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 21, name: "max_properties", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 22, name: "min_properties", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 23, name: "required", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 24, name: "enum", kind: "message", T: Any, repeated: true },
    { no: 25, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 26, name: "all_of", kind: "message", T: SchemaOrReference, repeated: true },
    { no: 27, name: "one_of", kind: "message", T: SchemaOrReference, repeated: true },
    { no: 28, name: "any_of", kind: "message", T: SchemaOrReference, repeated: true },
    { no: 29, name: "not", kind: "message", T: Schema },
    { no: 30, name: "items", kind: "message", T: ItemsItem },
    { no: 31, name: "properties", kind: "message", T: Properties },
    { no: 32, name: "additional_properties", kind: "message", T: AdditionalPropertiesItem },
    { no: 33, name: "default", kind: "message", T: DefaultType },
    { no: 34, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 35, name: "format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 36, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Schema {
    return new Schema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Schema {
    return new Schema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Schema {
    return new Schema().fromJsonString(jsonString, options);
  }

  static equals(a: Schema | PlainMessage<Schema> | undefined, b: Schema | PlainMessage<Schema> | undefined): boolean {
    return proto3.util.equals(Schema, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.SchemaOrReference
 */
export class SchemaOrReference extends Message<SchemaOrReference> {
  /**
   * @generated from oneof gnostic.openapi.v3.SchemaOrReference.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.Schema schema = 1;
     */
    value: Schema;
    case: "schema";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Reference reference = 2;
     */
    value: Reference;
    case: "reference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SchemaOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.SchemaOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "message", T: Schema, oneof: "oneof" },
    { no: 2, name: "reference", kind: "message", T: Reference, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemaOrReference {
    return new SchemaOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemaOrReference {
    return new SchemaOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemaOrReference {
    return new SchemaOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: SchemaOrReference | PlainMessage<SchemaOrReference> | undefined, b: SchemaOrReference | PlainMessage<SchemaOrReference> | undefined): boolean {
    return proto3.util.equals(SchemaOrReference, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.SchemasOrReferences
 */
export class SchemasOrReferences extends Message<SchemasOrReferences> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedSchemaOrReference additional_properties = 1;
   */
  additionalProperties: NamedSchemaOrReference[] = [];

  constructor(data?: PartialMessage<SchemasOrReferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.SchemasOrReferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedSchemaOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemasOrReferences {
    return new SchemasOrReferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemasOrReferences {
    return new SchemasOrReferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemasOrReferences {
    return new SchemasOrReferences().fromJsonString(jsonString, options);
  }

  static equals(a: SchemasOrReferences | PlainMessage<SchemasOrReferences> | undefined, b: SchemasOrReferences | PlainMessage<SchemasOrReferences> | undefined): boolean {
    return proto3.util.equals(SchemasOrReferences, a, b);
  }
}

/**
 * Lists the required security schemes to execute this operation. The name used for each property MUST correspond to a security scheme declared in the Security Schemes under the Components Object.  Security Requirement Objects that contain multiple schemes require that all schemes MUST be satisfied for a request to be authorized. This enables support for scenarios where multiple query parameters or HTTP headers are required to convey security information.  When a list of Security Requirement Objects is defined on the OpenAPI Object or Operation Object, only one of the Security Requirement Objects in the list needs to be satisfied to authorize the request.
 *
 * @generated from message gnostic.openapi.v3.SecurityRequirement
 */
export class SecurityRequirement extends Message<SecurityRequirement> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedStringArray additional_properties = 1;
   */
  additionalProperties: NamedStringArray[] = [];

  constructor(data?: PartialMessage<SecurityRequirement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.SecurityRequirement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedStringArray, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityRequirement {
    return new SecurityRequirement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityRequirement {
    return new SecurityRequirement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityRequirement {
    return new SecurityRequirement().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityRequirement | PlainMessage<SecurityRequirement> | undefined, b: SecurityRequirement | PlainMessage<SecurityRequirement> | undefined): boolean {
    return proto3.util.equals(SecurityRequirement, a, b);
  }
}

/**
 * Defines a security scheme that can be used by the operations. Supported schemes are HTTP authentication, an API key (either as a header, a cookie parameter or as a query parameter), mutual TLS (use of a client certificate), OAuth2's common flows (implicit, password, application and access code) as defined in RFC6749, and OpenID Connect.   Please note that currently (2019) the implicit flow is about to be deprecated OAuth 2.0 Security Best Current Practice. Recommended for most use case is Authorization Code Grant flow with PKCE.
 *
 * @generated from message gnostic.openapi.v3.SecurityScheme
 */
export class SecurityScheme extends Message<SecurityScheme> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * @generated from field: string in = 4;
   */
  in = "";

  /**
   * @generated from field: string scheme = 5;
   */
  scheme = "";

  /**
   * @generated from field: string bearer_format = 6;
   */
  bearerFormat = "";

  /**
   * @generated from field: gnostic.openapi.v3.OauthFlows flows = 7;
   */
  flows?: OauthFlows;

  /**
   * @generated from field: string open_id_connect_url = 8;
   */
  openIdConnectUrl = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 9;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<SecurityScheme>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.SecurityScheme";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "in", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "scheme", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "bearer_format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "flows", kind: "message", T: OauthFlows },
    { no: 8, name: "open_id_connect_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityScheme {
    return new SecurityScheme().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityScheme {
    return new SecurityScheme().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityScheme {
    return new SecurityScheme().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityScheme | PlainMessage<SecurityScheme> | undefined, b: SecurityScheme | PlainMessage<SecurityScheme> | undefined): boolean {
    return proto3.util.equals(SecurityScheme, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.SecuritySchemeOrReference
 */
export class SecuritySchemeOrReference extends Message<SecuritySchemeOrReference> {
  /**
   * @generated from oneof gnostic.openapi.v3.SecuritySchemeOrReference.oneof
   */
  oneof: {
    /**
     * @generated from field: gnostic.openapi.v3.SecurityScheme security_scheme = 1;
     */
    value: SecurityScheme;
    case: "securityScheme";
  } | {
    /**
     * @generated from field: gnostic.openapi.v3.Reference reference = 2;
     */
    value: Reference;
    case: "reference";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SecuritySchemeOrReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.SecuritySchemeOrReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "security_scheme", kind: "message", T: SecurityScheme, oneof: "oneof" },
    { no: 2, name: "reference", kind: "message", T: Reference, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecuritySchemeOrReference {
    return new SecuritySchemeOrReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecuritySchemeOrReference {
    return new SecuritySchemeOrReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecuritySchemeOrReference {
    return new SecuritySchemeOrReference().fromJsonString(jsonString, options);
  }

  static equals(a: SecuritySchemeOrReference | PlainMessage<SecuritySchemeOrReference> | undefined, b: SecuritySchemeOrReference | PlainMessage<SecuritySchemeOrReference> | undefined): boolean {
    return proto3.util.equals(SecuritySchemeOrReference, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.SecuritySchemesOrReferences
 */
export class SecuritySchemesOrReferences extends Message<SecuritySchemesOrReferences> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedSecuritySchemeOrReference additional_properties = 1;
   */
  additionalProperties: NamedSecuritySchemeOrReference[] = [];

  constructor(data?: PartialMessage<SecuritySchemesOrReferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.SecuritySchemesOrReferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedSecuritySchemeOrReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecuritySchemesOrReferences {
    return new SecuritySchemesOrReferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecuritySchemesOrReferences {
    return new SecuritySchemesOrReferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecuritySchemesOrReferences {
    return new SecuritySchemesOrReferences().fromJsonString(jsonString, options);
  }

  static equals(a: SecuritySchemesOrReferences | PlainMessage<SecuritySchemesOrReferences> | undefined, b: SecuritySchemesOrReferences | PlainMessage<SecuritySchemesOrReferences> | undefined): boolean {
    return proto3.util.equals(SecuritySchemesOrReferences, a, b);
  }
}

/**
 * An object representing a Server.
 *
 * @generated from message gnostic.openapi.v3.Server
 */
export class Server extends Message<Server> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: gnostic.openapi.v3.ServerVariables variables = 3;
   */
  variables?: ServerVariables;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Server>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Server";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "variables", kind: "message", T: ServerVariables },
    { no: 4, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Server {
    return new Server().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Server {
    return new Server().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Server {
    return new Server().fromJsonString(jsonString, options);
  }

  static equals(a: Server | PlainMessage<Server> | undefined, b: Server | PlainMessage<Server> | undefined): boolean {
    return proto3.util.equals(Server, a, b);
  }
}

/**
 * An object representing a Server Variable for server URL template substitution.
 *
 * @generated from message gnostic.openapi.v3.ServerVariable
 */
export class ServerVariable extends Message<ServerVariable> {
  /**
   * @generated from field: repeated string enum = 1;
   */
  enum: string[] = [];

  /**
   * @generated from field: string default = 2;
   */
  default = "";

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<ServerVariable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ServerVariable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enum", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "default", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerVariable {
    return new ServerVariable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerVariable {
    return new ServerVariable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerVariable {
    return new ServerVariable().fromJsonString(jsonString, options);
  }

  static equals(a: ServerVariable | PlainMessage<ServerVariable> | undefined, b: ServerVariable | PlainMessage<ServerVariable> | undefined): boolean {
    return proto3.util.equals(ServerVariable, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.ServerVariables
 */
export class ServerVariables extends Message<ServerVariables> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedServerVariable additional_properties = 1;
   */
  additionalProperties: NamedServerVariable[] = [];

  constructor(data?: PartialMessage<ServerVariables>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.ServerVariables";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedServerVariable, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerVariables {
    return new ServerVariables().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerVariables {
    return new ServerVariables().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerVariables {
    return new ServerVariables().fromJsonString(jsonString, options);
  }

  static equals(a: ServerVariables | PlainMessage<ServerVariables> | undefined, b: ServerVariables | PlainMessage<ServerVariables> | undefined): boolean {
    return proto3.util.equals(ServerVariables, a, b);
  }
}

/**
 * Any property starting with x- is valid.
 *
 * @generated from message gnostic.openapi.v3.SpecificationExtension
 */
export class SpecificationExtension extends Message<SpecificationExtension> {
  /**
   * @generated from oneof gnostic.openapi.v3.SpecificationExtension.oneof
   */
  oneof: {
    /**
     * @generated from field: double number = 1;
     */
    value: number;
    case: "number";
  } | {
    /**
     * @generated from field: bool boolean = 2;
     */
    value: boolean;
    case: "boolean";
  } | {
    /**
     * @generated from field: string string = 3;
     */
    value: string;
    case: "string";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SpecificationExtension>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.SpecificationExtension";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "number", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "oneof" },
    { no: 2, name: "boolean", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "oneof" },
    { no: 3, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "oneof" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpecificationExtension {
    return new SpecificationExtension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpecificationExtension {
    return new SpecificationExtension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpecificationExtension {
    return new SpecificationExtension().fromJsonString(jsonString, options);
  }

  static equals(a: SpecificationExtension | PlainMessage<SpecificationExtension> | undefined, b: SpecificationExtension | PlainMessage<SpecificationExtension> | undefined): boolean {
    return proto3.util.equals(SpecificationExtension, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.StringArray
 */
export class StringArray extends Message<StringArray> {
  /**
   * @generated from field: repeated string value = 1;
   */
  value: string[] = [];

  constructor(data?: PartialMessage<StringArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.StringArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringArray {
    return new StringArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringArray {
    return new StringArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringArray {
    return new StringArray().fromJsonString(jsonString, options);
  }

  static equals(a: StringArray | PlainMessage<StringArray> | undefined, b: StringArray | PlainMessage<StringArray> | undefined): boolean {
    return proto3.util.equals(StringArray, a, b);
  }
}

/**
 * @generated from message gnostic.openapi.v3.Strings
 */
export class Strings extends Message<Strings> {
  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedString additional_properties = 1;
   */
  additionalProperties: NamedString[] = [];

  constructor(data?: PartialMessage<Strings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Strings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additional_properties", kind: "message", T: NamedString, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Strings {
    return new Strings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Strings {
    return new Strings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Strings {
    return new Strings().fromJsonString(jsonString, options);
  }

  static equals(a: Strings | PlainMessage<Strings> | undefined, b: Strings | PlainMessage<Strings> | undefined): boolean {
    return proto3.util.equals(Strings, a, b);
  }
}

/**
 * Adds metadata to a single tag that is used by the Operation Object. It is not mandatory to have a Tag Object per tag defined in the Operation Object instances.
 *
 * @generated from message gnostic.openapi.v3.Tag
 */
export class Tag extends Message<Tag> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: gnostic.openapi.v3.ExternalDocs external_docs = 3;
   */
  externalDocs?: ExternalDocs;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 4;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Tag>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Tag";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "external_docs", kind: "message", T: ExternalDocs },
    { no: 4, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tag {
    return new Tag().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tag {
    return new Tag().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tag {
    return new Tag().fromJsonString(jsonString, options);
  }

  static equals(a: Tag | PlainMessage<Tag> | undefined, b: Tag | PlainMessage<Tag> | undefined): boolean {
    return proto3.util.equals(Tag, a, b);
  }
}

/**
 * A metadata object that allows for more fine-tuned XML model definitions.  When using arrays, XML element names are *not* inferred (for singular/plural forms) and the `name` property SHOULD be used to add that information. See examples for expected behavior.
 *
 * @generated from message gnostic.openapi.v3.Xml
 */
export class Xml extends Message<Xml> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string namespace = 2;
   */
  namespace = "";

  /**
   * @generated from field: string prefix = 3;
   */
  prefix = "";

  /**
   * @generated from field: bool attribute = 4;
   */
  attribute = false;

  /**
   * @generated from field: bool wrapped = 5;
   */
  wrapped = false;

  /**
   * @generated from field: repeated gnostic.openapi.v3.NamedAny specification_extension = 6;
   */
  specificationExtension: NamedAny[] = [];

  constructor(data?: PartialMessage<Xml>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gnostic.openapi.v3.Xml";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "attribute", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "wrapped", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "specification_extension", kind: "message", T: NamedAny, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Xml {
    return new Xml().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Xml {
    return new Xml().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Xml {
    return new Xml().fromJsonString(jsonString, options);
  }

  static equals(a: Xml | PlainMessage<Xml> | undefined, b: Xml | PlainMessage<Xml> | undefined): boolean {
    return proto3.util.equals(Xml, a, b);
  }
}

