// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const approveRelationship = `-- name: ApproveRelationship :execresult
UPDATE relationships SET
  ` + "`" + `status` + "`" + ` = 'approved',
  resolved_at = CURRENT_TIMESTAMP,
  resolved_by = ?
WHERE public_id = UUID_TO_BIN(?) AND ` + "`" + `status` + "`" + ` = 'pending'
`

type ApproveRelationshipParams struct {
	ResolvedBy sql.NullInt64 `json:"resolved_by"`
	PublicID   string        `json:"public_id"`
}

func (q *Queries) ApproveRelationship(ctx context.Context, arg ApproveRelationshipParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, approveRelationship, arg.ResolvedBy, arg.PublicID)
}

const claimPendingEvents = `-- name: ClaimPendingEvents :execresult
UPDATE event_queue
SET status = 'processing',
    processing_by = ?,
    processing_at = NOW()
WHERE status = 'pending'
  AND retry_count < ?
ORDER BY created_at ASC
LIMIT ?
`

type ClaimPendingEventsParams struct {
	ProcessingBy sql.NullString `json:"processing_by"`
	RetryCount   int32          `json:"retry_count"`
	Limit        int32          `json:"limit"`
}

func (q *Queries) ClaimPendingEvents(ctx context.Context, arg ClaimPendingEventsParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, claimPendingEvents, arg.ProcessingBy, arg.RetryCount, arg.Limit)
}

const cleanupExpiredVerificationTokens = `-- name: CleanupExpiredVerificationTokens :exec
DELETE FROM email_verification_tokens
WHERE expires_at < NOW()
`

func (q *Queries) CleanupExpiredVerificationTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredVerificationTokens)
	return err
}

const cleanupOldEvents = `-- name: CleanupOldEvents :exec
DELETE FROM event_queue
WHERE status = 'sent'
  AND sent_at < DATE_SUB(NOW(), INTERVAL ? DAY)
`

func (q *Queries) CleanupOldEvents(ctx context.Context, dateSUB interface{}) error {
	_, err := q.db.ExecContext(ctx, cleanupOldEvents, dateSUB)
	return err
}

const countOrganizationSecrets = `-- name: CountOrganizationSecrets :one
SELECT COUNT(*) FROM organization_secrets
WHERE organization_id = ? AND status != 'deleted'
`

func (q *Queries) CountOrganizationSecrets(ctx context.Context, organizationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrganizationSecrets, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectSecrets = `-- name: CountProjectSecrets :one
SELECT COUNT(*) FROM project_secrets
WHERE project_id = ? AND status != 'deleted'
`

func (q *Queries) CountProjectSecrets(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProjectSecrets, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSiteSecrets = `-- name: CountSiteSecrets :one
SELECT COUNT(*) FROM site_secrets
WHERE site_id = ? AND status != 'deleted'
`

func (q *Queries) CountSiteSecrets(ctx context.Context, siteID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSiteSecrets, siteID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIKey = `-- name: CreateAPIKey :exec

INSERT INTO api_keys (
  public_id, account_id, ` + "`" + `name` + "`" + `, description, scopes, created_at, expires_at, active, created_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, NOW(), ?, ?, ?)
`

type CreateAPIKeyParams struct {
	PublicID    string          `json:"public_id"`
	AccountID   int64           `json:"account_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Scopes      json.RawMessage `json:"scopes"`
	ExpiresAt   sql.NullTime    `json:"expires_at"`
	Active      bool            `json:"active"`
	CreatedBy   sql.NullInt64   `json:"created_by"`
}

// =============================================================================
// API KEYS
// =============================================================================
func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) error {
	_, err := q.db.ExecContext(ctx, createAPIKey,
		arg.PublicID,
		arg.AccountID,
		arg.Name,
		arg.Description,
		arg.Scopes,
		arg.ExpiresAt,
		arg.Active,
		arg.CreatedBy,
	)
	return err
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO accounts (
  public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id, auth_method, verified, verified_at, created_at, updated_at
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
`

type CreateAccountParams struct {
	Email          string             `json:"email"`
	Name           sql.NullString     `json:"name"`
	GithubUsername sql.NullString     `json:"github_username"`
	VaultEntityID  sql.NullString     `json:"vault_entity_id"`
	AuthMethod     AccountsAuthMethod `json:"auth_method"`
	Verified       bool               `json:"verified"`
	VerifiedAt     sql.NullTime       `json:"verified_at"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount,
		arg.Email,
		arg.Name,
		arg.GithubUsername,
		arg.VaultEntityID,
		arg.AuthMethod,
		arg.Verified,
		arg.VerifiedAt,
	)
	return err
}

const createAuditEvent = `-- name: CreateAuditEvent :exec
INSERT INTO audit (
  account_id, entity_id, entity_type, event_name, event_data
) VALUES (?, ?, ?, ?, ?)
`

type CreateAuditEventParams struct {
	AccountID  int64           `json:"account_id"`
	EntityID   int64           `json:"entity_id"`
	EntityType AuditEntityType `json:"entity_type"`
	EventName  string          `json:"event_name"`
	EventData  []byte          `json:"event_data"`
}

func (q *Queries) CreateAuditEvent(ctx context.Context, arg CreateAuditEventParams) error {
	_, err := q.db.ExecContext(ctx, createAuditEvent,
		arg.AccountID,
		arg.EntityID,
		arg.EntityType,
		arg.EventName,
		arg.EventData,
	)
	return err
}

const createDeployment = `-- name: CreateDeployment :exec
INSERT INTO deployments (
  deployment_id, site_id, ` + "`" + `status` + "`" + `, github_run_id, github_run_url, started_at, completed_at, error_message, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW())
`

type CreateDeploymentParams struct {
	DeploymentID string            `json:"deployment_id"`
	SiteID       string            `json:"site_id"`
	Status       DeploymentsStatus `json:"status"`
	GithubRunID  sql.NullString    `json:"github_run_id"`
	GithubRunUrl sql.NullString    `json:"github_run_url"`
	StartedAt    int64             `json:"started_at"`
	CompletedAt  sql.NullInt64     `json:"completed_at"`
	ErrorMessage sql.NullString    `json:"error_message"`
}

func (q *Queries) CreateDeployment(ctx context.Context, arg CreateDeploymentParams) error {
	_, err := q.db.ExecContext(ctx, createDeployment,
		arg.DeploymentID,
		arg.SiteID,
		arg.Status,
		arg.GithubRunID,
		arg.GithubRunUrl,
		arg.StartedAt,
		arg.CompletedAt,
		arg.ErrorMessage,
	)
	return err
}

const createDomain = `-- name: CreateDomain :exec
INSERT INTO domains (
  site_id, domain, created_at
) VALUES (?, ?, NOW())
`

type CreateDomainParams struct {
	SiteID int64  `json:"site_id"`
	Domain string `json:"domain"`
}

func (q *Queries) CreateDomain(ctx context.Context, arg CreateDomainParams) error {
	_, err := q.db.ExecContext(ctx, createDomain, arg.SiteID, arg.Domain)
	return err
}

const createEmailVerificationToken = `-- name: CreateEmailVerificationToken :exec

INSERT INTO email_verification_tokens (
    email,
    token,
    password_hash,
    expires_at
) VALUES (?, ?, ?, ?)
`

type CreateEmailVerificationTokenParams struct {
	Email        string    `json:"email"`
	Token        string    `json:"token"`
	PasswordHash string    `json:"password_hash"`
	ExpiresAt    time.Time `json:"expires_at"`
}

// =============================================================================
// EMAIL VERIFICATION TOKENS
// =============================================================================
func (q *Queries) CreateEmailVerificationToken(ctx context.Context, arg CreateEmailVerificationTokenParams) error {
	_, err := q.db.ExecContext(ctx, createEmailVerificationToken,
		arg.Email,
		arg.Token,
		arg.PasswordHash,
		arg.ExpiresAt,
	)
	return err
}

const createOrganization = `-- name: CreateOrganization :exec
INSERT INTO organizations (
  public_id, ` + "`" + `name` + "`" + `, gcp_org_id, gcp_billing_account, gcp_parent, gcp_folder_id, ` + "`" + `status` + "`" + `, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateOrganizationParams struct {
	PublicID          string                  `json:"public_id"`
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	CreatedBy         sql.NullInt64           `json:"created_by"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, createOrganization,
		arg.PublicID,
		arg.Name,
		arg.GcpOrgID,
		arg.GcpBillingAccount,
		arg.GcpParent,
		arg.GcpFolderID,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createOrganizationFirewallRule = `-- name: CreateOrganizationFirewallRule :exec
INSERT INTO organization_firewall_rules (
  public_id, organization_id, name, rule_type, cidr, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?)
`

type CreateOrganizationFirewallRuleParams struct {
	OrganizationID sql.NullInt64                     `json:"organization_id"`
	Name           string                            `json:"name"`
	RuleType       OrganizationFirewallRulesRuleType `json:"rule_type"`
	Cidr           string                            `json:"cidr"`
	CreatedBy      sql.NullInt64                     `json:"created_by"`
	UpdatedBy      sql.NullInt64                     `json:"updated_by"`
}

func (q *Queries) CreateOrganizationFirewallRule(ctx context.Context, arg CreateOrganizationFirewallRuleParams) error {
	_, err := q.db.ExecContext(ctx, createOrganizationFirewallRule,
		arg.OrganizationID,
		arg.Name,
		arg.RuleType,
		arg.Cidr,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createOrganizationMember = `-- name: CreateOrganizationMember :exec
INSERT INTO organization_members (
  public_id, organization_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateOrganizationMemberParams struct {
	OrganizationID int64                   `json:"organization_id"`
	AccountID      int64                   `json:"account_id"`
	Role           OrganizationMembersRole `json:"role"`
	CreatedBy      sql.NullInt64           `json:"created_by"`
	UpdatedBy      sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) CreateOrganizationMember(ctx context.Context, arg CreateOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, createOrganizationMember,
		arg.OrganizationID,
		arg.AccountID,
		arg.Role,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createOrganizationSecret = `-- name: CreateOrganizationSecret :execresult

INSERT INTO organization_secrets (
    public_id, organization_id, name, vault_path, status, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateOrganizationSecretParams struct {
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

// =============================================================================
// ORGANIZATION SECRETS
// =============================================================================
func (q *Queries) CreateOrganizationSecret(ctx context.Context, arg CreateOrganizationSecretParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createOrganizationSecret,
		arg.PublicID,
		arg.OrganizationID,
		arg.Name,
		arg.VaultPath,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
}

const createProject = `-- name: CreateProject :exec
INSERT INTO projects (
  public_id, organization_id, ` + "`" + `name` + "`" + `, github_repository, github_branch, compose_path,
  gcp_region, gcp_zone, machine_type, disk_size_gb, compose_file, application_type,
  monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
  gcp_project_id, gcp_project_number, github_team_id, create_branch_sites, ` + "`" + `status` + "`" + `,
  created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateProjectParams struct {
	OrganizationID            int64              `json:"organization_id"`
	Name                      string             `json:"name"`
	GithubRepository          sql.NullString     `json:"github_repository"`
	GithubBranch              sql.NullString     `json:"github_branch"`
	ComposePath               sql.NullString     `json:"compose_path"`
	GcpRegion                 sql.NullString     `json:"gcp_region"`
	GcpZone                   sql.NullString     `json:"gcp_zone"`
	MachineType               sql.NullString     `json:"machine_type"`
	DiskSizeGb                sql.NullInt32      `json:"disk_size_gb"`
	ComposeFile               sql.NullString     `json:"compose_file"`
	ApplicationType           sql.NullString     `json:"application_type"`
	MonitoringEnabled         sql.NullBool       `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString     `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool       `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString     `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString     `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString     `json:"gcp_project_number"`
	GithubTeamID              sql.NullString     `json:"github_team_id"`
	CreateBranchSites         sql.NullBool       `json:"create_branch_sites"`
	Status                    NullProjectsStatus `json:"status"`
	CreatedBy                 sql.NullInt64      `json:"created_by"`
	UpdatedBy                 sql.NullInt64      `json:"updated_by"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) error {
	_, err := q.db.ExecContext(ctx, createProject,
		arg.OrganizationID,
		arg.Name,
		arg.GithubRepository,
		arg.GithubBranch,
		arg.ComposePath,
		arg.GcpRegion,
		arg.GcpZone,
		arg.MachineType,
		arg.DiskSizeGb,
		arg.ComposeFile,
		arg.ApplicationType,
		arg.MonitoringEnabled,
		arg.MonitoringLogLevel,
		arg.MonitoringMetricsEnabled,
		arg.MonitoringHealthCheckPath,
		arg.GcpProjectID,
		arg.GcpProjectNumber,
		arg.GithubTeamID,
		arg.CreateBranchSites,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createProjectFirewallRule = `-- name: CreateProjectFirewallRule :exec
INSERT INTO project_firewall_rules (
  public_id, project_id, name, rule_type, cidr, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?)
`

type CreateProjectFirewallRuleParams struct {
	ProjectID sql.NullInt64                `json:"project_id"`
	Name      string                       `json:"name"`
	RuleType  ProjectFirewallRulesRuleType `json:"rule_type"`
	Cidr      string                       `json:"cidr"`
	CreatedBy sql.NullInt64                `json:"created_by"`
	UpdatedBy sql.NullInt64                `json:"updated_by"`
}

func (q *Queries) CreateProjectFirewallRule(ctx context.Context, arg CreateProjectFirewallRuleParams) error {
	_, err := q.db.ExecContext(ctx, createProjectFirewallRule,
		arg.ProjectID,
		arg.Name,
		arg.RuleType,
		arg.Cidr,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createProjectMember = `-- name: CreateProjectMember :exec
INSERT INTO project_members (
  public_id, project_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateProjectMemberParams struct {
	ProjectID int64              `json:"project_id"`
	AccountID int64              `json:"account_id"`
	Role      ProjectMembersRole `json:"role"`
	CreatedBy sql.NullInt64      `json:"created_by"`
	UpdatedBy sql.NullInt64      `json:"updated_by"`
}

func (q *Queries) CreateProjectMember(ctx context.Context, arg CreateProjectMemberParams) error {
	_, err := q.db.ExecContext(ctx, createProjectMember,
		arg.ProjectID,
		arg.AccountID,
		arg.Role,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createProjectSecret = `-- name: CreateProjectSecret :execresult

INSERT INTO project_secrets (
    public_id, project_id, name, vault_path, status, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateProjectSecretParams struct {
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

// =============================================================================
// PROJECT SECRETS
// =============================================================================
func (q *Queries) CreateProjectSecret(ctx context.Context, arg CreateProjectSecretParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProjectSecret,
		arg.PublicID,
		arg.ProjectID,
		arg.Name,
		arg.VaultPath,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
}

const createRelationship = `-- name: CreateRelationship :execresult
INSERT INTO relationships (
  public_id, source_organization_id, target_organization_id, relationship_type, ` + "`" + `status` + "`" + `, created_at
) VALUES (
  UUID_TO_BIN(UUID_V7()), ?, ?, ?, 'pending', CURRENT_TIMESTAMP
)
`

type CreateRelationshipParams struct {
	SourceOrganizationID int64                         `json:"source_organization_id"`
	TargetOrganizationID int64                         `json:"target_organization_id"`
	RelationshipType     RelationshipsRelationshipType `json:"relationship_type"`
}

func (q *Queries) CreateRelationship(ctx context.Context, arg CreateRelationshipParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createRelationship, arg.SourceOrganizationID, arg.TargetOrganizationID, arg.RelationshipType)
}

const createSite = `-- name: CreateSite :exec
INSERT INTO sites (
  public_id, project_id, ` + "`" + `name` + "`" + `, github_ref, gcp_external_ip, ` + "`" + `status` + "`" + `, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateSiteParams struct {
	ProjectID     int64           `json:"project_id"`
	Name          string          `json:"name"`
	GithubRef     string          `json:"github_ref"`
	GcpExternalIp sql.NullString  `json:"gcp_external_ip"`
	Status        NullSitesStatus `json:"status"`
	CreatedBy     sql.NullInt64   `json:"created_by"`
	UpdatedBy     sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) CreateSite(ctx context.Context, arg CreateSiteParams) error {
	_, err := q.db.ExecContext(ctx, createSite,
		arg.ProjectID,
		arg.Name,
		arg.GithubRef,
		arg.GcpExternalIp,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createSiteFirewallRule = `-- name: CreateSiteFirewallRule :exec
INSERT INTO site_firewall_rules (
  public_id, site_id, name, rule_type, cidr, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?)
`

type CreateSiteFirewallRuleParams struct {
	SiteID    sql.NullInt64             `json:"site_id"`
	Name      string                    `json:"name"`
	RuleType  SiteFirewallRulesRuleType `json:"rule_type"`
	Cidr      string                    `json:"cidr"`
	CreatedBy sql.NullInt64             `json:"created_by"`
	UpdatedBy sql.NullInt64             `json:"updated_by"`
}

func (q *Queries) CreateSiteFirewallRule(ctx context.Context, arg CreateSiteFirewallRuleParams) error {
	_, err := q.db.ExecContext(ctx, createSiteFirewallRule,
		arg.SiteID,
		arg.Name,
		arg.RuleType,
		arg.Cidr,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createSiteMember = `-- name: CreateSiteMember :exec
INSERT INTO site_members (
  public_id, site_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateSiteMemberParams struct {
	SiteID    int64           `json:"site_id"`
	AccountID int64           `json:"account_id"`
	Role      SiteMembersRole `json:"role"`
	CreatedBy sql.NullInt64   `json:"created_by"`
	UpdatedBy sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) CreateSiteMember(ctx context.Context, arg CreateSiteMemberParams) error {
	_, err := q.db.ExecContext(ctx, createSiteMember,
		arg.SiteID,
		arg.AccountID,
		arg.Role,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createSiteSecret = `-- name: CreateSiteSecret :execresult

INSERT INTO site_secrets (
    public_id, site_id, name, vault_path, status, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSiteSecretParams struct {
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

// =============================================================================
// SITE SECRETS
// =============================================================================
func (q *Queries) CreateSiteSecret(ctx context.Context, arg CreateSiteSecretParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createSiteSecret,
		arg.PublicID,
		arg.SiteID,
		arg.Name,
		arg.VaultPath,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
}

const createSshAccess = `-- name: CreateSshAccess :exec
INSERT INTO ssh_access (
  account_id, site_id, created_at, updated_at, created_by, updated_by
) VALUES (?, ?, NOW(), NOW(), ?, ?)
`

type CreateSshAccessParams struct {
	AccountID int64         `json:"account_id"`
	SiteID    int64         `json:"site_id"`
	CreatedBy sql.NullInt64 `json:"created_by"`
	UpdatedBy sql.NullInt64 `json:"updated_by"`
}

func (q *Queries) CreateSshAccess(ctx context.Context, arg CreateSshAccessParams) error {
	_, err := q.db.ExecContext(ctx, createSshAccess,
		arg.AccountID,
		arg.SiteID,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createSshKey = `-- name: CreateSshKey :execresult
INSERT INTO ssh_keys (
  public_id, account_id, public_key, ` + "`" + `name` + "`" + `, fingerprint, created_at, updated_at
) VALUES (
  UUID_TO_BIN(?),
  (SELECT id FROM accounts WHERE accounts.public_id = UUID_TO_BIN(?)),
  ?, ?, ?,
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
`

type CreateSshKeyParams struct {
	PublicID        string         `json:"public_id"`
	AccountPublicID string         `json:"account_public_id"`
	PublicKey       string         `json:"public_key"`
	Name            sql.NullString `json:"name"`
	Fingerprint     sql.NullString `json:"fingerprint"`
}

func (q *Queries) CreateSshKey(ctx context.Context, arg CreateSshKeyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createSshKey,
		arg.PublicID,
		arg.AccountPublicID,
		arg.PublicKey,
		arg.Name,
		arg.Fingerprint,
	)
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_keys WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteAPIKey(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteAPIKey, publicID)
	return err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteAccount(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteAccount, publicID)
	return err
}

const deleteDeployment = `-- name: DeleteDeployment :exec
DELETE FROM deployments WHERE deployment_id = ?
`

func (q *Queries) DeleteDeployment(ctx context.Context, deploymentID string) error {
	_, err := q.db.ExecContext(ctx, deleteDeployment, deploymentID)
	return err
}

const deleteDomain = `-- name: DeleteDomain :exec
DELETE FROM domains WHERE id = ?
`

func (q *Queries) DeleteDomain(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDomain, id)
	return err
}

const deleteEmailVerificationToken = `-- name: DeleteEmailVerificationToken :exec
DELETE FROM email_verification_tokens
WHERE email = ?
`

func (q *Queries) DeleteEmailVerificationToken(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deleteEmailVerificationToken, email)
	return err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteOrganization(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteOrganization, publicID)
	return err
}

const deleteOrganizationFirewallRule = `-- name: DeleteOrganizationFirewallRule :exec
DELETE FROM organization_firewall_rules WHERE id = ?
`

func (q *Queries) DeleteOrganizationFirewallRule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationFirewallRule, id)
	return err
}

const deleteOrganizationFirewallRuleByPublicID = `-- name: DeleteOrganizationFirewallRuleByPublicID :exec
DELETE FROM organization_firewall_rules WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteOrganizationFirewallRuleByPublicID(ctx context.Context, uuidTOBIN string) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationFirewallRuleByPublicID, uuidTOBIN)
	return err
}

const deleteOrganizationMember = `-- name: DeleteOrganizationMember :exec
DELETE FROM organization_members WHERE organization_id = ? AND account_id = ?
`

type DeleteOrganizationMemberParams struct {
	OrganizationID int64 `json:"organization_id"`
	AccountID      int64 `json:"account_id"`
}

func (q *Queries) DeleteOrganizationMember(ctx context.Context, arg DeleteOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationMember, arg.OrganizationID, arg.AccountID)
	return err
}

const deleteOrganizationSecret = `-- name: DeleteOrganizationSecret :exec
UPDATE organization_secrets
SET status = 'deleted', updated_by = ?, updated_at = ?
WHERE id = ?
`

type DeleteOrganizationSecretParams struct {
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) DeleteOrganizationSecret(ctx context.Context, arg DeleteOrganizationSecretParams) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationSecret, arg.UpdatedBy, arg.UpdatedAt, arg.ID)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteProject(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteProject, publicID)
	return err
}

const deleteProjectFirewallRule = `-- name: DeleteProjectFirewallRule :exec
DELETE FROM project_firewall_rules WHERE id = ?
`

func (q *Queries) DeleteProjectFirewallRule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProjectFirewallRule, id)
	return err
}

const deleteProjectFirewallRuleByPublicID = `-- name: DeleteProjectFirewallRuleByPublicID :exec
DELETE FROM project_firewall_rules WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteProjectFirewallRuleByPublicID(ctx context.Context, uuidTOBIN string) error {
	_, err := q.db.ExecContext(ctx, deleteProjectFirewallRuleByPublicID, uuidTOBIN)
	return err
}

const deleteProjectMember = `-- name: DeleteProjectMember :exec
DELETE FROM project_members WHERE project_id = ? AND account_id = ?
`

type DeleteProjectMemberParams struct {
	ProjectID int64 `json:"project_id"`
	AccountID int64 `json:"account_id"`
}

func (q *Queries) DeleteProjectMember(ctx context.Context, arg DeleteProjectMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteProjectMember, arg.ProjectID, arg.AccountID)
	return err
}

const deleteProjectSecret = `-- name: DeleteProjectSecret :exec
UPDATE project_secrets
SET status = 'deleted', updated_by = ?, updated_at = ?
WHERE id = ?
`

type DeleteProjectSecretParams struct {
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) DeleteProjectSecret(ctx context.Context, arg DeleteProjectSecretParams) error {
	_, err := q.db.ExecContext(ctx, deleteProjectSecret, arg.UpdatedBy, arg.UpdatedAt, arg.ID)
	return err
}

const deleteSite = `-- name: DeleteSite :exec
DELETE FROM sites WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteSite(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteSite, publicID)
	return err
}

const deleteSiteFirewallRule = `-- name: DeleteSiteFirewallRule :exec
DELETE FROM site_firewall_rules WHERE id = ?
`

func (q *Queries) DeleteSiteFirewallRule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSiteFirewallRule, id)
	return err
}

const deleteSiteFirewallRuleByPublicID = `-- name: DeleteSiteFirewallRuleByPublicID :exec
DELETE FROM site_firewall_rules WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteSiteFirewallRuleByPublicID(ctx context.Context, uuidTOBIN string) error {
	_, err := q.db.ExecContext(ctx, deleteSiteFirewallRuleByPublicID, uuidTOBIN)
	return err
}

const deleteSiteMember = `-- name: DeleteSiteMember :exec
DELETE FROM site_members WHERE site_id = ? AND account_id = ?
`

type DeleteSiteMemberParams struct {
	SiteID    int64 `json:"site_id"`
	AccountID int64 `json:"account_id"`
}

func (q *Queries) DeleteSiteMember(ctx context.Context, arg DeleteSiteMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteSiteMember, arg.SiteID, arg.AccountID)
	return err
}

const deleteSiteSecret = `-- name: DeleteSiteSecret :exec
UPDATE site_secrets
SET status = 'deleted', updated_by = ?, updated_at = ?
WHERE id = ?
`

type DeleteSiteSecretParams struct {
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) DeleteSiteSecret(ctx context.Context, arg DeleteSiteSecretParams) error {
	_, err := q.db.ExecContext(ctx, deleteSiteSecret, arg.UpdatedBy, arg.UpdatedAt, arg.ID)
	return err
}

const deleteSshAccess = `-- name: DeleteSshAccess :exec
DELETE FROM ssh_access WHERE account_id = ? AND site_id = ?
`

type DeleteSshAccessParams struct {
	AccountID int64 `json:"account_id"`
	SiteID    int64 `json:"site_id"`
}

func (q *Queries) DeleteSshAccess(ctx context.Context, arg DeleteSshAccessParams) error {
	_, err := q.db.ExecContext(ctx, deleteSshAccess, arg.AccountID, arg.SiteID)
	return err
}

const deleteSshKey = `-- name: DeleteSshKey :exec
DELETE FROM ssh_keys WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteSshKey(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteSshKey, publicID)
	return err
}

const enqueueEvent = `-- name: EnqueueEvent :exec

INSERT INTO event_queue (
    event_id,
    event_type,
    event_source,
    event_subject,
    event_data,
    content_type,
    created_at
) VALUES (?, ?, ?, ?, ?, ?, NOW())
`

type EnqueueEventParams struct {
	EventID      string         `json:"event_id"`
	EventType    string         `json:"event_type"`
	EventSource  string         `json:"event_source"`
	EventSubject sql.NullString `json:"event_subject"`
	EventData    []byte         `json:"event_data"`
	ContentType  string         `json:"content_type"`
}

// =============================================================================
// EVENT QUEUE
// =============================================================================
func (q *Queries) EnqueueEvent(ctx context.Context, arg EnqueueEventParams) error {
	_, err := q.db.ExecContext(ctx, enqueueEvent,
		arg.EventID,
		arg.EventType,
		arg.EventSource,
		arg.EventSubject,
		arg.EventData,
		arg.ContentType,
	)
	return err
}

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, account_id, ` + "`" + `name` + "`" + `, description,
       COALESCE(scopes, '[]') as scopes,
       created_at, last_used_at, expires_at, active, created_by
FROM api_keys WHERE id = ?
`

type GetAPIKeyByIDRow struct {
	ID          int64           `json:"id"`
	PublicID    string          `json:"public_id"`
	AccountID   int64           `json:"account_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Scopes      json.RawMessage `json:"scopes"`
	CreatedAt   sql.NullTime    `json:"created_at"`
	LastUsedAt  sql.NullTime    `json:"last_used_at"`
	ExpiresAt   sql.NullTime    `json:"expires_at"`
	Active      bool            `json:"active"`
	CreatedBy   sql.NullInt64   `json:"created_by"`
}

func (q *Queries) GetAPIKeyByID(ctx context.Context, id int64) (GetAPIKeyByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByID, id)
	var i GetAPIKeyByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.AccountID,
		&i.Name,
		&i.Description,
		&i.Scopes,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.Active,
		&i.CreatedBy,
	)
	return i, err
}

const getAPIKeyByUUID = `-- name: GetAPIKeyByUUID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, account_id, ` + "`" + `name` + "`" + `, description,
       COALESCE(scopes, '[]') as scopes,
       created_at, last_used_at, expires_at, active, created_by
FROM api_keys WHERE public_id = UUID_TO_BIN(?)
`

type GetAPIKeyByUUIDRow struct {
	ID          int64           `json:"id"`
	PublicID    string          `json:"public_id"`
	AccountID   int64           `json:"account_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Scopes      json.RawMessage `json:"scopes"`
	CreatedAt   sql.NullTime    `json:"created_at"`
	LastUsedAt  sql.NullTime    `json:"last_used_at"`
	ExpiresAt   sql.NullTime    `json:"expires_at"`
	Active      bool            `json:"active"`
	CreatedBy   sql.NullInt64   `json:"created_by"`
}

func (q *Queries) GetAPIKeyByUUID(ctx context.Context, publicID string) (GetAPIKeyByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByUUID, publicID)
	var i GetAPIKeyByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.AccountID,
		&i.Name,
		&i.Description,
		&i.Scopes,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.Active,
		&i.CreatedBy,
	)
	return i, err
}

const getAccount = `-- name: GetAccount :one

SELECT id, BIN_TO_UUID(public_id) AS public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id,
       auth_method, verified, verified_at, created_at, updated_at
FROM accounts WHERE public_id = UUID_TO_BIN(?)
`

type GetAccountRow struct {
	ID             int64              `json:"id"`
	PublicID       string             `json:"public_id"`
	Email          string             `json:"email"`
	Name           sql.NullString     `json:"name"`
	GithubUsername sql.NullString     `json:"github_username"`
	VaultEntityID  sql.NullString     `json:"vault_entity_id"`
	AuthMethod     AccountsAuthMethod `json:"auth_method"`
	Verified       bool               `json:"verified"`
	VerifiedAt     sql.NullTime       `json:"verified_at"`
	CreatedAt      sql.NullTime       `json:"created_at"`
	UpdatedAt      sql.NullTime       `json:"updated_at"`
}

// =============================================================================
// ACCOUNTS
// =============================================================================
func (q *Queries) GetAccount(ctx context.Context, publicID string) (GetAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getAccount, publicID)
	var i GetAccountRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Email,
		&i.Name,
		&i.GithubUsername,
		&i.VaultEntityID,
		&i.AuthMethod,
		&i.Verified,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByEmail = `-- name: GetAccountByEmail :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id,
       auth_method, verified, verified_at, failed_login_attempts, last_failed_login_at, created_at, updated_at
FROM accounts WHERE email = ?
`

type GetAccountByEmailRow struct {
	ID                  int64              `json:"id"`
	PublicID            string             `json:"public_id"`
	Email               string             `json:"email"`
	Name                sql.NullString     `json:"name"`
	GithubUsername      sql.NullString     `json:"github_username"`
	VaultEntityID       sql.NullString     `json:"vault_entity_id"`
	AuthMethod          AccountsAuthMethod `json:"auth_method"`
	Verified            bool               `json:"verified"`
	VerifiedAt          sql.NullTime       `json:"verified_at"`
	FailedLoginAttempts int32              `json:"failed_login_attempts"`
	LastFailedLoginAt   sql.NullTime       `json:"last_failed_login_at"`
	CreatedAt           sql.NullTime       `json:"created_at"`
	UpdatedAt           sql.NullTime       `json:"updated_at"`
}

func (q *Queries) GetAccountByEmail(ctx context.Context, email string) (GetAccountByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountByEmail, email)
	var i GetAccountByEmailRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Email,
		&i.Name,
		&i.GithubUsername,
		&i.VaultEntityID,
		&i.AuthMethod,
		&i.Verified,
		&i.VerifiedAt,
		&i.FailedLoginAttempts,
		&i.LastFailedLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id,
       auth_method, verified, verified_at, created_at, updated_at
FROM accounts WHERE id = ?
`

type GetAccountByIDRow struct {
	ID             int64              `json:"id"`
	PublicID       string             `json:"public_id"`
	Email          string             `json:"email"`
	Name           sql.NullString     `json:"name"`
	GithubUsername sql.NullString     `json:"github_username"`
	VaultEntityID  sql.NullString     `json:"vault_entity_id"`
	AuthMethod     AccountsAuthMethod `json:"auth_method"`
	Verified       bool               `json:"verified"`
	VerifiedAt     sql.NullTime       `json:"verified_at"`
	CreatedAt      sql.NullTime       `json:"created_at"`
	UpdatedAt      sql.NullTime       `json:"updated_at"`
}

func (q *Queries) GetAccountByID(ctx context.Context, id int64) (GetAccountByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountByID, id)
	var i GetAccountByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Email,
		&i.Name,
		&i.GithubUsername,
		&i.VaultEntityID,
		&i.AuthMethod,
		&i.Verified,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByVaultEntityID = `-- name: GetAccountByVaultEntityID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id,
       auth_method, verified, verified_at, created_at, updated_at
FROM accounts WHERE vault_entity_id = ?
`

type GetAccountByVaultEntityIDRow struct {
	ID             int64              `json:"id"`
	PublicID       string             `json:"public_id"`
	Email          string             `json:"email"`
	Name           sql.NullString     `json:"name"`
	GithubUsername sql.NullString     `json:"github_username"`
	VaultEntityID  sql.NullString     `json:"vault_entity_id"`
	AuthMethod     AccountsAuthMethod `json:"auth_method"`
	Verified       bool               `json:"verified"`
	VerifiedAt     sql.NullTime       `json:"verified_at"`
	CreatedAt      sql.NullTime       `json:"created_at"`
	UpdatedAt      sql.NullTime       `json:"updated_at"`
}

func (q *Queries) GetAccountByVaultEntityID(ctx context.Context, vaultEntityID sql.NullString) (GetAccountByVaultEntityIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountByVaultEntityID, vaultEntityID)
	var i GetAccountByVaultEntityIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Email,
		&i.Name,
		&i.GithubUsername,
		&i.VaultEntityID,
		&i.AuthMethod,
		&i.Verified,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveAPIKeyByUUID = `-- name: GetActiveAPIKeyByUUID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, account_id, ` + "`" + `name` + "`" + `, description,
       COALESCE(scopes, '[]') as scopes,
       created_at, last_used_at, expires_at, active, created_by
FROM api_keys
WHERE public_id = UUID_TO_BIN(?)
  AND active = TRUE
  AND (expires_at IS NULL OR expires_at > NOW())
`

type GetActiveAPIKeyByUUIDRow struct {
	ID          int64           `json:"id"`
	PublicID    string          `json:"public_id"`
	AccountID   int64           `json:"account_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Scopes      json.RawMessage `json:"scopes"`
	CreatedAt   sql.NullTime    `json:"created_at"`
	LastUsedAt  sql.NullTime    `json:"last_used_at"`
	ExpiresAt   sql.NullTime    `json:"expires_at"`
	Active      bool            `json:"active"`
	CreatedBy   sql.NullInt64   `json:"created_by"`
}

func (q *Queries) GetActiveAPIKeyByUUID(ctx context.Context, publicID string) (GetActiveAPIKeyByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveAPIKeyByUUID, publicID)
	var i GetActiveAPIKeyByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.AccountID,
		&i.Name,
		&i.Description,
		&i.Scopes,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.Active,
		&i.CreatedBy,
	)
	return i, err
}

const getClaimedEvents = `-- name: GetClaimedEvents :many
SELECT
    id,
    event_id,
    event_type,
    event_source,
    event_subject,
    event_data,
    content_type,
    retry_count,
    created_at,
    last_retry_at
FROM event_queue
WHERE status = 'processing'
  AND processing_by = ?
ORDER BY created_at ASC
`

type GetClaimedEventsRow struct {
	ID           int64          `json:"id"`
	EventID      string         `json:"event_id"`
	EventType    string         `json:"event_type"`
	EventSource  string         `json:"event_source"`
	EventSubject sql.NullString `json:"event_subject"`
	EventData    []byte         `json:"event_data"`
	ContentType  string         `json:"content_type"`
	RetryCount   int32          `json:"retry_count"`
	CreatedAt    time.Time      `json:"created_at"`
	LastRetryAt  sql.NullTime   `json:"last_retry_at"`
}

func (q *Queries) GetClaimedEvents(ctx context.Context, processingBy sql.NullString) ([]GetClaimedEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getClaimedEvents, processingBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClaimedEventsRow{}
	for rows.Next() {
		var i GetClaimedEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.EventType,
			&i.EventSource,
			&i.EventSubject,
			&i.EventData,
			&i.ContentType,
			&i.RetryCount,
			&i.CreatedAt,
			&i.LastRetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeployment = `-- name: GetDeployment :one

SELECT deployment_id, site_id, ` + "`" + `status` + "`" + `, github_run_id, github_run_url, started_at, completed_at, error_message, created_at
FROM deployments WHERE deployment_id = ?
`

// =============================================================================
// DEPLOYMENTS
// =============================================================================
func (q *Queries) GetDeployment(ctx context.Context, deploymentID string) (Deployment, error) {
	row := q.db.QueryRowContext(ctx, getDeployment, deploymentID)
	var i Deployment
	err := row.Scan(
		&i.DeploymentID,
		&i.SiteID,
		&i.Status,
		&i.GithubRunID,
		&i.GithubRunUrl,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getDomain = `-- name: GetDomain :one

SELECT id, site_id, domain, created_at
FROM domains WHERE id = ?
`

// =============================================================================
// DOMAINS
// =============================================================================
func (q *Queries) GetDomain(ctx context.Context, id int64) (Domain, error) {
	row := q.db.QueryRowContext(ctx, getDomain, id)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.Domain,
		&i.CreatedAt,
	)
	return i, err
}

const getDomainByName = `-- name: GetDomainByName :one
SELECT id, site_id, domain, created_at
FROM domains WHERE domain = ?
`

func (q *Queries) GetDomainByName(ctx context.Context, domain string) (Domain, error) {
	row := q.db.QueryRowContext(ctx, getDomainByName, domain)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.Domain,
		&i.CreatedAt,
	)
	return i, err
}

const getEmailVerificationToken = `-- name: GetEmailVerificationToken :one
SELECT id, email, token, password_hash, created_at, expires_at
FROM email_verification_tokens
WHERE email = ? AND token = ?
  AND expires_at > NOW()
`

type GetEmailVerificationTokenParams struct {
	Email string `json:"email"`
	Token string `json:"token"`
}

func (q *Queries) GetEmailVerificationToken(ctx context.Context, arg GetEmailVerificationTokenParams) (EmailVerificationToken, error) {
	row := q.db.QueryRowContext(ctx, getEmailVerificationToken, arg.Email, arg.Token)
	var i EmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Token,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getEmailVerificationTokenByEmail = `-- name: GetEmailVerificationTokenByEmail :one
SELECT id, email, token, password_hash, created_at, expires_at
FROM email_verification_tokens
WHERE email = ?
  AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetEmailVerificationTokenByEmail(ctx context.Context, email string) (EmailVerificationToken, error) {
	row := q.db.QueryRowContext(ctx, getEmailVerificationTokenByEmail, email)
	var i EmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Token,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getLatestSiteDeployment = `-- name: GetLatestSiteDeployment :one
SELECT deployment_id, site_id, status, github_run_id, github_run_url, started_at, completed_at, error_message, created_at FROM deployments
WHERE site_id = ?
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestSiteDeployment(ctx context.Context, siteID string) (Deployment, error) {
	row := q.db.QueryRowContext(ctx, getLatestSiteDeployment, siteID)
	var i Deployment
	err := row.Scan(
		&i.DeploymentID,
		&i.SiteID,
		&i.Status,
		&i.GithubRunID,
		&i.GithubRunUrl,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getOrganization = `-- name: GetOrganization :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, ` + "`" + `name` + "`" + `, gcp_org_id, gcp_billing_account, gcp_parent, gcp_folder_id, ` + "`" + `status` + "`" + `, gcp_project_id, gcp_project_number, created_at, updated_at, created_by, updated_by
FROM organizations WHERE public_id = UUID_TO_BIN(?)
`

type GetOrganizationRow struct {
	ID                int64                   `json:"id"`
	PublicID          string                  `json:"public_id"`
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	GcpProjectID      sql.NullString          `json:"gcp_project_id"`
	GcpProjectNumber  sql.NullString          `json:"gcp_project_number"`
	CreatedAt         sql.NullTime            `json:"created_at"`
	UpdatedAt         sql.NullTime            `json:"updated_at"`
	CreatedBy         sql.NullInt64           `json:"created_by"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) GetOrganization(ctx context.Context, publicID string) (GetOrganizationRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganization, publicID)
	var i GetOrganizationRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.GcpOrgID,
		&i.GcpBillingAccount,
		&i.GcpParent,
		&i.GcpFolderID,
		&i.Status,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationByGCPProjectID = `-- name: GetOrganizationByGCPProjectID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, ` + "`" + `name` + "`" + `, gcp_org_id, gcp_billing_account, gcp_parent, gcp_folder_id, ` + "`" + `status` + "`" + `, gcp_project_id, gcp_project_number, created_at, updated_at, created_by, updated_by
FROM organizations WHERE gcp_project_id = ?
`

type GetOrganizationByGCPProjectIDRow struct {
	ID                int64                   `json:"id"`
	PublicID          string                  `json:"public_id"`
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	GcpProjectID      sql.NullString          `json:"gcp_project_id"`
	GcpProjectNumber  sql.NullString          `json:"gcp_project_number"`
	CreatedAt         sql.NullTime            `json:"created_at"`
	UpdatedAt         sql.NullTime            `json:"updated_at"`
	CreatedBy         sql.NullInt64           `json:"created_by"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) GetOrganizationByGCPProjectID(ctx context.Context, gcpProjectID sql.NullString) (GetOrganizationByGCPProjectIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByGCPProjectID, gcpProjectID)
	var i GetOrganizationByGCPProjectIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.GcpOrgID,
		&i.GcpBillingAccount,
		&i.GcpParent,
		&i.GcpFolderID,
		&i.Status,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, ` + "`" + `name` + "`" + `, gcp_org_id, gcp_billing_account, gcp_parent, gcp_folder_id, ` + "`" + `status` + "`" + `, gcp_project_id, gcp_project_number, created_at, updated_at, created_by, updated_by
FROM organizations WHERE id = ?
`

type GetOrganizationByIDRow struct {
	ID                int64                   `json:"id"`
	PublicID          string                  `json:"public_id"`
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	GcpProjectID      sql.NullString          `json:"gcp_project_id"`
	GcpProjectNumber  sql.NullString          `json:"gcp_project_number"`
	CreatedAt         sql.NullTime            `json:"created_at"`
	UpdatedAt         sql.NullTime            `json:"updated_at"`
	CreatedBy         sql.NullInt64           `json:"created_by"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) GetOrganizationByID(ctx context.Context, id int64) (GetOrganizationByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByID, id)
	var i GetOrganizationByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.GcpOrgID,
		&i.GcpBillingAccount,
		&i.GcpParent,
		&i.GcpFolderID,
		&i.Status,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationFirewallRule = `-- name: GetOrganizationFirewallRule :one

SELECT id, organization_id, rule_type, cidr, created_at, updated_at, created_by, updated_by
FROM organization_firewall_rules WHERE id = ?
`

type GetOrganizationFirewallRuleRow struct {
	ID             int64                             `json:"id"`
	OrganizationID sql.NullInt64                     `json:"organization_id"`
	RuleType       OrganizationFirewallRulesRuleType `json:"rule_type"`
	Cidr           string                            `json:"cidr"`
	CreatedAt      sql.NullTime                      `json:"created_at"`
	UpdatedAt      sql.NullTime                      `json:"updated_at"`
	CreatedBy      sql.NullInt64                     `json:"created_by"`
	UpdatedBy      sql.NullInt64                     `json:"updated_by"`
}

// =============================================================================
// ORGANIZATION FIREWALL RULES
// =============================================================================
func (q *Queries) GetOrganizationFirewallRule(ctx context.Context, id int64) (GetOrganizationFirewallRuleRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationFirewallRule, id)
	var i GetOrganizationFirewallRuleRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.RuleType,
		&i.Cidr,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationMember = `-- name: GetOrganizationMember :one

SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
FROM organization_members WHERE organization_id = ? AND account_id = ?
`

type GetOrganizationMemberParams struct {
	OrganizationID int64 `json:"organization_id"`
	AccountID      int64 `json:"account_id"`
}

type GetOrganizationMemberRow struct {
	ID             int64                   `json:"id"`
	PublicID       string                  `json:"public_id"`
	OrganizationID int64                   `json:"organization_id"`
	AccountID      int64                   `json:"account_id"`
	Role           OrganizationMembersRole `json:"role"`
	CreatedAt      sql.NullTime            `json:"created_at"`
	UpdatedAt      sql.NullTime            `json:"updated_at"`
	CreatedBy      sql.NullInt64           `json:"created_by"`
	UpdatedBy      sql.NullInt64           `json:"updated_by"`
}

// =============================================================================
// ORGANIZATION MEMBERS
// =============================================================================
func (q *Queries) GetOrganizationMember(ctx context.Context, arg GetOrganizationMemberParams) (GetOrganizationMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationMember, arg.OrganizationID, arg.AccountID)
	var i GetOrganizationMemberRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.AccountID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationMemberByAccountAndOrganization = `-- name: GetOrganizationMemberByAccountAndOrganization :one

SELECT id, public_id, organization_id, account_id, role, status, created_at, updated_at, created_by, updated_by FROM organization_members
WHERE account_id = ? AND organization_id = ? AND status = 'active'
`

type GetOrganizationMemberByAccountAndOrganizationParams struct {
	AccountID      int64 `json:"account_id"`
	OrganizationID int64 `json:"organization_id"`
}

// =============================================================================
// MEMBERSHIP QUERIES FOR AUTHORIZATION
// =============================================================================
func (q *Queries) GetOrganizationMemberByAccountAndOrganization(ctx context.Context, arg GetOrganizationMemberByAccountAndOrganizationParams) (OrganizationMember, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationMemberByAccountAndOrganization, arg.AccountID, arg.OrganizationID)
	var i OrganizationMember
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.AccountID,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationProjectByOrganizationID = `-- name: GetOrganizationProjectByOrganizationID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, ` + "`" + `name` + "`" + `,
       github_repository, github_branch, compose_path,
       gcp_region, gcp_zone, machine_type, disk_size_gb, compose_file, application_type,
       promote_strategy,
       monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
       gcp_project_id, gcp_project_number, github_team_id, create_branch_sites, organization_project, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM projects
WHERE organization_id = ? AND organization_project = TRUE
LIMIT 1
`

type GetOrganizationProjectByOrganizationIDRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GithubRepository          sql.NullString              `json:"github_repository"`
	GithubBranch              sql.NullString              `json:"github_branch"`
	ComposePath               sql.NullString              `json:"compose_path"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	ComposeFile               sql.NullString              `json:"compose_file"`
	ApplicationType           sql.NullString              `json:"application_type"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	GithubTeamID              sql.NullString              `json:"github_team_id"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) GetOrganizationProjectByOrganizationID(ctx context.Context, organizationID int64) (GetOrganizationProjectByOrganizationIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationProjectByOrganizationID, organizationID)
	var i GetOrganizationProjectByOrganizationIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GithubRepository,
		&i.GithubBranch,
		&i.ComposePath,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.ComposeFile,
		&i.ApplicationType,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.GithubTeamID,
		&i.CreateBranchSites,
		&i.OrganizationProject,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationSecretByID = `-- name: GetOrganizationSecretByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM organization_secrets WHERE id = ? AND status != 'deleted'
`

type GetOrganizationSecretByIDRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

func (q *Queries) GetOrganizationSecretByID(ctx context.Context, id int64) (GetOrganizationSecretByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationSecretByID, id)
	var i GetOrganizationSecretByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationSecretByName = `-- name: GetOrganizationSecretByName :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM organization_secrets
WHERE organization_id = ? AND name = ? AND status != 'deleted'
`

type GetOrganizationSecretByNameParams struct {
	OrganizationID int64  `json:"organization_id"`
	Name           string `json:"name"`
}

type GetOrganizationSecretByNameRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

func (q *Queries) GetOrganizationSecretByName(ctx context.Context, arg GetOrganizationSecretByNameParams) (GetOrganizationSecretByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationSecretByName, arg.OrganizationID, arg.Name)
	var i GetOrganizationSecretByNameRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationSecretByPublicID = `-- name: GetOrganizationSecretByPublicID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM organization_secrets WHERE public_id = UUID_TO_BIN(?) AND status != 'deleted'
`

type GetOrganizationSecretByPublicIDRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

func (q *Queries) GetOrganizationSecretByPublicID(ctx context.Context, publicID string) (GetOrganizationSecretByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationSecretByPublicID, publicID)
	var i GetOrganizationSecretByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProject = `-- name: GetProject :one

SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, ` + "`" + `name` + "`" + `,
       github_repository, github_branch, compose_path,
       gcp_region, gcp_zone, machine_type, disk_size_gb, compose_file, application_type,
       promote_strategy,
       monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
       gcp_project_id, gcp_project_number, github_team_id, create_branch_sites, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM projects WHERE public_id = UUID_TO_BIN(?)
`

type GetProjectRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GithubRepository          sql.NullString              `json:"github_repository"`
	GithubBranch              sql.NullString              `json:"github_branch"`
	ComposePath               sql.NullString              `json:"compose_path"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	ComposeFile               sql.NullString              `json:"compose_file"`
	ApplicationType           sql.NullString              `json:"application_type"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	GithubTeamID              sql.NullString              `json:"github_team_id"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

// =============================================================================
// PROJECTS
// =============================================================================
func (q *Queries) GetProject(ctx context.Context, publicID string) (GetProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getProject, publicID)
	var i GetProjectRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GithubRepository,
		&i.GithubBranch,
		&i.ComposePath,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.ComposeFile,
		&i.ApplicationType,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.GithubTeamID,
		&i.CreateBranchSites,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectByGCPProjectID = `-- name: GetProjectByGCPProjectID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, ` + "`" + `name` + "`" + `,
       github_repository, github_branch, compose_path,
       gcp_region, gcp_zone, machine_type, disk_size_gb, compose_file, application_type,
       promote_strategy,
       monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
       gcp_project_id, gcp_project_number, github_team_id, create_branch_sites, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM projects WHERE gcp_project_id = ?
`

type GetProjectByGCPProjectIDRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GithubRepository          sql.NullString              `json:"github_repository"`
	GithubBranch              sql.NullString              `json:"github_branch"`
	ComposePath               sql.NullString              `json:"compose_path"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	ComposeFile               sql.NullString              `json:"compose_file"`
	ApplicationType           sql.NullString              `json:"application_type"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	GithubTeamID              sql.NullString              `json:"github_team_id"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) GetProjectByGCPProjectID(ctx context.Context, gcpProjectID sql.NullString) (GetProjectByGCPProjectIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectByGCPProjectID, gcpProjectID)
	var i GetProjectByGCPProjectIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GithubRepository,
		&i.GithubBranch,
		&i.ComposePath,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.ComposeFile,
		&i.ApplicationType,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.GithubTeamID,
		&i.CreateBranchSites,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, ` + "`" + `name` + "`" + `,
       github_repository, github_branch, compose_path,
       gcp_region, gcp_zone, machine_type, disk_size_gb, compose_file, application_type,
       promote_strategy,
       monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
       gcp_project_id, gcp_project_number, github_team_id, create_branch_sites, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM projects WHERE id = ?
`

type GetProjectByIDRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GithubRepository          sql.NullString              `json:"github_repository"`
	GithubBranch              sql.NullString              `json:"github_branch"`
	ComposePath               sql.NullString              `json:"compose_path"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	ComposeFile               sql.NullString              `json:"compose_file"`
	ApplicationType           sql.NullString              `json:"application_type"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	GithubTeamID              sql.NullString              `json:"github_team_id"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) GetProjectByID(ctx context.Context, id int64) (GetProjectByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, id)
	var i GetProjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GithubRepository,
		&i.GithubBranch,
		&i.ComposePath,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.ComposeFile,
		&i.ApplicationType,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.GithubTeamID,
		&i.CreateBranchSites,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectFirewallRule = `-- name: GetProjectFirewallRule :one

SELECT id, project_id, rule_type, cidr, created_at, updated_at, created_by, updated_by
FROM project_firewall_rules WHERE id = ?
`

type GetProjectFirewallRuleRow struct {
	ID        int64                        `json:"id"`
	ProjectID sql.NullInt64                `json:"project_id"`
	RuleType  ProjectFirewallRulesRuleType `json:"rule_type"`
	Cidr      string                       `json:"cidr"`
	CreatedAt sql.NullTime                 `json:"created_at"`
	UpdatedAt sql.NullTime                 `json:"updated_at"`
	CreatedBy sql.NullInt64                `json:"created_by"`
	UpdatedBy sql.NullInt64                `json:"updated_by"`
}

// =============================================================================
// PROJECT FIREWALL RULES
// =============================================================================
func (q *Queries) GetProjectFirewallRule(ctx context.Context, id int64) (GetProjectFirewallRuleRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectFirewallRule, id)
	var i GetProjectFirewallRuleRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.RuleType,
		&i.Cidr,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectMember = `-- name: GetProjectMember :one

SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
FROM project_members WHERE project_id = ? AND account_id = ?
`

type GetProjectMemberParams struct {
	ProjectID int64 `json:"project_id"`
	AccountID int64 `json:"account_id"`
}

type GetProjectMemberRow struct {
	ID        int64              `json:"id"`
	PublicID  string             `json:"public_id"`
	ProjectID int64              `json:"project_id"`
	AccountID int64              `json:"account_id"`
	Role      ProjectMembersRole `json:"role"`
	CreatedAt sql.NullTime       `json:"created_at"`
	UpdatedAt sql.NullTime       `json:"updated_at"`
	CreatedBy sql.NullInt64      `json:"created_by"`
	UpdatedBy sql.NullInt64      `json:"updated_by"`
}

// =============================================================================
// PROJECT MEMBERS
// =============================================================================
func (q *Queries) GetProjectMember(ctx context.Context, arg GetProjectMemberParams) (GetProjectMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectMember, arg.ProjectID, arg.AccountID)
	var i GetProjectMemberRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.AccountID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectMemberByAccountAndProject = `-- name: GetProjectMemberByAccountAndProject :one
SELECT id, public_id, project_id, account_id, role, status, created_at, updated_at, created_by, updated_by FROM project_members
WHERE account_id = ? AND project_id = ? AND status = 'active'
`

type GetProjectMemberByAccountAndProjectParams struct {
	AccountID int64 `json:"account_id"`
	ProjectID int64 `json:"project_id"`
}

func (q *Queries) GetProjectMemberByAccountAndProject(ctx context.Context, arg GetProjectMemberByAccountAndProjectParams) (ProjectMember, error) {
	row := q.db.QueryRowContext(ctx, getProjectMemberByAccountAndProject, arg.AccountID, arg.ProjectID)
	var i ProjectMember
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.AccountID,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectSecretByID = `-- name: GetProjectSecretByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM project_secrets WHERE id = ? AND status != 'deleted'
`

type GetProjectSecretByIDRow struct {
	ID        int64                    `json:"id"`
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

func (q *Queries) GetProjectSecretByID(ctx context.Context, id int64) (GetProjectSecretByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectSecretByID, id)
	var i GetProjectSecretByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectSecretByName = `-- name: GetProjectSecretByName :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM project_secrets
WHERE project_id = ? AND name = ? AND status != 'deleted'
`

type GetProjectSecretByNameParams struct {
	ProjectID int64  `json:"project_id"`
	Name      string `json:"name"`
}

type GetProjectSecretByNameRow struct {
	ID        int64                    `json:"id"`
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

func (q *Queries) GetProjectSecretByName(ctx context.Context, arg GetProjectSecretByNameParams) (GetProjectSecretByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectSecretByName, arg.ProjectID, arg.Name)
	var i GetProjectSecretByNameRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectSecretByPublicID = `-- name: GetProjectSecretByPublicID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM project_secrets WHERE public_id = UUID_TO_BIN(?) AND status != 'deleted'
`

type GetProjectSecretByPublicIDRow struct {
	ID        int64                    `json:"id"`
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

func (q *Queries) GetProjectSecretByPublicID(ctx context.Context, publicID string) (GetProjectSecretByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectSecretByPublicID, publicID)
	var i GetProjectSecretByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectWithOrganization = `-- name: GetProjectWithOrganization :one
SELECT
    p.id, BIN_TO_UUID(p.public_id) AS public_id, p.organization_id, p.name,
    p.github_repository, p.github_branch, p.compose_path,
    p.gcp_region, p.gcp_zone, p.machine_type, p.disk_size_gb, p.compose_file, p.application_type,
    p.promote_strategy,
    p.monitoring_enabled, p.monitoring_log_level, p.monitoring_metrics_enabled, p.monitoring_health_check_path,
    p.gcp_project_id, p.gcp_project_number, p.github_team_id, p.create_branch_sites, p.status,
    p.created_at, p.updated_at, p.created_by, p.updated_by,
    c.gcp_billing_account
FROM projects p
JOIN organizations c ON p.organization_id = c.id
WHERE p.public_id = UUID_TO_BIN(?)
`

type GetProjectWithOrganizationRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GithubRepository          sql.NullString              `json:"github_repository"`
	GithubBranch              sql.NullString              `json:"github_branch"`
	ComposePath               sql.NullString              `json:"compose_path"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	ComposeFile               sql.NullString              `json:"compose_file"`
	ApplicationType           sql.NullString              `json:"application_type"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	GithubTeamID              sql.NullString              `json:"github_team_id"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
	GcpBillingAccount         string                      `json:"gcp_billing_account"`
}

func (q *Queries) GetProjectWithOrganization(ctx context.Context, publicID string) (GetProjectWithOrganizationRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectWithOrganization, publicID)
	var i GetProjectWithOrganizationRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GithubRepository,
		&i.GithubBranch,
		&i.ComposePath,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.ComposeFile,
		&i.ApplicationType,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.GithubTeamID,
		&i.CreateBranchSites,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.GcpBillingAccount,
	)
	return i, err
}

const getQueueStats = `-- name: GetQueueStats :one
SELECT
    COUNT(*) as total_events,
    SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending_events,
    SUM(CASE WHEN status = 'sent' THEN 1 ELSE 0 END) as sent_events,
    SUM(CASE WHEN status = 'dead_letter' THEN 1 ELSE 0 END) as dead_letter_events
FROM event_queue
`

type GetQueueStatsRow struct {
	TotalEvents      int64       `json:"total_events"`
	PendingEvents    interface{} `json:"pending_events"`
	SentEvents       interface{} `json:"sent_events"`
	DeadLetterEvents interface{} `json:"dead_letter_events"`
}

func (q *Queries) GetQueueStats(ctx context.Context) (GetQueueStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getQueueStats)
	var i GetQueueStatsRow
	err := row.Scan(
		&i.TotalEvents,
		&i.PendingEvents,
		&i.SentEvents,
		&i.DeadLetterEvents,
	)
	return i, err
}

const getRelationship = `-- name: GetRelationship :one

SELECT id, BIN_TO_UUID(public_id) AS public_id, source_organization_id, target_organization_id,
       relationship_type, ` + "`" + `status` + "`" + `, created_at, resolved_at, resolved_by
FROM relationships WHERE public_id = UUID_TO_BIN(?)
`

type GetRelationshipRow struct {
	ID                   int64                         `json:"id"`
	PublicID             string                        `json:"public_id"`
	SourceOrganizationID int64                         `json:"source_organization_id"`
	TargetOrganizationID int64                         `json:"target_organization_id"`
	RelationshipType     RelationshipsRelationshipType `json:"relationship_type"`
	Status               RelationshipsStatus           `json:"status"`
	CreatedAt            sql.NullTime                  `json:"created_at"`
	ResolvedAt           sql.NullTime                  `json:"resolved_at"`
	ResolvedBy           sql.NullInt64                 `json:"resolved_by"`
}

// =============================================================================
// RELATIONSHIPS
// =============================================================================
func (q *Queries) GetRelationship(ctx context.Context, publicID string) (GetRelationshipRow, error) {
	row := q.db.QueryRowContext(ctx, getRelationship, publicID)
	var i GetRelationshipRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SourceOrganizationID,
		&i.TargetOrganizationID,
		&i.RelationshipType,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
		&i.ResolvedBy,
	)
	return i, err
}

const getSite = `-- name: GetSite :one

SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, ` + "`" + `name` + "`" + `, github_ref, gcp_external_ip, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM sites WHERE public_id = UUID_TO_BIN(?)
`

type GetSiteRow struct {
	ID            int64           `json:"id"`
	PublicID      string          `json:"public_id"`
	ProjectID     int64           `json:"project_id"`
	Name          string          `json:"name"`
	GithubRef     string          `json:"github_ref"`
	GcpExternalIp sql.NullString  `json:"gcp_external_ip"`
	Status        NullSitesStatus `json:"status"`
	CreatedAt     sql.NullTime    `json:"created_at"`
	UpdatedAt     sql.NullTime    `json:"updated_at"`
	CreatedBy     sql.NullInt64   `json:"created_by"`
	UpdatedBy     sql.NullInt64   `json:"updated_by"`
}

// =============================================================================
// SITES
// =============================================================================
func (q *Queries) GetSite(ctx context.Context, publicID string) (GetSiteRow, error) {
	row := q.db.QueryRowContext(ctx, getSite, publicID)
	var i GetSiteRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.GithubRef,
		&i.GcpExternalIp,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteByID = `-- name: GetSiteByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, ` + "`" + `name` + "`" + `, github_ref, gcp_external_ip, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM sites WHERE id = ?
`

type GetSiteByIDRow struct {
	ID            int64           `json:"id"`
	PublicID      string          `json:"public_id"`
	ProjectID     int64           `json:"project_id"`
	Name          string          `json:"name"`
	GithubRef     string          `json:"github_ref"`
	GcpExternalIp sql.NullString  `json:"gcp_external_ip"`
	Status        NullSitesStatus `json:"status"`
	CreatedAt     sql.NullTime    `json:"created_at"`
	UpdatedAt     sql.NullTime    `json:"updated_at"`
	CreatedBy     sql.NullInt64   `json:"created_by"`
	UpdatedBy     sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) GetSiteByID(ctx context.Context, id int64) (GetSiteByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteByID, id)
	var i GetSiteByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.GithubRef,
		&i.GcpExternalIp,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteByProjectAndName = `-- name: GetSiteByProjectAndName :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, ` + "`" + `name` + "`" + `, github_ref, gcp_external_ip, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM sites WHERE project_id = ? AND ` + "`" + `name` + "`" + ` = ?
`

type GetSiteByProjectAndNameParams struct {
	ProjectID int64  `json:"project_id"`
	Name      string `json:"name"`
}

type GetSiteByProjectAndNameRow struct {
	ID            int64           `json:"id"`
	PublicID      string          `json:"public_id"`
	ProjectID     int64           `json:"project_id"`
	Name          string          `json:"name"`
	GithubRef     string          `json:"github_ref"`
	GcpExternalIp sql.NullString  `json:"gcp_external_ip"`
	Status        NullSitesStatus `json:"status"`
	CreatedAt     sql.NullTime    `json:"created_at"`
	UpdatedAt     sql.NullTime    `json:"updated_at"`
	CreatedBy     sql.NullInt64   `json:"created_by"`
	UpdatedBy     sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) GetSiteByProjectAndName(ctx context.Context, arg GetSiteByProjectAndNameParams) (GetSiteByProjectAndNameRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteByProjectAndName, arg.ProjectID, arg.Name)
	var i GetSiteByProjectAndNameRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.GithubRef,
		&i.GcpExternalIp,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteFirewallRule = `-- name: GetSiteFirewallRule :one

SELECT id, site_id, rule_type, cidr, created_at, updated_at, created_by, updated_by
FROM site_firewall_rules WHERE id = ?
`

type GetSiteFirewallRuleRow struct {
	ID        int64                     `json:"id"`
	SiteID    sql.NullInt64             `json:"site_id"`
	RuleType  SiteFirewallRulesRuleType `json:"rule_type"`
	Cidr      string                    `json:"cidr"`
	CreatedAt sql.NullTime              `json:"created_at"`
	UpdatedAt sql.NullTime              `json:"updated_at"`
	CreatedBy sql.NullInt64             `json:"created_by"`
	UpdatedBy sql.NullInt64             `json:"updated_by"`
}

// =============================================================================
// SITE FIREWALL RULES
// =============================================================================
func (q *Queries) GetSiteFirewallRule(ctx context.Context, id int64) (GetSiteFirewallRuleRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteFirewallRule, id)
	var i GetSiteFirewallRuleRow
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.RuleType,
		&i.Cidr,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteMember = `-- name: GetSiteMember :one

SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
FROM site_members WHERE site_id = ? AND account_id = ?
`

type GetSiteMemberParams struct {
	SiteID    int64 `json:"site_id"`
	AccountID int64 `json:"account_id"`
}

type GetSiteMemberRow struct {
	ID        int64           `json:"id"`
	PublicID  string          `json:"public_id"`
	SiteID    int64           `json:"site_id"`
	AccountID int64           `json:"account_id"`
	Role      SiteMembersRole `json:"role"`
	CreatedAt sql.NullTime    `json:"created_at"`
	UpdatedAt sql.NullTime    `json:"updated_at"`
	CreatedBy sql.NullInt64   `json:"created_by"`
	UpdatedBy sql.NullInt64   `json:"updated_by"`
}

// =============================================================================
// SITE MEMBERS
// =============================================================================
func (q *Queries) GetSiteMember(ctx context.Context, arg GetSiteMemberParams) (GetSiteMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteMember, arg.SiteID, arg.AccountID)
	var i GetSiteMemberRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.AccountID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteMemberByAccountAndSite = `-- name: GetSiteMemberByAccountAndSite :one
SELECT id, public_id, site_id, account_id, role, status, created_at, updated_at, created_by, updated_by FROM site_members
WHERE account_id = ? AND site_id = ? AND status = 'active'
`

type GetSiteMemberByAccountAndSiteParams struct {
	AccountID int64 `json:"account_id"`
	SiteID    int64 `json:"site_id"`
}

func (q *Queries) GetSiteMemberByAccountAndSite(ctx context.Context, arg GetSiteMemberByAccountAndSiteParams) (SiteMember, error) {
	row := q.db.QueryRowContext(ctx, getSiteMemberByAccountAndSite, arg.AccountID, arg.SiteID)
	var i SiteMember
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.AccountID,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteSecretByID = `-- name: GetSiteSecretByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM site_secrets WHERE id = ? AND status != 'deleted'
`

type GetSiteSecretByIDRow struct {
	ID        int64                 `json:"id"`
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

func (q *Queries) GetSiteSecretByID(ctx context.Context, id int64) (GetSiteSecretByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteSecretByID, id)
	var i GetSiteSecretByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteSecretByName = `-- name: GetSiteSecretByName :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM site_secrets
WHERE site_id = ? AND name = ? AND status != 'deleted'
`

type GetSiteSecretByNameParams struct {
	SiteID int64  `json:"site_id"`
	Name   string `json:"name"`
}

type GetSiteSecretByNameRow struct {
	ID        int64                 `json:"id"`
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

func (q *Queries) GetSiteSecretByName(ctx context.Context, arg GetSiteSecretByNameParams) (GetSiteSecretByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteSecretByName, arg.SiteID, arg.Name)
	var i GetSiteSecretByNameRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteSecretByPublicID = `-- name: GetSiteSecretByPublicID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM site_secrets WHERE public_id = UUID_TO_BIN(?) AND status != 'deleted'
`

type GetSiteSecretByPublicIDRow struct {
	ID        int64                 `json:"id"`
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

func (q *Queries) GetSiteSecretByPublicID(ctx context.Context, publicID string) (GetSiteSecretByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteSecretByPublicID, publicID)
	var i GetSiteSecretByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSshAccess = `-- name: GetSshAccess :one

SELECT id, account_id, site_id, created_at, updated_at, created_by, updated_by
FROM ssh_access WHERE account_id = ? AND site_id = ?
`

type GetSshAccessParams struct {
	AccountID int64 `json:"account_id"`
	SiteID    int64 `json:"site_id"`
}

// =============================================================================
// Ssh ACCESS
// =============================================================================
func (q *Queries) GetSshAccess(ctx context.Context, arg GetSshAccessParams) (SshAccess, error) {
	row := q.db.QueryRowContext(ctx, getSshAccess, arg.AccountID, arg.SiteID)
	var i SshAccess
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.SiteID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSshKey = `-- name: GetSshKey :one

SELECT sk.id, BIN_TO_UUID(sk.public_id) AS public_id,
       BIN_TO_UUID(a.public_id) AS account_public_id,
       sk.public_key, sk.` + "`" + `name` + "`" + `, sk.fingerprint,
       sk.created_at, sk.updated_at
FROM ssh_keys sk
JOIN accounts a ON sk.account_id = a.id
WHERE sk.public_id = UUID_TO_BIN(?)
`

type GetSshKeyRow struct {
	ID              int64          `json:"id"`
	PublicID        string         `json:"public_id"`
	AccountPublicID string         `json:"account_public_id"`
	PublicKey       string         `json:"public_key"`
	Name            sql.NullString `json:"name"`
	Fingerprint     sql.NullString `json:"fingerprint"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
}

// =============================================================================
// Ssh KEYS
// =============================================================================
func (q *Queries) GetSshKey(ctx context.Context, publicID string) (GetSshKeyRow, error) {
	row := q.db.QueryRowContext(ctx, getSshKey, publicID)
	var i GetSshKeyRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.AccountPublicID,
		&i.PublicKey,
		&i.Name,
		&i.Fingerprint,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hasUserProjectAccessInOrganization = `-- name: HasUserProjectAccessInOrganization :one
SELECT EXISTS (
    SELECT 1 FROM project_members pm
    JOIN projects p ON pm.project_id = p.id
    LEFT JOIN relationships r ON (
        r.source_organization_id = p.organization_id AND r.target_organization_id = ?
    )
    WHERE pm.account_id = ?
      AND (p.organization_id = ? OR (r.status = 'approved' AND r.id IS NOT NULL))
      AND pm.status = 'active'
    LIMIT 1
)
`

type HasUserProjectAccessInOrganizationParams struct {
	TargetOrganizationID int64 `json:"target_organization_id"`
	AccountID            int64 `json:"account_id"`
	OrganizationID       int64 `json:"organization_id"`
}

func (q *Queries) HasUserProjectAccessInOrganization(ctx context.Context, arg HasUserProjectAccessInOrganizationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserProjectAccessInOrganization, arg.TargetOrganizationID, arg.AccountID, arg.OrganizationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasUserRelationshipAccessToOrganization = `-- name: HasUserRelationshipAccessToOrganization :one
WITH RECURSIVE user_access AS (
    SELECT organization_id
    FROM organization_members
    WHERE account_id = ? AND status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_access ua ON r.source_organization_id = ua.organization_id
    WHERE r.status = 'approved'
)
SELECT EXISTS (
    SELECT 1 FROM user_access WHERE organization_id = ?
)
`

type HasUserRelationshipAccessToOrganizationParams struct {
	AccountID      int64 `json:"account_id"`
	OrganizationID int64 `json:"organization_id"`
}

func (q *Queries) HasUserRelationshipAccessToOrganization(ctx context.Context, arg HasUserRelationshipAccessToOrganizationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserRelationshipAccessToOrganization, arg.AccountID, arg.OrganizationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasUserSiteAccessInOrganization = `-- name: HasUserSiteAccessInOrganization :one
SELECT EXISTS (
    SELECT 1 FROM site_members sm
    JOIN sites s ON sm.site_id = s.id
    JOIN projects p ON s.project_id = p.id
    LEFT JOIN relationships r ON (
        r.source_organization_id = p.organization_id AND r.target_organization_id = ?
    )
    WHERE sm.account_id = ?
      AND (p.organization_id = ? OR (r.status = 'approved' AND r.id IS NOT NULL))
      AND sm.status = 'active'
    LIMIT 1
)
`

type HasUserSiteAccessInOrganizationParams struct {
	TargetOrganizationID int64 `json:"target_organization_id"`
	AccountID            int64 `json:"account_id"`
	OrganizationID       int64 `json:"organization_id"`
}

func (q *Queries) HasUserSiteAccessInOrganization(ctx context.Context, arg HasUserSiteAccessInOrganizationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserSiteAccessInOrganization, arg.TargetOrganizationID, arg.AccountID, arg.OrganizationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasUserSiteAccessInProject = `-- name: HasUserSiteAccessInProject :one
SELECT EXISTS (
    SELECT 1 FROM site_members sm
    JOIN sites s ON sm.site_id = s.id
    JOIN projects p ON s.project_id = p.id
    JOIN projects p_target ON p_target.id = ?
    LEFT JOIN relationships r ON (
        r.source_organization_id = p.organization_id AND r.target_organization_id = p_target.organization_id
    )
    WHERE sm.account_id = ?
      AND (s.project_id = ? OR (r.status = 'approved' AND r.id IS NOT NULL))
      AND sm.status = 'active'
    LIMIT 1
)
`

type HasUserSiteAccessInProjectParams struct {
	ID        int64 `json:"id"`
	AccountID int64 `json:"account_id"`
	ProjectID int64 `json:"project_id"`
}

func (q *Queries) HasUserSiteAccessInProject(ctx context.Context, arg HasUserSiteAccessInProjectParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserSiteAccessInProject, arg.ID, arg.AccountID, arg.ProjectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const incrementFailedLoginAttempts = `-- name: IncrementFailedLoginAttempts :exec
UPDATE accounts SET
  failed_login_attempts = failed_login_attempts + 1,
  last_failed_login_at = NOW()
WHERE id = ?
`

func (q *Queries) IncrementFailedLoginAttempts(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementFailedLoginAttempts, id)
	return err
}

const listAPIKeysByAccount = `-- name: ListAPIKeysByAccount :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, account_id, ` + "`" + `name` + "`" + `, description,
       COALESCE(scopes, '[]') as scopes,
       created_at, last_used_at, expires_at, active, created_by
FROM api_keys
WHERE account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAPIKeysByAccountParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListAPIKeysByAccountRow struct {
	ID          int64           `json:"id"`
	PublicID    string          `json:"public_id"`
	AccountID   int64           `json:"account_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Scopes      json.RawMessage `json:"scopes"`
	CreatedAt   sql.NullTime    `json:"created_at"`
	LastUsedAt  sql.NullTime    `json:"last_used_at"`
	ExpiresAt   sql.NullTime    `json:"expires_at"`
	Active      bool            `json:"active"`
	CreatedBy   sql.NullInt64   `json:"created_by"`
}

func (q *Queries) ListAPIKeysByAccount(ctx context.Context, arg ListAPIKeysByAccountParams) ([]ListAPIKeysByAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listAPIKeysByAccount, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAPIKeysByAccountRow{}
	for rows.Next() {
		var i ListAPIKeysByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.AccountID,
			&i.Name,
			&i.Description,
			&i.Scopes,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.ExpiresAt,
			&i.Active,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountOrganizations = `-- name: ListAccountOrganizations :many
SELECT c.id, BIN_TO_UUID(c.public_id) AS public_id, c.` + "`" + `name` + "`" + `, cm.` + "`" + `role` + "`" + `
FROM organization_members cm
JOIN organizations c ON cm.organization_id = c.id
WHERE cm.account_id = ?
ORDER BY c.created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountOrganizationsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListAccountOrganizationsRow struct {
	ID       int64                   `json:"id"`
	PublicID string                  `json:"public_id"`
	Name     string                  `json:"name"`
	Role     OrganizationMembersRole `json:"role"`
}

func (q *Queries) ListAccountOrganizations(ctx context.Context, arg ListAccountOrganizationsParams) ([]ListAccountOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccountOrganizations, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountOrganizationsRow{}
	for rows.Next() {
		var i ListAccountOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountProjects = `-- name: ListAccountProjects :many
SELECT p.id, BIN_TO_UUID(p.public_id) AS public_id, p.` + "`" + `name` + "`" + `, pm.` + "`" + `role` + "`" + `
FROM project_members pm
JOIN projects p ON pm.project_id = p.id
WHERE pm.account_id = ?
ORDER BY p.created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountProjectsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListAccountProjectsRow struct {
	ID       int64              `json:"id"`
	PublicID string             `json:"public_id"`
	Name     string             `json:"name"`
	Role     ProjectMembersRole `json:"role"`
}

func (q *Queries) ListAccountProjects(ctx context.Context, arg ListAccountProjectsParams) ([]ListAccountProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccountProjects, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountProjectsRow{}
	for rows.Next() {
		var i ListAccountProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountSites = `-- name: ListAccountSites :many
SELECT s.id, BIN_TO_UUID(s.public_id) AS public_id, s.` + "`" + `name` + "`" + `, sm.` + "`" + `role` + "`" + `
FROM site_members sm
JOIN sites s ON sm.site_id = s.id
WHERE sm.account_id = ?
ORDER BY s.created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountSitesParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListAccountSitesRow struct {
	ID       int64           `json:"id"`
	PublicID string          `json:"public_id"`
	Name     string          `json:"name"`
	Role     SiteMembersRole `json:"role"`
}

func (q *Queries) ListAccountSites(ctx context.Context, arg ListAccountSitesParams) ([]ListAccountSitesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccountSites, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountSitesRow{}
	for rows.Next() {
		var i ListAccountSitesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountSshAccess = `-- name: ListAccountSshAccess :many
SELECT id, account_id, site_id, created_at, updated_at, created_by, updated_by FROM ssh_access
WHERE account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountSshAccessParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListAccountSshAccess(ctx context.Context, arg ListAccountSshAccessParams) ([]SshAccess, error) {
	rows, err := q.db.QueryContext(ctx, listAccountSshAccess, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SshAccess{}
	for rows.Next() {
		var i SshAccess
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SiteID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, email, name, github_username, vault_entity_id, auth_method, verified, verified_at, failed_login_attempts, last_failed_login_at, created_at, updated_at
FROM accounts
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAccountsRow struct {
	ID                  int64              `json:"id"`
	PublicID            string             `json:"public_id"`
	Email               string             `json:"email"`
	Name                sql.NullString     `json:"name"`
	GithubUsername      sql.NullString     `json:"github_username"`
	VaultEntityID       sql.NullString     `json:"vault_entity_id"`
	AuthMethod          AccountsAuthMethod `json:"auth_method"`
	Verified            bool               `json:"verified"`
	VerifiedAt          sql.NullTime       `json:"verified_at"`
	FailedLoginAttempts int32              `json:"failed_login_attempts"`
	LastFailedLoginAt   sql.NullTime       `json:"last_failed_login_at"`
	CreatedAt           sql.NullTime       `json:"created_at"`
	UpdatedAt           sql.NullTime       `json:"updated_at"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]ListAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountsRow{}
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
			&i.VaultEntityID,
			&i.AuthMethod,
			&i.Verified,
			&i.VerifiedAt,
			&i.FailedLoginAttempts,
			&i.LastFailedLoginAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApprovedRelatedOrganizationsForAccount = `-- name: ListApprovedRelatedOrganizationsForAccount :many
WITH user_orgs AS (
    SELECT organization_id FROM organization_members WHERE account_id = ? AND status = 'active'
)
SELECT r.id, BIN_TO_UUID(r.public_id) AS public_id, r.source_organization_id, r.target_organization_id,
       r.relationship_type, r.` + "`" + `status` + "`" + `, r.created_at, r.resolved_at, r.resolved_by,
       BIN_TO_UUID(target_org.public_id) AS target_org_public_id
FROM relationships r
INNER JOIN organizations target_org ON r.target_organization_id = target_org.id
WHERE r.source_organization_id = ?
  AND r.` + "`" + `status` + "`" + ` = 'approved'
  AND r.target_organization_id IN (SELECT organization_id FROM user_orgs)
ORDER BY r.created_at DESC
`

type ListApprovedRelatedOrganizationsForAccountParams struct {
	AccountID            int64 `json:"account_id"`
	SourceOrganizationID int64 `json:"source_organization_id"`
}

type ListApprovedRelatedOrganizationsForAccountRow struct {
	ID                   int64                         `json:"id"`
	PublicID             string                        `json:"public_id"`
	SourceOrganizationID int64                         `json:"source_organization_id"`
	TargetOrganizationID int64                         `json:"target_organization_id"`
	RelationshipType     RelationshipsRelationshipType `json:"relationship_type"`
	Status               RelationshipsStatus           `json:"status"`
	CreatedAt            sql.NullTime                  `json:"created_at"`
	ResolvedAt           sql.NullTime                  `json:"resolved_at"`
	ResolvedBy           sql.NullInt64                 `json:"resolved_by"`
	TargetOrgPublicID    string                        `json:"target_org_public_id"`
}

// Get all approved relationships for a source org where the account has access to the target org
func (q *Queries) ListApprovedRelatedOrganizationsForAccount(ctx context.Context, arg ListApprovedRelatedOrganizationsForAccountParams) ([]ListApprovedRelatedOrganizationsForAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listApprovedRelatedOrganizationsForAccount, arg.AccountID, arg.SourceOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListApprovedRelatedOrganizationsForAccountRow{}
	for rows.Next() {
		var i ListApprovedRelatedOrganizationsForAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceOrganizationID,
			&i.TargetOrganizationID,
			&i.RelationshipType,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ResolvedBy,
			&i.TargetOrgPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationFirewallRules = `-- name: ListOrganizationFirewallRules :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, rule_type, cidr, name, status, created_at, updated_at, created_by, updated_by
FROM organization_firewall_rules
WHERE organization_id = ?
ORDER BY created_at DESC
`

type ListOrganizationFirewallRulesRow struct {
	ID             int64                               `json:"id"`
	PublicID       string                              `json:"public_id"`
	OrganizationID sql.NullInt64                       `json:"organization_id"`
	RuleType       OrganizationFirewallRulesRuleType   `json:"rule_type"`
	Cidr           string                              `json:"cidr"`
	Name           string                              `json:"name"`
	Status         NullOrganizationFirewallRulesStatus `json:"status"`
	CreatedAt      sql.NullTime                        `json:"created_at"`
	UpdatedAt      sql.NullTime                        `json:"updated_at"`
	CreatedBy      sql.NullInt64                       `json:"created_by"`
	UpdatedBy      sql.NullInt64                       `json:"updated_by"`
}

func (q *Queries) ListOrganizationFirewallRules(ctx context.Context, organizationID sql.NullInt64) ([]ListOrganizationFirewallRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationFirewallRules, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationFirewallRulesRow{}
	for rows.Next() {
		var i ListOrganizationFirewallRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.RuleType,
			&i.Cidr,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationMembers = `-- name: ListOrganizationMembers :many
SELECT cm.id, BIN_TO_UUID(cm.public_id) AS public_id, cm.organization_id, cm.account_id, cm.` + "`" + `role` + "`" + `, cm.status, cm.created_at, cm.updated_at,
       BIN_TO_UUID(a.public_id) AS account_public_id, a.email, a.` + "`" + `name` + "`" + `, a.github_username, a.verified, a.auth_method
FROM organization_members cm
JOIN accounts a ON cm.account_id = a.id
WHERE cm.organization_id = ?
ORDER BY cm.created_at DESC
LIMIT ? OFFSET ?
`

type ListOrganizationMembersParams struct {
	OrganizationID int64 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

type ListOrganizationMembersRow struct {
	ID              int64                         `json:"id"`
	PublicID        string                        `json:"public_id"`
	OrganizationID  int64                         `json:"organization_id"`
	AccountID       int64                         `json:"account_id"`
	Role            OrganizationMembersRole       `json:"role"`
	Status          NullOrganizationMembersStatus `json:"status"`
	CreatedAt       sql.NullTime                  `json:"created_at"`
	UpdatedAt       sql.NullTime                  `json:"updated_at"`
	AccountPublicID string                        `json:"account_public_id"`
	Email           string                        `json:"email"`
	Name            sql.NullString                `json:"name"`
	GithubUsername  sql.NullString                `json:"github_username"`
	Verified        bool                          `json:"verified"`
	AuthMethod      AccountsAuthMethod            `json:"auth_method"`
}

func (q *Queries) ListOrganizationMembers(ctx context.Context, arg ListOrganizationMembersParams) ([]ListOrganizationMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationMembers, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationMembersRow{}
	for rows.Next() {
		var i ListOrganizationMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.AccountID,
			&i.Role,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountPublicID,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
			&i.Verified,
			&i.AuthMethod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationProjects = `-- name: ListOrganizationProjects :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, github_repository, github_repository_template, github_branch, compose_path, gcp_region, gcp_zone, machine_type, disk_size_gb, compose_file, application_type, promote_strategy, monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path, gcp_project_id, gcp_project_number, github_team_id, organization_project, create_branch_sites, up_cmd, init_cmd, rollout_cmd, status, created_at, updated_at, created_by, updated_by
FROM projects
WHERE organization_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListOrganizationProjectsParams struct {
	OrganizationID int64 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

type ListOrganizationProjectsRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GithubRepository          sql.NullString              `json:"github_repository"`
	GithubRepositoryTemplate  sql.NullString              `json:"github_repository_template"`
	GithubBranch              sql.NullString              `json:"github_branch"`
	ComposePath               sql.NullString              `json:"compose_path"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	ComposeFile               sql.NullString              `json:"compose_file"`
	ApplicationType           sql.NullString              `json:"application_type"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	GithubTeamID              sql.NullString              `json:"github_team_id"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	UpCmd                     sql.NullString              `json:"up_cmd"`
	InitCmd                   sql.NullString              `json:"init_cmd"`
	RolloutCmd                json.RawMessage             `json:"rollout_cmd"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListOrganizationProjects(ctx context.Context, arg ListOrganizationProjectsParams) ([]ListOrganizationProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationProjects, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationProjectsRow{}
	for rows.Next() {
		var i ListOrganizationProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.Name,
			&i.GithubRepository,
			&i.GithubRepositoryTemplate,
			&i.GithubBranch,
			&i.ComposePath,
			&i.GcpRegion,
			&i.GcpZone,
			&i.MachineType,
			&i.DiskSizeGb,
			&i.ComposeFile,
			&i.ApplicationType,
			&i.PromoteStrategy,
			&i.MonitoringEnabled,
			&i.MonitoringLogLevel,
			&i.MonitoringMetricsEnabled,
			&i.MonitoringHealthCheckPath,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.GithubTeamID,
			&i.OrganizationProject,
			&i.CreateBranchSites,
			&i.UpCmd,
			&i.InitCmd,
			&i.RolloutCmd,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationRelationships = `-- name: ListOrganizationRelationships :many
SELECT r.id, BIN_TO_UUID(r.public_id) AS public_id, r.source_organization_id, r.target_organization_id,
       r.relationship_type, r.` + "`" + `status` + "`" + `, r.created_at, r.resolved_at, r.resolved_by
FROM relationships r
WHERE r.source_organization_id = ? OR r.target_organization_id = ?
ORDER BY r.created_at DESC
`

type ListOrganizationRelationshipsParams struct {
	SourceOrganizationID int64 `json:"source_organization_id"`
	TargetOrganizationID int64 `json:"target_organization_id"`
}

type ListOrganizationRelationshipsRow struct {
	ID                   int64                         `json:"id"`
	PublicID             string                        `json:"public_id"`
	SourceOrganizationID int64                         `json:"source_organization_id"`
	TargetOrganizationID int64                         `json:"target_organization_id"`
	RelationshipType     RelationshipsRelationshipType `json:"relationship_type"`
	Status               RelationshipsStatus           `json:"status"`
	CreatedAt            sql.NullTime                  `json:"created_at"`
	ResolvedAt           sql.NullTime                  `json:"resolved_at"`
	ResolvedBy           sql.NullInt64                 `json:"resolved_by"`
}

func (q *Queries) ListOrganizationRelationships(ctx context.Context, arg ListOrganizationRelationshipsParams) ([]ListOrganizationRelationshipsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationRelationships, arg.SourceOrganizationID, arg.TargetOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationRelationshipsRow{}
	for rows.Next() {
		var i ListOrganizationRelationshipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceOrganizationID,
			&i.TargetOrganizationID,
			&i.RelationshipType,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ResolvedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationSecrets = `-- name: ListOrganizationSecrets :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM organization_secrets
WHERE organization_id = ? AND status != 'deleted'
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListOrganizationSecretsParams struct {
	OrganizationID int64 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

type ListOrganizationSecretsRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

func (q *Queries) ListOrganizationSecrets(ctx context.Context, arg ListOrganizationSecretsParams) ([]ListOrganizationSecretsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationSecrets, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationSecretsRow{}
	for rows.Next() {
		var i ListOrganizationSecretsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.Name,
			&i.VaultPath,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizations = `-- name: ListOrganizations :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE account_id = ? AND status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT o.id, BIN_TO_UUID(o.public_id) AS public_id, o.name, o.gcp_org_id, o.gcp_billing_account, o.gcp_parent, o.location, o.region, o.gcp_folder_id, o.status, o.gcp_project_id, o.gcp_project_number, o.created_at, o.updated_at, o.created_by, o.updated_by
FROM organizations o
INNER JOIN user_orgs uo ON o.id = uo.organization_id
ORDER BY o.created_at DESC
LIMIT ? OFFSET ?
`

type ListOrganizationsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListOrganizationsRow struct {
	ID                int64                     `json:"id"`
	PublicID          string                    `json:"public_id"`
	Name              string                    `json:"name"`
	GcpOrgID          string                    `json:"gcp_org_id"`
	GcpBillingAccount string                    `json:"gcp_billing_account"`
	GcpParent         string                    `json:"gcp_parent"`
	Location          NullOrganizationsLocation `json:"location"`
	Region            sql.NullString            `json:"region"`
	GcpFolderID       sql.NullString            `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus   `json:"status"`
	GcpProjectID      sql.NullString            `json:"gcp_project_id"`
	GcpProjectNumber  sql.NullString            `json:"gcp_project_number"`
	CreatedAt         sql.NullTime              `json:"created_at"`
	UpdatedAt         sql.NullTime              `json:"updated_at"`
	CreatedBy         sql.NullInt64             `json:"created_by"`
	UpdatedBy         sql.NullInt64             `json:"updated_by"`
}

func (q *Queries) ListOrganizations(ctx context.Context, arg ListOrganizationsParams) ([]ListOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizations, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationsRow{}
	for rows.Next() {
		var i ListOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.GcpOrgID,
			&i.GcpBillingAccount,
			&i.GcpParent,
			&i.Location,
			&i.Region,
			&i.GcpFolderID,
			&i.Status,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingApprovals = `-- name: ListPendingApprovals :many
SELECT r.id, BIN_TO_UUID(r.public_id) AS public_id, r.source_organization_id, r.target_organization_id,
       r.relationship_type, r.` + "`" + `status` + "`" + `, r.created_at, r.resolved_at, r.resolved_by
FROM relationships r
WHERE r.target_organization_id = ? AND r.` + "`" + `status` + "`" + ` = 'pending'
ORDER BY r.created_at DESC
`

type ListPendingApprovalsRow struct {
	ID                   int64                         `json:"id"`
	PublicID             string                        `json:"public_id"`
	SourceOrganizationID int64                         `json:"source_organization_id"`
	TargetOrganizationID int64                         `json:"target_organization_id"`
	RelationshipType     RelationshipsRelationshipType `json:"relationship_type"`
	Status               RelationshipsStatus           `json:"status"`
	CreatedAt            sql.NullTime                  `json:"created_at"`
	ResolvedAt           sql.NullTime                  `json:"resolved_at"`
	ResolvedBy           sql.NullInt64                 `json:"resolved_by"`
}

func (q *Queries) ListPendingApprovals(ctx context.Context, targetOrganizationID int64) ([]ListPendingApprovalsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPendingApprovals, targetOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingApprovalsRow{}
	for rows.Next() {
		var i ListPendingApprovalsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceOrganizationID,
			&i.TargetOrganizationID,
			&i.RelationshipType,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ResolvedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectFirewallRules = `-- name: ListProjectFirewallRules :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, rule_type, cidr, name, status, created_at, updated_at, created_by, updated_by
FROM project_firewall_rules
WHERE project_id = ?
ORDER BY created_at DESC
`

type ListProjectFirewallRulesRow struct {
	ID        int64                          `json:"id"`
	PublicID  string                         `json:"public_id"`
	ProjectID sql.NullInt64                  `json:"project_id"`
	RuleType  ProjectFirewallRulesRuleType   `json:"rule_type"`
	Cidr      string                         `json:"cidr"`
	Name      string                         `json:"name"`
	Status    NullProjectFirewallRulesStatus `json:"status"`
	CreatedAt sql.NullTime                   `json:"created_at"`
	UpdatedAt sql.NullTime                   `json:"updated_at"`
	CreatedBy sql.NullInt64                  `json:"created_by"`
	UpdatedBy sql.NullInt64                  `json:"updated_by"`
}

func (q *Queries) ListProjectFirewallRules(ctx context.Context, projectID sql.NullInt64) ([]ListProjectFirewallRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectFirewallRules, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectFirewallRulesRow{}
	for rows.Next() {
		var i ListProjectFirewallRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.RuleType,
			&i.Cidr,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectMembers = `-- name: ListProjectMembers :many
SELECT pm.id, BIN_TO_UUID(pm.public_id) AS public_id, pm.project_id, pm.account_id, pm.` + "`" + `role` + "`" + `, pm.status, pm.created_at, pm.updated_at,
       BIN_TO_UUID(a.public_id) AS account_public_id, a.email, a.` + "`" + `name` + "`" + `, a.github_username
FROM project_members pm
JOIN accounts a ON pm.account_id = a.id
WHERE pm.project_id = ?
ORDER BY pm.created_at DESC
LIMIT ? OFFSET ?
`

type ListProjectMembersParams struct {
	ProjectID int64 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListProjectMembersRow struct {
	ID              int64                    `json:"id"`
	PublicID        string                   `json:"public_id"`
	ProjectID       int64                    `json:"project_id"`
	AccountID       int64                    `json:"account_id"`
	Role            ProjectMembersRole       `json:"role"`
	Status          NullProjectMembersStatus `json:"status"`
	CreatedAt       sql.NullTime             `json:"created_at"`
	UpdatedAt       sql.NullTime             `json:"updated_at"`
	AccountPublicID string                   `json:"account_public_id"`
	Email           string                   `json:"email"`
	Name            sql.NullString           `json:"name"`
	GithubUsername  sql.NullString           `json:"github_username"`
}

func (q *Queries) ListProjectMembers(ctx context.Context, arg ListProjectMembersParams) ([]ListProjectMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectMembers, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectMembersRow{}
	for rows.Next() {
		var i ListProjectMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.AccountID,
			&i.Role,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountPublicID,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectSecrets = `-- name: ListProjectSecrets :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM project_secrets
WHERE project_id = ? AND status != 'deleted'
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListProjectSecretsParams struct {
	ProjectID int64 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListProjectSecretsRow struct {
	ID        int64                    `json:"id"`
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

func (q *Queries) ListProjectSecrets(ctx context.Context, arg ListProjectSecretsParams) ([]ListProjectSecretsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectSecrets, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectSecretsRow{}
	for rows.Next() {
		var i ListProjectSecretsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.Name,
			&i.VaultPath,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectSites = `-- name: ListProjectSites :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, github_ref, gcp_external_ip, status, created_at, updated_at, created_by, updated_by
FROM sites
WHERE project_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListProjectSitesParams struct {
	ProjectID int64 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListProjectSitesRow struct {
	ID            int64           `json:"id"`
	PublicID      string          `json:"public_id"`
	ProjectID     int64           `json:"project_id"`
	Name          string          `json:"name"`
	GithubRef     string          `json:"github_ref"`
	GcpExternalIp sql.NullString  `json:"gcp_external_ip"`
	Status        NullSitesStatus `json:"status"`
	CreatedAt     sql.NullTime    `json:"created_at"`
	UpdatedAt     sql.NullTime    `json:"updated_at"`
	CreatedBy     sql.NullInt64   `json:"created_by"`
	UpdatedBy     sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) ListProjectSites(ctx context.Context, arg ListProjectSitesParams) ([]ListProjectSitesRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectSites, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectSitesRow{}
	for rows.Next() {
		var i ListProjectSitesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.Name,
			&i.GithubRef,
			&i.GcpExternalIp,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, github_repository, github_repository_template, github_branch, compose_path, gcp_region, gcp_zone, machine_type, disk_size_gb, compose_file, application_type, promote_strategy, monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path, gcp_project_id, gcp_project_number, github_team_id, organization_project, create_branch_sites, up_cmd, init_cmd, rollout_cmd, status, created_at, updated_at, created_by, updated_by
FROM projects
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListProjectsRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GithubRepository          sql.NullString              `json:"github_repository"`
	GithubRepositoryTemplate  sql.NullString              `json:"github_repository_template"`
	GithubBranch              sql.NullString              `json:"github_branch"`
	ComposePath               sql.NullString              `json:"compose_path"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	ComposeFile               sql.NullString              `json:"compose_file"`
	ApplicationType           sql.NullString              `json:"application_type"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	GithubTeamID              sql.NullString              `json:"github_team_id"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	UpCmd                     sql.NullString              `json:"up_cmd"`
	InitCmd                   sql.NullString              `json:"init_cmd"`
	RolloutCmd                json.RawMessage             `json:"rollout_cmd"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListProjects(ctx context.Context, arg ListProjectsParams) ([]ListProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectsRow{}
	for rows.Next() {
		var i ListProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.Name,
			&i.GithubRepository,
			&i.GithubRepositoryTemplate,
			&i.GithubBranch,
			&i.ComposePath,
			&i.GcpRegion,
			&i.GcpZone,
			&i.MachineType,
			&i.DiskSizeGb,
			&i.ComposeFile,
			&i.ApplicationType,
			&i.PromoteStrategy,
			&i.MonitoringEnabled,
			&i.MonitoringLogLevel,
			&i.MonitoringMetricsEnabled,
			&i.MonitoringHealthCheckPath,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.GithubTeamID,
			&i.OrganizationProject,
			&i.CreateBranchSites,
			&i.UpCmd,
			&i.InitCmd,
			&i.RolloutCmd,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteDeployments = `-- name: ListSiteDeployments :many
SELECT deployment_id, site_id, status, github_run_id, github_run_url, started_at, completed_at, error_message, created_at FROM deployments
WHERE site_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListSiteDeploymentsParams struct {
	SiteID string `json:"site_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListSiteDeployments(ctx context.Context, arg ListSiteDeploymentsParams) ([]Deployment, error) {
	rows, err := q.db.QueryContext(ctx, listSiteDeployments, arg.SiteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.DeploymentID,
			&i.SiteID,
			&i.Status,
			&i.GithubRunID,
			&i.GithubRunUrl,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteDomains = `-- name: ListSiteDomains :many
SELECT id, site_id, domain, created_at FROM domains
WHERE site_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListSiteDomainsParams struct {
	SiteID int64 `json:"site_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSiteDomains(ctx context.Context, arg ListSiteDomainsParams) ([]Domain, error) {
	rows, err := q.db.QueryContext(ctx, listSiteDomains, arg.SiteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Domain{}
	for rows.Next() {
		var i Domain
		if err := rows.Scan(
			&i.ID,
			&i.SiteID,
			&i.Domain,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteFirewallRules = `-- name: ListSiteFirewallRules :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, rule_type, cidr, name, status, created_at, updated_at, created_by, updated_by
FROM site_firewall_rules
WHERE site_id = ?
ORDER BY created_at DESC
`

type ListSiteFirewallRulesRow struct {
	ID        int64                       `json:"id"`
	PublicID  string                      `json:"public_id"`
	SiteID    sql.NullInt64               `json:"site_id"`
	RuleType  SiteFirewallRulesRuleType   `json:"rule_type"`
	Cidr      string                      `json:"cidr"`
	Name      string                      `json:"name"`
	Status    NullSiteFirewallRulesStatus `json:"status"`
	CreatedAt sql.NullTime                `json:"created_at"`
	UpdatedAt sql.NullTime                `json:"updated_at"`
	CreatedBy sql.NullInt64               `json:"created_by"`
	UpdatedBy sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListSiteFirewallRules(ctx context.Context, siteID sql.NullInt64) ([]ListSiteFirewallRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, listSiteFirewallRules, siteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSiteFirewallRulesRow{}
	for rows.Next() {
		var i ListSiteFirewallRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SiteID,
			&i.RuleType,
			&i.Cidr,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteMembers = `-- name: ListSiteMembers :many
SELECT sm.id, BIN_TO_UUID(sm.public_id) AS public_id, sm.site_id, sm.account_id, sm.` + "`" + `role` + "`" + `, sm.status, sm.created_at, sm.updated_at,
       BIN_TO_UUID(a.public_id) AS account_public_id, a.email, a.` + "`" + `name` + "`" + `, a.github_username
FROM site_members sm
JOIN accounts a ON sm.account_id = a.id
WHERE sm.site_id = ?
ORDER BY sm.created_at DESC
LIMIT ? OFFSET ?
`

type ListSiteMembersParams struct {
	SiteID int64 `json:"site_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSiteMembersRow struct {
	ID              int64                 `json:"id"`
	PublicID        string                `json:"public_id"`
	SiteID          int64                 `json:"site_id"`
	AccountID       int64                 `json:"account_id"`
	Role            SiteMembersRole       `json:"role"`
	Status          NullSiteMembersStatus `json:"status"`
	CreatedAt       sql.NullTime          `json:"created_at"`
	UpdatedAt       sql.NullTime          `json:"updated_at"`
	AccountPublicID string                `json:"account_public_id"`
	Email           string                `json:"email"`
	Name            sql.NullString        `json:"name"`
	GithubUsername  sql.NullString        `json:"github_username"`
}

func (q *Queries) ListSiteMembers(ctx context.Context, arg ListSiteMembersParams) ([]ListSiteMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listSiteMembers, arg.SiteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSiteMembersRow{}
	for rows.Next() {
		var i ListSiteMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SiteID,
			&i.AccountID,
			&i.Role,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountPublicID,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteSecrets = `-- name: ListSiteSecrets :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM site_secrets
WHERE site_id = ? AND status != 'deleted'
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListSiteSecretsParams struct {
	SiteID int64 `json:"site_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSiteSecretsRow struct {
	ID        int64                 `json:"id"`
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

func (q *Queries) ListSiteSecrets(ctx context.Context, arg ListSiteSecretsParams) ([]ListSiteSecretsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSiteSecrets, arg.SiteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSiteSecretsRow{}
	for rows.Next() {
		var i ListSiteSecretsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SiteID,
			&i.Name,
			&i.VaultPath,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteSshAccess = `-- name: ListSiteSshAccess :many
SELECT sa.id, sa.account_id, sa.site_id, sa.created_at, sa.updated_at,
       a.email, a.` + "`" + `name` + "`" + `, a.github_username
FROM ssh_access sa
JOIN accounts a ON sa.account_id = a.id
WHERE sa.site_id = ?
ORDER BY sa.created_at DESC
LIMIT ? OFFSET ?
`

type ListSiteSshAccessParams struct {
	SiteID int64 `json:"site_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSiteSshAccessRow struct {
	ID             int64          `json:"id"`
	AccountID      int64          `json:"account_id"`
	SiteID         int64          `json:"site_id"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	Email          string         `json:"email"`
	Name           sql.NullString `json:"name"`
	GithubUsername sql.NullString `json:"github_username"`
}

func (q *Queries) ListSiteSshAccess(ctx context.Context, arg ListSiteSshAccessParams) ([]ListSiteSshAccessRow, error) {
	rows, err := q.db.QueryContext(ctx, listSiteSshAccess, arg.SiteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSiteSshAccessRow{}
	for rows.Next() {
		var i ListSiteSshAccessRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SiteID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSites = `-- name: ListSites :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, github_ref, gcp_external_ip, status, created_at, updated_at, created_by, updated_by
FROM sites
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListSitesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSitesRow struct {
	ID            int64           `json:"id"`
	PublicID      string          `json:"public_id"`
	ProjectID     int64           `json:"project_id"`
	Name          string          `json:"name"`
	GithubRef     string          `json:"github_ref"`
	GcpExternalIp sql.NullString  `json:"gcp_external_ip"`
	Status        NullSitesStatus `json:"status"`
	CreatedAt     sql.NullTime    `json:"created_at"`
	UpdatedAt     sql.NullTime    `json:"updated_at"`
	CreatedBy     sql.NullInt64   `json:"created_by"`
	UpdatedBy     sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) ListSites(ctx context.Context, arg ListSitesParams) ([]ListSitesRow, error) {
	rows, err := q.db.QueryContext(ctx, listSites, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSitesRow{}
	for rows.Next() {
		var i ListSitesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.Name,
			&i.GithubRef,
			&i.GcpExternalIp,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSshKeysByAccount = `-- name: ListSshKeysByAccount :many
SELECT sk.id, BIN_TO_UUID(sk.public_id) AS public_id,
       BIN_TO_UUID(a.public_id) AS account_public_id,
       sk.public_key, sk.` + "`" + `name` + "`" + `, sk.fingerprint,
       sk.created_at, sk.updated_at
FROM ssh_keys sk
JOIN accounts a ON sk.account_id = a.id
WHERE a.public_id = UUID_TO_BIN(?)
ORDER BY sk.created_at DESC
`

type ListSshKeysByAccountRow struct {
	ID              int64          `json:"id"`
	PublicID        string         `json:"public_id"`
	AccountPublicID string         `json:"account_public_id"`
	PublicKey       string         `json:"public_key"`
	Name            sql.NullString `json:"name"`
	Fingerprint     sql.NullString `json:"fingerprint"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
}

func (q *Queries) ListSshKeysByAccount(ctx context.Context, publicID string) ([]ListSshKeysByAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listSshKeysByAccount, publicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSshKeysByAccountRow{}
	for rows.Next() {
		var i ListSshKeysByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.AccountPublicID,
			&i.PublicKey,
			&i.Name,
			&i.Fingerprint,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSshKeysByProject = `-- name: ListSshKeysByProject :many
SELECT DISTINCT sk.public_key
FROM ssh_keys sk
JOIN accounts a ON sk.account_id = a.id
JOIN (
    SELECT DISTINCT pm.account_id
    FROM project_members pm
    WHERE pm.project_id = (SELECT id FROM projects WHERE public_id = UUID_TO_BIN(?))
      AND pm.status = 'active'
      AND pm.role IN ('owner', 'developer')
    UNION
    SELECT DISTINCT om.account_id
    FROM organization_members om
    JOIN projects p ON om.organization_id = p.organization_id
    WHERE p.public_id = UUID_TO_BIN(?)
      AND om.status = 'active'
      AND om.role IN ('owner', 'developer')
    UNION
    -- Include members from related organizations with approved relationships
    SELECT DISTINCT om_related.account_id
    FROM organization_members om_related
    JOIN relationships r ON om_related.organization_id = r.target_organization_id
    JOIN projects p ON r.source_organization_id = p.organization_id
    WHERE p.public_id = UUID_TO_BIN(?)
      AND r.status = 'approved'
      AND om_related.status = 'active'
      AND om_related.role IN ('owner', 'developer')
) AS authorized_accounts ON a.id = authorized_accounts.account_id
ORDER BY sk.created_at DESC
`

type ListSshKeysByProjectParams struct {
	ProjectPublicID string `json:"project_public_id"`
}

func (q *Queries) ListSshKeysByProject(ctx context.Context, arg ListSshKeysByProjectParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listSshKeysByProject, arg.ProjectPublicID, arg.ProjectPublicID, arg.ProjectPublicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var public_key string
		if err := rows.Scan(&public_key); err != nil {
			return nil, err
		}
		items = append(items, public_key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSshKeysBySite = `-- name: ListSshKeysBySite :many
SELECT DISTINCT sk.public_key
FROM ssh_keys sk
JOIN accounts a ON sk.account_id = a.id
JOIN (
    SELECT DISTINCT sm.account_id
    FROM site_members sm
    WHERE sm.site_id = (SELECT id FROM sites WHERE public_id = UUID_TO_BIN(?))
      AND sm.status = 'active'
      AND sm.role IN ('owner', 'developer')
    UNION
    SELECT DISTINCT pm.account_id
    FROM project_members pm
    JOIN sites s ON pm.project_id = s.project_id
    WHERE s.public_id = UUID_TO_BIN(?)
      AND pm.status = 'active'
      AND pm.role IN ('owner', 'developer')
    UNION
    SELECT DISTINCT om.account_id
    FROM organization_members om
    JOIN projects p ON om.organization_id = p.organization_id
    JOIN sites s ON s.project_id = p.id
    WHERE s.public_id = UUID_TO_BIN(?)
      AND om.status = 'active'
      AND om.role IN ('owner', 'developer')
    UNION
    -- Include members from related organizations with approved relationships
    SELECT DISTINCT om_related.account_id
    FROM organization_members om_related
    JOIN relationships r ON om_related.organization_id = r.target_organization_id
    JOIN projects p ON r.source_organization_id = p.organization_id
    JOIN sites s ON s.project_id = p.id
    WHERE s.public_id = UUID_TO_BIN(?)
      AND r.status = 'approved'
      AND om_related.status = 'active'
      AND om_related.role IN ('owner', 'developer')
) AS authorized_accounts ON a.id = authorized_accounts.account_id
ORDER BY sk.created_at DESC
`

type ListSshKeysBySiteParams struct {
	SitePublicID string `json:"site_public_id"`
}

func (q *Queries) ListSshKeysBySite(ctx context.Context, arg ListSshKeysBySiteParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listSshKeysBySite,
		arg.SitePublicID,
		arg.SitePublicID,
		arg.SitePublicID,
		arg.SitePublicID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var public_key string
		if err := rows.Scan(&public_key); err != nil {
			return nil, err
		}
		items = append(items, public_key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserFirewallRules = `-- name: ListUserFirewallRules :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT id, public_id, name, status, created_at, updated_at, rule_type, cidr, parent_type, parent_name, parent_public_id FROM (
    SELECT
        ofr.id, BIN_TO_UUID(ofr.public_id) AS public_id, ofr.name, ofr.status, ofr.created_at, ofr.updated_at, ofr.rule_type, ofr.cidr,
        'organization' AS parent_type,
        o.name AS parent_name,
        BIN_TO_UUID(o.public_id) AS parent_public_id
    FROM organization_firewall_rules ofr
    JOIN organizations o ON ofr.organization_id = o.id
    JOIN user_orgs uo ON o.id = uo.organization_id
    WHERE ofr.status != 'deleted'

    UNION ALL

    SELECT
        pfr.id, BIN_TO_UUID(pfr.public_id) AS public_id, pfr.name, pfr.status, pfr.created_at, pfr.updated_at, pfr.rule_type, pfr.cidr,
        'project' AS parent_type,
        p.name AS parent_name,
        BIN_TO_UUID(p.public_id) AS parent_public_id
    FROM project_firewall_rules pfr
    JOIN projects p ON pfr.project_id = p.id
    LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE pfr.status != 'deleted'
    AND (pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)

    UNION ALL

    SELECT
        sfr.id, BIN_TO_UUID(sfr.public_id) AS public_id, sfr.name, sfr.status, sfr.created_at, sfr.updated_at, sfr.rule_type, sfr.cidr,
        'site' AS parent_type,
        s.name AS parent_name,
        BIN_TO_UUID(s.public_id) AS parent_public_id
    FROM site_firewall_rules sfr
    JOIN sites s ON sfr.site_id = s.id
    JOIN projects p ON s.project_id = p.id
    LEFT JOIN site_members sm ON s.id = sm.site_id AND sm.account_id = ? AND sm.status = 'active'
    LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE sfr.status != 'deleted'
    AND (sm.id IS NOT NULL OR pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
) AS all_rules
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListUserFirewallRulesParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListUserFirewallRulesRow struct {
	ID             int64                               `json:"id"`
	PublicID       string                              `json:"public_id"`
	Name           string                              `json:"name"`
	Status         NullOrganizationFirewallRulesStatus `json:"status"`
	CreatedAt      sql.NullTime                        `json:"created_at"`
	UpdatedAt      sql.NullTime                        `json:"updated_at"`
	RuleType       OrganizationFirewallRulesRuleType   `json:"rule_type"`
	Cidr           string                              `json:"cidr"`
	ParentType     string                              `json:"parent_type"`
	ParentName     string                              `json:"parent_name"`
	ParentPublicID string                              `json:"parent_public_id"`
}

func (q *Queries) ListUserFirewallRules(ctx context.Context, arg ListUserFirewallRulesParams) ([]ListUserFirewallRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserFirewallRules,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserFirewallRulesRow{}
	for rows.Next() {
		var i ListUserFirewallRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RuleType,
			&i.Cidr,
			&i.ParentType,
			&i.ParentName,
			&i.ParentPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserMemberships = `-- name: ListUserMemberships :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT id, public_id, status, created_at, updated_at, role, email, user_name, account_public_id, parent_type, parent_name, parent_public_id FROM (
    SELECT
        om.id, BIN_TO_UUID(om.public_id) AS public_id, om.status, om.created_at, om.updated_at, om.role,
        a.email, a.name AS user_name, BIN_TO_UUID(a.public_id) AS account_public_id,
        'organization' AS parent_type,
        o.name AS parent_name,
        BIN_TO_UUID(o.public_id) AS parent_public_id
    FROM organization_members om
    JOIN organizations o ON om.organization_id = o.id
    JOIN accounts a ON om.account_id = a.id
    JOIN user_orgs uo ON o.id = uo.organization_id
    WHERE om.status != 'deleted'

    UNION ALL

    SELECT
        pm.id, BIN_TO_UUID(pm.public_id) AS public_id, pm.status, pm.created_at, pm.updated_at, pm.role,
        a.email, a.name AS user_name, BIN_TO_UUID(a.public_id) AS account_public_id,
        'project' AS parent_type,
        p.name AS parent_name,
        BIN_TO_UUID(p.public_id) AS parent_public_id
    FROM project_members pm
    JOIN projects p ON pm.project_id = p.id
    JOIN accounts a ON pm.account_id = a.id
    LEFT JOIN project_members pm_auth ON p.id = pm_auth.project_id AND pm_auth.account_id = ? AND pm_auth.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE pm.status != 'deleted'
    AND (pm_auth.id IS NOT NULL OR uo.organization_id IS NOT NULL)

    UNION ALL

    SELECT
        sm.id, BIN_TO_UUID(sm.public_id) AS public_id, sm.status, sm.created_at, sm.updated_at, sm.role,
        a.email, a.name AS user_name, BIN_TO_UUID(a.public_id) AS account_public_id,
        'site' AS parent_type,
        s.name AS parent_name,
        BIN_TO_UUID(s.public_id) AS parent_public_id
    FROM site_members sm
    JOIN sites s ON sm.site_id = s.id
    JOIN projects p ON s.project_id = p.id
    JOIN accounts a ON sm.account_id = a.id
    LEFT JOIN site_members sm_auth ON s.id = sm_auth.site_id AND sm_auth.account_id = ? AND sm_auth.status = 'active'
    LEFT JOIN project_members pm_auth ON p.id = pm_auth.project_id AND pm_auth.account_id = ? AND pm_auth.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE sm.status != 'deleted'
    AND (sm_auth.id IS NOT NULL OR pm_auth.id IS NOT NULL OR uo.organization_id IS NOT NULL)
) AS all_members
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListUserMembershipsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListUserMembershipsRow struct {
	ID              int64                         `json:"id"`
	PublicID        string                        `json:"public_id"`
	Status          NullOrganizationMembersStatus `json:"status"`
	CreatedAt       sql.NullTime                  `json:"created_at"`
	UpdatedAt       sql.NullTime                  `json:"updated_at"`
	Role            OrganizationMembersRole       `json:"role"`
	Email           string                        `json:"email"`
	UserName        sql.NullString                `json:"user_name"`
	AccountPublicID string                        `json:"account_public_id"`
	ParentType      string                        `json:"parent_type"`
	ParentName      string                        `json:"parent_name"`
	ParentPublicID  string                        `json:"parent_public_id"`
}

func (q *Queries) ListUserMemberships(ctx context.Context, arg ListUserMembershipsParams) ([]ListUserMembershipsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserMemberships,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserMembershipsRow{}
	for rows.Next() {
		var i ListUserMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
			&i.Email,
			&i.UserName,
			&i.AccountPublicID,
			&i.ParentType,
			&i.ParentName,
			&i.ParentPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrganizations = `-- name: ListUserOrganizations :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT o.id, BIN_TO_UUID(o.public_id) AS public_id, o.name,
       COALESCE(om.role, 'read') AS role
FROM organizations o
JOIN user_orgs uo ON o.id = uo.organization_id
LEFT JOIN organization_members om ON o.id = om.organization_id AND om.account_id = ?
ORDER BY o.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserOrganizationsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListUserOrganizationsRow struct {
	ID       int64                   `json:"id"`
	PublicID string                  `json:"public_id"`
	Name     string                  `json:"name"`
	Role     OrganizationMembersRole `json:"role"`
}

func (q *Queries) ListUserOrganizations(ctx context.Context, arg ListUserOrganizationsParams) ([]ListUserOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserOrganizations,
		arg.AccountID,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserOrganizationsRow{}
	for rows.Next() {
		var i ListUserOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProjects = `-- name: ListUserProjects :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT p.id, BIN_TO_UUID(p.public_id) AS public_id, p.organization_id, BIN_TO_UUID(o.public_id) AS organization_public_id, p.name, p.github_repository, p.github_repository_template, p.github_branch, p.compose_path, p.gcp_region, p.gcp_zone, p.machine_type, p.disk_size_gb, p.compose_file, p.application_type, p.promote_strategy, p.monitoring_enabled, p.monitoring_log_level, p.monitoring_metrics_enabled, p.monitoring_health_check_path, p.gcp_project_id, p.gcp_project_number, p.github_team_id, p.organization_project, p.create_branch_sites, p.up_cmd, p.init_cmd, p.rollout_cmd, p.status, p.created_at, p.updated_at, p.created_by, p.updated_by
FROM projects p
JOIN organizations o ON p.organization_id = o.id
LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
WHERE (pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
AND (p.organization_id = ? OR ? IS NULL)
ORDER BY p.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserProjectsParams struct {
	AccountID            int64         `json:"account_id"`
	FilterOrganizationID sql.NullInt64 `json:"filter_organization_id"`
	Limit                int32         `json:"limit"`
	Offset               int32         `json:"offset"`
}

type ListUserProjectsRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	OrganizationPublicID      string                      `json:"organization_public_id"`
	Name                      string                      `json:"name"`
	GithubRepository          sql.NullString              `json:"github_repository"`
	GithubRepositoryTemplate  sql.NullString              `json:"github_repository_template"`
	GithubBranch              sql.NullString              `json:"github_branch"`
	ComposePath               sql.NullString              `json:"compose_path"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	ComposeFile               sql.NullString              `json:"compose_file"`
	ApplicationType           sql.NullString              `json:"application_type"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	GithubTeamID              sql.NullString              `json:"github_team_id"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	UpCmd                     sql.NullString              `json:"up_cmd"`
	InitCmd                   sql.NullString              `json:"init_cmd"`
	RolloutCmd                json.RawMessage             `json:"rollout_cmd"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListUserProjects(ctx context.Context, arg ListUserProjectsParams) ([]ListUserProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserProjects,
		arg.AccountID,
		arg.AccountID,
		arg.FilterOrganizationID,
		arg.FilterOrganizationID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserProjectsRow{}
	for rows.Next() {
		var i ListUserProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.OrganizationPublicID,
			&i.Name,
			&i.GithubRepository,
			&i.GithubRepositoryTemplate,
			&i.GithubBranch,
			&i.ComposePath,
			&i.GcpRegion,
			&i.GcpZone,
			&i.MachineType,
			&i.DiskSizeGb,
			&i.ComposeFile,
			&i.ApplicationType,
			&i.PromoteStrategy,
			&i.MonitoringEnabled,
			&i.MonitoringLogLevel,
			&i.MonitoringMetricsEnabled,
			&i.MonitoringHealthCheckPath,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.GithubTeamID,
			&i.OrganizationProject,
			&i.CreateBranchSites,
			&i.UpCmd,
			&i.InitCmd,
			&i.RolloutCmd,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProjectsWithOrg = `-- name: ListUserProjectsWithOrg :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT p.id, BIN_TO_UUID(p.public_id) AS public_id, p.organization_id, BIN_TO_UUID(o.public_id) AS organization_public_id, o.name AS organization_name, p.name, p.github_repository, p.github_repository_template, p.github_branch, p.compose_path, p.gcp_region, p.gcp_zone, p.machine_type, p.disk_size_gb, p.compose_file, p.application_type, p.promote_strategy, p.monitoring_enabled, p.monitoring_log_level, p.monitoring_metrics_enabled, p.monitoring_health_check_path, p.gcp_project_id, p.gcp_project_number, p.github_team_id, p.organization_project, p.create_branch_sites, p.up_cmd, p.init_cmd, p.rollout_cmd, p.status, p.created_at, p.updated_at, p.created_by, p.updated_by
FROM projects p
JOIN organizations o ON p.organization_id = o.id
LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
WHERE (pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
AND (p.organization_id = ? OR ? IS NULL)
ORDER BY p.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserProjectsWithOrgParams struct {
	AccountID            int64         `json:"account_id"`
	FilterOrganizationID sql.NullInt64 `json:"filter_organization_id"`
	Limit                int32         `json:"limit"`
	Offset               int32         `json:"offset"`
}

type ListUserProjectsWithOrgRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	OrganizationPublicID      string                      `json:"organization_public_id"`
	OrganizationName          string                      `json:"organization_name"`
	Name                      string                      `json:"name"`
	GithubRepository          sql.NullString              `json:"github_repository"`
	GithubRepositoryTemplate  sql.NullString              `json:"github_repository_template"`
	GithubBranch              sql.NullString              `json:"github_branch"`
	ComposePath               sql.NullString              `json:"compose_path"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	ComposeFile               sql.NullString              `json:"compose_file"`
	ApplicationType           sql.NullString              `json:"application_type"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	GithubTeamID              sql.NullString              `json:"github_team_id"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	UpCmd                     sql.NullString              `json:"up_cmd"`
	InitCmd                   sql.NullString              `json:"init_cmd"`
	RolloutCmd                json.RawMessage             `json:"rollout_cmd"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListUserProjectsWithOrg(ctx context.Context, arg ListUserProjectsWithOrgParams) ([]ListUserProjectsWithOrgRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserProjectsWithOrg,
		arg.AccountID,
		arg.AccountID,
		arg.FilterOrganizationID,
		arg.FilterOrganizationID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserProjectsWithOrgRow{}
	for rows.Next() {
		var i ListUserProjectsWithOrgRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.OrganizationPublicID,
			&i.OrganizationName,
			&i.Name,
			&i.GithubRepository,
			&i.GithubRepositoryTemplate,
			&i.GithubBranch,
			&i.ComposePath,
			&i.GcpRegion,
			&i.GcpZone,
			&i.MachineType,
			&i.DiskSizeGb,
			&i.ComposeFile,
			&i.ApplicationType,
			&i.PromoteStrategy,
			&i.MonitoringEnabled,
			&i.MonitoringLogLevel,
			&i.MonitoringMetricsEnabled,
			&i.MonitoringHealthCheckPath,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.GithubTeamID,
			&i.OrganizationProject,
			&i.CreateBranchSites,
			&i.UpCmd,
			&i.InitCmd,
			&i.RolloutCmd,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSecrets = `-- name: ListUserSecrets :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT id, public_id, name, status, created_at, updated_at, parent_type, parent_name, parent_public_id FROM (
    SELECT
        os.id, BIN_TO_UUID(os.public_id) AS public_id, os.name, os.status, os.created_at, os.updated_at,
        'organization' AS parent_type,
        o.name AS parent_name,
        BIN_TO_UUID(o.public_id) AS parent_public_id
    FROM organization_secrets os
    JOIN organizations o ON os.organization_id = o.id
    JOIN user_orgs uo ON o.id = uo.organization_id
    WHERE os.status != 'deleted'

    UNION ALL

    SELECT
        ps.id, BIN_TO_UUID(ps.public_id) AS public_id, ps.name, ps.status, ps.created_at, ps.updated_at,
        'project' AS parent_type,
        p.name AS parent_name,
        BIN_TO_UUID(p.public_id) AS parent_public_id
    FROM project_secrets ps
    JOIN projects p ON ps.project_id = p.id
    LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE ps.status != 'deleted'
    AND (pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)

    UNION ALL

    SELECT
        ss.id, BIN_TO_UUID(ss.public_id) AS public_id, ss.name, ss.status, ss.created_at, ss.updated_at,
        'site' AS parent_type,
        s.name AS parent_name,
        BIN_TO_UUID(s.public_id) AS parent_public_id
    FROM site_secrets ss
    JOIN sites s ON ss.site_id = s.id
    JOIN projects p ON s.project_id = p.id
    LEFT JOIN site_members sm ON s.id = sm.site_id AND sm.account_id = ? AND sm.status = 'active'
    LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE ss.status != 'deleted'
    AND (sm.id IS NOT NULL OR pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
) AS all_secrets
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListUserSecretsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListUserSecretsRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	Name           string                        `json:"name"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	ParentType     string                        `json:"parent_type"`
	ParentName     string                        `json:"parent_name"`
	ParentPublicID string                        `json:"parent_public_id"`
}

func (q *Queries) ListUserSecrets(ctx context.Context, arg ListUserSecretsParams) ([]ListUserSecretsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserSecrets,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSecretsRow{}
	for rows.Next() {
		var i ListUserSecretsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParentType,
			&i.ParentName,
			&i.ParentPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSites = `-- name: ListUserSites :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT s.id, BIN_TO_UUID(s.public_id) AS public_id, s.project_id, BIN_TO_UUID(p.public_id) AS project_public_id, BIN_TO_UUID(o.public_id) AS organization_public_id, s.name, s.github_ref, s.gcp_external_ip, s.status, s.created_at, s.updated_at, s.created_by, s.updated_by
FROM sites s
JOIN projects p ON s.project_id = p.id
JOIN organizations o ON p.organization_id = o.id
LEFT JOIN site_members sm ON s.id = sm.site_id AND sm.account_id = ? AND sm.status = 'active'
LEFT JOIN project_members pm ON s.project_id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
WHERE (sm.id IS NOT NULL OR pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
AND (p.organization_id = ? OR ? IS NULL)
AND (s.project_id = ? OR ? IS NULL)
ORDER BY s.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserSitesParams struct {
	AccountID            int64         `json:"account_id"`
	FilterOrganizationID sql.NullInt64 `json:"filter_organization_id"`
	FilterProjectID      sql.NullInt64 `json:"filter_project_id"`
	Limit                int32         `json:"limit"`
	Offset               int32         `json:"offset"`
}

type ListUserSitesRow struct {
	ID                   int64           `json:"id"`
	PublicID             string          `json:"public_id"`
	ProjectID            int64           `json:"project_id"`
	ProjectPublicID      string          `json:"project_public_id"`
	OrganizationPublicID string          `json:"organization_public_id"`
	Name                 string          `json:"name"`
	GithubRef            string          `json:"github_ref"`
	GcpExternalIp        sql.NullString  `json:"gcp_external_ip"`
	Status               NullSitesStatus `json:"status"`
	CreatedAt            sql.NullTime    `json:"created_at"`
	UpdatedAt            sql.NullTime    `json:"updated_at"`
	CreatedBy            sql.NullInt64   `json:"created_by"`
	UpdatedBy            sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) ListUserSites(ctx context.Context, arg ListUserSitesParams) ([]ListUserSitesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserSites,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.FilterOrganizationID,
		arg.FilterOrganizationID,
		arg.FilterProjectID,
		arg.FilterProjectID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSitesRow{}
	for rows.Next() {
		var i ListUserSitesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.ProjectPublicID,
			&i.OrganizationPublicID,
			&i.Name,
			&i.GithubRef,
			&i.GcpExternalIp,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSitesWithProject = `-- name: ListUserSitesWithProject :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT s.id, BIN_TO_UUID(s.public_id) AS public_id, s.project_id, BIN_TO_UUID(p.public_id) AS project_public_id, p.name AS project_name, BIN_TO_UUID(o.public_id) AS organization_public_id, s.name, s.github_ref, s.gcp_external_ip, s.status, s.created_at, s.updated_at, s.created_by, s.updated_by
FROM sites s
JOIN projects p ON s.project_id = p.id
JOIN organizations o ON p.organization_id = o.id
LEFT JOIN site_members sm ON s.id = sm.site_id AND sm.account_id = ? AND sm.status = 'active'
LEFT JOIN project_members pm ON s.project_id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
WHERE (sm.id IS NOT NULL OR pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
AND (p.organization_id = ? OR ? IS NULL)
AND (s.project_id = ? OR ? IS NULL)
ORDER BY s.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserSitesWithProjectParams struct {
	AccountID            int64         `json:"account_id"`
	FilterOrganizationID sql.NullInt64 `json:"filter_organization_id"`
	FilterProjectID      sql.NullInt64 `json:"filter_project_id"`
	Limit                int32         `json:"limit"`
	Offset               int32         `json:"offset"`
}

type ListUserSitesWithProjectRow struct {
	ID                   int64           `json:"id"`
	PublicID             string          `json:"public_id"`
	ProjectID            int64           `json:"project_id"`
	ProjectPublicID      string          `json:"project_public_id"`
	ProjectName          string          `json:"project_name"`
	OrganizationPublicID string          `json:"organization_public_id"`
	Name                 string          `json:"name"`
	GithubRef            string          `json:"github_ref"`
	GcpExternalIp        sql.NullString  `json:"gcp_external_ip"`
	Status               NullSitesStatus `json:"status"`
	CreatedAt            sql.NullTime    `json:"created_at"`
	UpdatedAt            sql.NullTime    `json:"updated_at"`
	CreatedBy            sql.NullInt64   `json:"created_by"`
	UpdatedBy            sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) ListUserSitesWithProject(ctx context.Context, arg ListUserSitesWithProjectParams) ([]ListUserSitesWithProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserSitesWithProject,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.FilterOrganizationID,
		arg.FilterOrganizationID,
		arg.FilterProjectID,
		arg.FilterProjectID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSitesWithProjectRow{}
	for rows.Next() {
		var i ListUserSitesWithProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.ProjectPublicID,
			&i.ProjectName,
			&i.OrganizationPublicID,
			&i.Name,
			&i.GithubRef,
			&i.GcpExternalIp,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEventDeadLetter = `-- name: MarkEventDeadLetter :exec
UPDATE event_queue
SET status = 'dead_letter',
    last_error = ?
WHERE id = ?
`

type MarkEventDeadLetterParams struct {
	LastError sql.NullString `json:"last_error"`
	ID        int64          `json:"id"`
}

func (q *Queries) MarkEventDeadLetter(ctx context.Context, arg MarkEventDeadLetterParams) error {
	_, err := q.db.ExecContext(ctx, markEventDeadLetter, arg.LastError, arg.ID)
	return err
}

const markEventFailed = `-- name: MarkEventFailed :exec
UPDATE event_queue
SET retry_count = retry_count + 1,
    last_retry_at = NOW(),
    last_error = ?,
    status = 'pending',
    processing_by = NULL,
    processing_at = NULL
WHERE id = ?
`

type MarkEventFailedParams struct {
	LastError sql.NullString `json:"last_error"`
	ID        int64          `json:"id"`
}

func (q *Queries) MarkEventFailed(ctx context.Context, arg MarkEventFailedParams) error {
	_, err := q.db.ExecContext(ctx, markEventFailed, arg.LastError, arg.ID)
	return err
}

const markEventSent = `-- name: MarkEventSent :exec
UPDATE event_queue
SET status = 'sent',
    sent_at = NOW()
WHERE id = ?
`

func (q *Queries) MarkEventSent(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markEventSent, id)
	return err
}

const recoverStaleProcessing = `-- name: RecoverStaleProcessing :exec
UPDATE event_queue
SET status = 'pending',
    processing_by = NULL,
    processing_at = NULL
WHERE status = 'processing'
  AND processing_at < DATE_SUB(NOW(), INTERVAL ? MINUTE)
`

func (q *Queries) RecoverStaleProcessing(ctx context.Context, dateSUB interface{}) error {
	_, err := q.db.ExecContext(ctx, recoverStaleProcessing, dateSUB)
	return err
}

const rejectRelationship = `-- name: RejectRelationship :execresult
UPDATE relationships SET
  ` + "`" + `status` + "`" + ` = 'rejected',
  resolved_at = CURRENT_TIMESTAMP,
  resolved_by = ?
WHERE public_id = UUID_TO_BIN(?) AND ` + "`" + `status` + "`" + ` = 'pending'
`

type RejectRelationshipParams struct {
	ResolvedBy sql.NullInt64 `json:"resolved_by"`
	PublicID   string        `json:"public_id"`
}

func (q *Queries) RejectRelationship(ctx context.Context, arg RejectRelationshipParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, rejectRelationship, arg.ResolvedBy, arg.PublicID)
}

const resetFailedLoginAttempts = `-- name: ResetFailedLoginAttempts :exec
UPDATE accounts SET
  failed_login_attempts = 0
WHERE id = ?
`

func (q *Queries) ResetFailedLoginAttempts(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, resetFailedLoginAttempts, id)
	return err
}

const updateAPIKeyActive = `-- name: UpdateAPIKeyActive :exec
UPDATE api_keys SET
  active = ?
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateAPIKeyActiveParams struct {
	Active   bool   `json:"active"`
	PublicID string `json:"public_id"`
}

func (q *Queries) UpdateAPIKeyActive(ctx context.Context, arg UpdateAPIKeyActiveParams) error {
	_, err := q.db.ExecContext(ctx, updateAPIKeyActive, arg.Active, arg.PublicID)
	return err
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys SET
  last_used_at = NOW()
WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, updateAPIKeyLastUsed, publicID)
	return err
}

const updateAccount = `-- name: UpdateAccount :exec
UPDATE accounts SET
  email = ?,
  ` + "`" + `name` + "`" + ` = ?,
  github_username = ?,
  vault_entity_id = ?,
  auth_method = ?,
  verified = ?,
  verified_at = ?,
  updated_at = NOW()
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateAccountParams struct {
	Email          string             `json:"email"`
	Name           sql.NullString     `json:"name"`
	GithubUsername sql.NullString     `json:"github_username"`
	VaultEntityID  sql.NullString     `json:"vault_entity_id"`
	AuthMethod     AccountsAuthMethod `json:"auth_method"`
	Verified       bool               `json:"verified"`
	VerifiedAt     sql.NullTime       `json:"verified_at"`
	PublicID       string             `json:"public_id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) error {
	_, err := q.db.ExecContext(ctx, updateAccount,
		arg.Email,
		arg.Name,
		arg.GithubUsername,
		arg.VaultEntityID,
		arg.AuthMethod,
		arg.Verified,
		arg.VerifiedAt,
		arg.PublicID,
	)
	return err
}

const updateDeployment = `-- name: UpdateDeployment :exec
UPDATE deployments SET
  ` + "`" + `status` + "`" + ` = ?,
  github_run_id = ?,
  github_run_url = ?,
  completed_at = ?,
  error_message = ?
WHERE deployment_id = ?
`

type UpdateDeploymentParams struct {
	Status       DeploymentsStatus `json:"status"`
	GithubRunID  sql.NullString    `json:"github_run_id"`
	GithubRunUrl sql.NullString    `json:"github_run_url"`
	CompletedAt  sql.NullInt64     `json:"completed_at"`
	ErrorMessage sql.NullString    `json:"error_message"`
	DeploymentID string            `json:"deployment_id"`
}

func (q *Queries) UpdateDeployment(ctx context.Context, arg UpdateDeploymentParams) error {
	_, err := q.db.ExecContext(ctx, updateDeployment,
		arg.Status,
		arg.GithubRunID,
		arg.GithubRunUrl,
		arg.CompletedAt,
		arg.ErrorMessage,
		arg.DeploymentID,
	)
	return err
}

const updateOrganization = `-- name: UpdateOrganization :exec
UPDATE organizations SET
  ` + "`" + `name` + "`" + ` = ?,
  gcp_org_id = ?,
  gcp_billing_account = ?,
  gcp_parent = ?,
  gcp_folder_id = ?,
  ` + "`" + `status` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateOrganizationParams struct {
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
	PublicID          string                  `json:"public_id"`
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganization,
		arg.Name,
		arg.GcpOrgID,
		arg.GcpBillingAccount,
		arg.GcpParent,
		arg.GcpFolderID,
		arg.Status,
		arg.UpdatedBy,
		arg.PublicID,
	)
	return err
}

const updateOrganizationMember = `-- name: UpdateOrganizationMember :exec
UPDATE organization_members SET
  ` + "`" + `role` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE organization_id = ? AND account_id = ?
`

type UpdateOrganizationMemberParams struct {
	Role           OrganizationMembersRole `json:"role"`
	UpdatedBy      sql.NullInt64           `json:"updated_by"`
	OrganizationID int64                   `json:"organization_id"`
	AccountID      int64                   `json:"account_id"`
}

func (q *Queries) UpdateOrganizationMember(ctx context.Context, arg UpdateOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationMember,
		arg.Role,
		arg.UpdatedBy,
		arg.OrganizationID,
		arg.AccountID,
	)
	return err
}

const updateOrganizationSecret = `-- name: UpdateOrganizationSecret :exec
UPDATE organization_secrets
SET vault_path = ?, updated_by = ?, updated_at = ?
WHERE id = ?
`

type UpdateOrganizationSecretParams struct {
	VaultPath string        `json:"vault_path"`
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateOrganizationSecret(ctx context.Context, arg UpdateOrganizationSecretParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationSecret,
		arg.VaultPath,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateProject = `-- name: UpdateProject :exec
UPDATE projects SET
  ` + "`" + `name` + "`" + ` = ?,
  github_repository = ?,
  github_branch = ?,
  compose_path = ?,
  gcp_region = ?,
  gcp_zone = ?,
  machine_type = ?,
  disk_size_gb = ?,
  compose_file = ?,
  application_type = ?,
  monitoring_enabled = ?,
  monitoring_log_level = ?,
  monitoring_metrics_enabled = ?,
  monitoring_health_check_path = ?,
  gcp_project_id = ?,
  gcp_project_number = ?,
  github_team_id = ?,
  create_branch_sites = ?,
  ` + "`" + `status` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateProjectParams struct {
	Name                      string             `json:"name"`
	GithubRepository          sql.NullString     `json:"github_repository"`
	GithubBranch              sql.NullString     `json:"github_branch"`
	ComposePath               sql.NullString     `json:"compose_path"`
	GcpRegion                 sql.NullString     `json:"gcp_region"`
	GcpZone                   sql.NullString     `json:"gcp_zone"`
	MachineType               sql.NullString     `json:"machine_type"`
	DiskSizeGb                sql.NullInt32      `json:"disk_size_gb"`
	ComposeFile               sql.NullString     `json:"compose_file"`
	ApplicationType           sql.NullString     `json:"application_type"`
	MonitoringEnabled         sql.NullBool       `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString     `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool       `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString     `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString     `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString     `json:"gcp_project_number"`
	GithubTeamID              sql.NullString     `json:"github_team_id"`
	CreateBranchSites         sql.NullBool       `json:"create_branch_sites"`
	Status                    NullProjectsStatus `json:"status"`
	UpdatedBy                 sql.NullInt64      `json:"updated_by"`
	PublicID                  string             `json:"public_id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.ExecContext(ctx, updateProject,
		arg.Name,
		arg.GithubRepository,
		arg.GithubBranch,
		arg.ComposePath,
		arg.GcpRegion,
		arg.GcpZone,
		arg.MachineType,
		arg.DiskSizeGb,
		arg.ComposeFile,
		arg.ApplicationType,
		arg.MonitoringEnabled,
		arg.MonitoringLogLevel,
		arg.MonitoringMetricsEnabled,
		arg.MonitoringHealthCheckPath,
		arg.GcpProjectID,
		arg.GcpProjectNumber,
		arg.GithubTeamID,
		arg.CreateBranchSites,
		arg.Status,
		arg.UpdatedBy,
		arg.PublicID,
	)
	return err
}

const updateProjectMember = `-- name: UpdateProjectMember :exec
UPDATE project_members SET
  ` + "`" + `role` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE project_id = ? AND account_id = ?
`

type UpdateProjectMemberParams struct {
	Role      ProjectMembersRole `json:"role"`
	UpdatedBy sql.NullInt64      `json:"updated_by"`
	ProjectID int64              `json:"project_id"`
	AccountID int64              `json:"account_id"`
}

func (q *Queries) UpdateProjectMember(ctx context.Context, arg UpdateProjectMemberParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectMember,
		arg.Role,
		arg.UpdatedBy,
		arg.ProjectID,
		arg.AccountID,
	)
	return err
}

const updateProjectSecret = `-- name: UpdateProjectSecret :exec
UPDATE project_secrets
SET vault_path = ?, updated_by = ?, updated_at = ?
WHERE id = ?
`

type UpdateProjectSecretParams struct {
	VaultPath string        `json:"vault_path"`
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateProjectSecret(ctx context.Context, arg UpdateProjectSecretParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectSecret,
		arg.VaultPath,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateSite = `-- name: UpdateSite :exec
UPDATE sites SET
  ` + "`" + `name` + "`" + ` = ?,
  github_ref = ?,
  gcp_external_ip = ?,
  ` + "`" + `status` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateSiteParams struct {
	Name          string          `json:"name"`
	GithubRef     string          `json:"github_ref"`
	GcpExternalIp sql.NullString  `json:"gcp_external_ip"`
	Status        NullSitesStatus `json:"status"`
	UpdatedBy     sql.NullInt64   `json:"updated_by"`
	PublicID      string          `json:"public_id"`
}

func (q *Queries) UpdateSite(ctx context.Context, arg UpdateSiteParams) error {
	_, err := q.db.ExecContext(ctx, updateSite,
		arg.Name,
		arg.GithubRef,
		arg.GcpExternalIp,
		arg.Status,
		arg.UpdatedBy,
		arg.PublicID,
	)
	return err
}

const updateSiteMember = `-- name: UpdateSiteMember :exec
UPDATE site_members SET
  ` + "`" + `role` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE site_id = ? AND account_id = ?
`

type UpdateSiteMemberParams struct {
	Role      SiteMembersRole `json:"role"`
	UpdatedBy sql.NullInt64   `json:"updated_by"`
	SiteID    int64           `json:"site_id"`
	AccountID int64           `json:"account_id"`
}

func (q *Queries) UpdateSiteMember(ctx context.Context, arg UpdateSiteMemberParams) error {
	_, err := q.db.ExecContext(ctx, updateSiteMember,
		arg.Role,
		arg.UpdatedBy,
		arg.SiteID,
		arg.AccountID,
	)
	return err
}

const updateSiteSecret = `-- name: UpdateSiteSecret :exec
UPDATE site_secrets
SET vault_path = ?, updated_by = ?, updated_at = ?
WHERE id = ?
`

type UpdateSiteSecretParams struct {
	VaultPath string        `json:"vault_path"`
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateSiteSecret(ctx context.Context, arg UpdateSiteSecretParams) error {
	_, err := q.db.ExecContext(ctx, updateSiteSecret,
		arg.VaultPath,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateSshKey = `-- name: UpdateSshKey :execresult
UPDATE ssh_keys SET
  ` + "`" + `name` + "`" + ` = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateSshKeyParams struct {
	Name     sql.NullString `json:"name"`
	PublicID string         `json:"public_id"`
}

func (q *Queries) UpdateSshKey(ctx context.Context, arg UpdateSshKeyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateSshKey, arg.Name, arg.PublicID)
}
