// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sites.sql

package db

import (
	"context"
	"database/sql"

	"github.com/libops/api/db/types"
)

const countSiteSecrets = `-- name: CountSiteSecrets :one
SELECT COUNT(*) FROM site_secrets
WHERE site_id = ? AND status != 'deleted'
`

func (q *Queries) CountSiteSecrets(ctx context.Context, siteID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSiteSecrets, siteID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDomain = `-- name: CreateDomain :exec
INSERT INTO domains (
  site_id, domain, created_at
) VALUES (?, ?, NOW())
`

type CreateDomainParams struct {
	SiteID int64  `json:"site_id"`
	Domain string `json:"domain"`
}

func (q *Queries) CreateDomain(ctx context.Context, arg CreateDomainParams) error {
	_, err := q.db.ExecContext(ctx, createDomain, arg.SiteID, arg.Domain)
	return err
}

const createSite = `-- name: CreateSite :exec
INSERT INTO sites (
  public_id, project_id, ` + "`" + `name` + "`" + `, github_repository, github_ref, github_team_id, compose_path, compose_file, port, application_type, up_cmd, init_cmd, rollout_cmd, overlay_volumes, os, is_production, gcp_external_ip, ` + "`" + `status` + "`" + `, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateSiteParams struct {
	ProjectID        int64           `json:"project_id"`
	Name             string          `json:"name"`
	GithubRepository string          `json:"github_repository"`
	GithubRef        string          `json:"github_ref"`
	GithubTeamID     sql.NullString  `json:"github_team_id"`
	ComposePath      sql.NullString  `json:"compose_path"`
	ComposeFile      sql.NullString  `json:"compose_file"`
	Port             sql.NullInt32   `json:"port"`
	ApplicationType  sql.NullString  `json:"application_type"`
	UpCmd            types.RawJSON   `json:"up_cmd"`
	InitCmd          types.RawJSON   `json:"init_cmd"`
	RolloutCmd       types.RawJSON   `json:"rollout_cmd"`
	OverlayVolumes   types.RawJSON   `json:"overlay_volumes"`
	Os               sql.NullString  `json:"os"`
	IsProduction     sql.NullBool    `json:"is_production"`
	GcpExternalIp    sql.NullString  `json:"gcp_external_ip"`
	Status           NullSitesStatus `json:"status"`
	CreatedBy        sql.NullInt64   `json:"created_by"`
	UpdatedBy        sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) CreateSite(ctx context.Context, arg CreateSiteParams) error {
	_, err := q.db.ExecContext(ctx, createSite,
		arg.ProjectID,
		arg.Name,
		arg.GithubRepository,
		arg.GithubRef,
		arg.GithubTeamID,
		arg.ComposePath,
		arg.ComposeFile,
		arg.Port,
		arg.ApplicationType,
		arg.UpCmd,
		arg.InitCmd,
		arg.RolloutCmd,
		arg.OverlayVolumes,
		arg.Os,
		arg.IsProduction,
		arg.GcpExternalIp,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createSiteFirewallRule = `-- name: CreateSiteFirewallRule :exec
INSERT INTO site_firewall_rules (
  public_id, site_id, name, rule_type, cidr, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?)
`

type CreateSiteFirewallRuleParams struct {
	SiteID    sql.NullInt64             `json:"site_id"`
	Name      string                    `json:"name"`
	RuleType  SiteFirewallRulesRuleType `json:"rule_type"`
	Cidr      string                    `json:"cidr"`
	CreatedBy sql.NullInt64             `json:"created_by"`
	UpdatedBy sql.NullInt64             `json:"updated_by"`
}

func (q *Queries) CreateSiteFirewallRule(ctx context.Context, arg CreateSiteFirewallRuleParams) error {
	_, err := q.db.ExecContext(ctx, createSiteFirewallRule,
		arg.SiteID,
		arg.Name,
		arg.RuleType,
		arg.Cidr,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createSiteSecret = `-- name: CreateSiteSecret :execresult


INSERT INTO site_secrets (
    public_id, site_id, name, vault_path, status, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSiteSecretParams struct {
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

// =============================================================================
// RELATIONSHIPS
// =============================================================================
func (q *Queries) CreateSiteSecret(ctx context.Context, arg CreateSiteSecretParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createSiteSecret,
		arg.PublicID,
		arg.SiteID,
		arg.Name,
		arg.VaultPath,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
}

const deleteDomain = `-- name: DeleteDomain :exec
DELETE FROM domains WHERE id = ?
`

func (q *Queries) DeleteDomain(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDomain, id)
	return err
}

const deleteSite = `-- name: DeleteSite :exec
DELETE FROM sites WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteSite(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteSite, publicID)
	return err
}

const deleteSiteFirewallRule = `-- name: DeleteSiteFirewallRule :exec
DELETE FROM site_firewall_rules WHERE id = ?
`

func (q *Queries) DeleteSiteFirewallRule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSiteFirewallRule, id)
	return err
}

const deleteSiteFirewallRuleByPublicID = `-- name: DeleteSiteFirewallRuleByPublicID :exec
UPDATE site_firewall_rules SET status = 'deleted', updated_at = CURRENT_TIMESTAMP WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteSiteFirewallRuleByPublicID(ctx context.Context, uuidTOBIN string) error {
	_, err := q.db.ExecContext(ctx, deleteSiteFirewallRuleByPublicID, uuidTOBIN)
	return err
}

const deleteSiteSecret = `-- name: DeleteSiteSecret :exec
UPDATE site_secrets
SET status = 'deleted', updated_by = ?, updated_at = ?
WHERE id = ?
`

type DeleteSiteSecretParams struct {
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) DeleteSiteSecret(ctx context.Context, arg DeleteSiteSecretParams) error {
	_, err := q.db.ExecContext(ctx, deleteSiteSecret, arg.UpdatedBy, arg.UpdatedAt, arg.ID)
	return err
}

const getDomain = `-- name: GetDomain :one


SELECT id, site_id, domain, created_at
FROM domains WHERE id = ?
`

// =============================================================================
// SITE MEMBERS
// =============================================================================
func (q *Queries) GetDomain(ctx context.Context, id int64) (Domain, error) {
	row := q.db.QueryRowContext(ctx, getDomain, id)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.Domain,
		&i.CreatedAt,
	)
	return i, err
}

const getDomainByName = `-- name: GetDomainByName :one
SELECT id, site_id, domain, created_at
FROM domains WHERE domain = ?
`

func (q *Queries) GetDomainByName(ctx context.Context, domain string) (Domain, error) {
	row := q.db.QueryRowContext(ctx, getDomainByName, domain)
	var i Domain
	err := row.Scan(
		&i.ID,
		&i.SiteID,
		&i.Domain,
		&i.CreatedAt,
	)
	return i, err
}

const getSite = `-- name: GetSite :one


SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, ` + "`" + `name` + "`" + `, github_repository, github_ref, github_team_id, compose_path, compose_file, port, application_type, up_cmd, init_cmd, rollout_cmd, overlay_volumes, os, is_production, gcp_external_ip, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM sites WHERE public_id = UUID_TO_BIN(?)
`

type GetSiteRow struct {
	ID               int64           `json:"id"`
	PublicID         string          `json:"public_id"`
	ProjectID        int64           `json:"project_id"`
	Name             string          `json:"name"`
	GithubRepository string          `json:"github_repository"`
	GithubRef        string          `json:"github_ref"`
	GithubTeamID     sql.NullString  `json:"github_team_id"`
	ComposePath      sql.NullString  `json:"compose_path"`
	ComposeFile      sql.NullString  `json:"compose_file"`
	Port             sql.NullInt32   `json:"port"`
	ApplicationType  sql.NullString  `json:"application_type"`
	UpCmd            types.RawJSON   `json:"up_cmd"`
	InitCmd          types.RawJSON   `json:"init_cmd"`
	RolloutCmd       types.RawJSON   `json:"rollout_cmd"`
	OverlayVolumes   types.RawJSON   `json:"overlay_volumes"`
	Os               sql.NullString  `json:"os"`
	IsProduction     sql.NullBool    `json:"is_production"`
	GcpExternalIp    sql.NullString  `json:"gcp_external_ip"`
	Status           NullSitesStatus `json:"status"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	CreatedBy        sql.NullInt64   `json:"created_by"`
	UpdatedBy        sql.NullInt64   `json:"updated_by"`
}

// =============================================================================
// PROJECT MEMBERS
// =============================================================================
func (q *Queries) GetSite(ctx context.Context, publicID string) (GetSiteRow, error) {
	row := q.db.QueryRowContext(ctx, getSite, publicID)
	var i GetSiteRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.GithubRepository,
		&i.GithubRef,
		&i.GithubTeamID,
		&i.ComposePath,
		&i.ComposeFile,
		&i.Port,
		&i.ApplicationType,
		&i.UpCmd,
		&i.InitCmd,
		&i.RolloutCmd,
		&i.OverlayVolumes,
		&i.Os,
		&i.IsProduction,
		&i.GcpExternalIp,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteByID = `-- name: GetSiteByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, ` + "`" + `name` + "`" + `, github_repository, github_ref, github_team_id, compose_path, compose_file, port, application_type, up_cmd, init_cmd, rollout_cmd, overlay_volumes, os, is_production, gcp_external_ip, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM sites WHERE id = ?
`

type GetSiteByIDRow struct {
	ID               int64           `json:"id"`
	PublicID         string          `json:"public_id"`
	ProjectID        int64           `json:"project_id"`
	Name             string          `json:"name"`
	GithubRepository string          `json:"github_repository"`
	GithubRef        string          `json:"github_ref"`
	GithubTeamID     sql.NullString  `json:"github_team_id"`
	ComposePath      sql.NullString  `json:"compose_path"`
	ComposeFile      sql.NullString  `json:"compose_file"`
	Port             sql.NullInt32   `json:"port"`
	ApplicationType  sql.NullString  `json:"application_type"`
	UpCmd            types.RawJSON   `json:"up_cmd"`
	InitCmd          types.RawJSON   `json:"init_cmd"`
	RolloutCmd       types.RawJSON   `json:"rollout_cmd"`
	OverlayVolumes   types.RawJSON   `json:"overlay_volumes"`
	Os               sql.NullString  `json:"os"`
	IsProduction     sql.NullBool    `json:"is_production"`
	GcpExternalIp    sql.NullString  `json:"gcp_external_ip"`
	Status           NullSitesStatus `json:"status"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	CreatedBy        sql.NullInt64   `json:"created_by"`
	UpdatedBy        sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) GetSiteByID(ctx context.Context, id int64) (GetSiteByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteByID, id)
	var i GetSiteByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.GithubRepository,
		&i.GithubRef,
		&i.GithubTeamID,
		&i.ComposePath,
		&i.ComposeFile,
		&i.Port,
		&i.ApplicationType,
		&i.UpCmd,
		&i.InitCmd,
		&i.RolloutCmd,
		&i.OverlayVolumes,
		&i.Os,
		&i.IsProduction,
		&i.GcpExternalIp,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteByShortUUID = `-- name: GetSiteByShortUUID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, ` + "`" + `name` + "`" + `, github_repository, github_ref, github_team_id, compose_path, compose_file, port, application_type, up_cmd, init_cmd, rollout_cmd, overlay_volumes, os, is_production, gcp_external_ip, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM sites WHERE HEX(public_id) LIKE CONCAT(UPPER(?), '%') LIMIT 1
`

type GetSiteByShortUUIDRow struct {
	ID               int64           `json:"id"`
	PublicID         string          `json:"public_id"`
	ProjectID        int64           `json:"project_id"`
	Name             string          `json:"name"`
	GithubRepository string          `json:"github_repository"`
	GithubRef        string          `json:"github_ref"`
	GithubTeamID     sql.NullString  `json:"github_team_id"`
	ComposePath      sql.NullString  `json:"compose_path"`
	ComposeFile      sql.NullString  `json:"compose_file"`
	Port             sql.NullInt32   `json:"port"`
	ApplicationType  sql.NullString  `json:"application_type"`
	UpCmd            types.RawJSON   `json:"up_cmd"`
	InitCmd          types.RawJSON   `json:"init_cmd"`
	RolloutCmd       types.RawJSON   `json:"rollout_cmd"`
	OverlayVolumes   types.RawJSON   `json:"overlay_volumes"`
	Os               sql.NullString  `json:"os"`
	IsProduction     sql.NullBool    `json:"is_production"`
	GcpExternalIp    sql.NullString  `json:"gcp_external_ip"`
	Status           NullSitesStatus `json:"status"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	CreatedBy        sql.NullInt64   `json:"created_by"`
	UpdatedBy        sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) GetSiteByShortUUID(ctx context.Context, shortUuid string) (GetSiteByShortUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteByShortUUID, shortUuid)
	var i GetSiteByShortUUIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.GithubRepository,
		&i.GithubRef,
		&i.GithubTeamID,
		&i.ComposePath,
		&i.ComposeFile,
		&i.Port,
		&i.ApplicationType,
		&i.UpCmd,
		&i.InitCmd,
		&i.RolloutCmd,
		&i.OverlayVolumes,
		&i.Os,
		&i.IsProduction,
		&i.GcpExternalIp,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteFirewallForVM = `-- name: GetSiteFirewallForVM :many
SELECT DISTINCT sf.rule_type, sf.cidr, sf.name
FROM site_firewall_rules sf
WHERE sf.site_id = ? AND sf.status = 'active'
UNION
SELECT DISTINCT pf.rule_type, pf.cidr, pf.name
FROM project_firewall_rules pf
JOIN sites s ON s.project_id = pf.project_id
WHERE s.id = ? AND pf.status = 'active'
UNION
SELECT DISTINCT orgf.rule_type, orgf.cidr, orgf.name
FROM organization_firewall_rules orgf
JOIN projects p ON p.organization_id = orgf.organization_id
JOIN sites st ON st.project_id = p.id
WHERE st.id = ? AND orgf.status = 'active'
`

type GetSiteFirewallForVMParams struct {
	SiteID sql.NullInt64 `json:"site_id"`
	ID     int64         `json:"id"`
	ID_2   int64         `json:"id_2"`
}

type GetSiteFirewallForVMRow struct {
	RuleType SiteFirewallRulesRuleType `json:"rule_type"`
	Cidr     string                    `json:"cidr"`
	Name     string                    `json:"name"`
}

// Fetches all firewall rules that should be applied to a site VM
// Includes rules from site, project, and org levels
func (q *Queries) GetSiteFirewallForVM(ctx context.Context, arg GetSiteFirewallForVMParams) ([]GetSiteFirewallForVMRow, error) {
	rows, err := q.db.QueryContext(ctx, getSiteFirewallForVM, arg.SiteID, arg.ID, arg.ID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSiteFirewallForVMRow{}
	for rows.Next() {
		var i GetSiteFirewallForVMRow
		if err := rows.Scan(&i.RuleType, &i.Cidr, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiteFirewallRuleByPublicID = `-- name: GetSiteFirewallRuleByPublicID :one


SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, rule_type, cidr, name, status, created_at, updated_at, created_by, updated_by
FROM site_firewall_rules WHERE public_id = UUID_TO_BIN(?)
`

type GetSiteFirewallRuleByPublicIDRow struct {
	ID        int64                       `json:"id"`
	PublicID  string                      `json:"public_id"`
	SiteID    sql.NullInt64               `json:"site_id"`
	RuleType  SiteFirewallRulesRuleType   `json:"rule_type"`
	Cidr      string                      `json:"cidr"`
	Name      string                      `json:"name"`
	Status    NullSiteFirewallRulesStatus `json:"status"`
	CreatedAt sql.NullTime                `json:"created_at"`
	UpdatedAt sql.NullTime                `json:"updated_at"`
	CreatedBy sql.NullInt64               `json:"created_by"`
	UpdatedBy sql.NullInt64               `json:"updated_by"`
}

// =============================================================================
// ORGANIZATION FIREWALL RULES
// =============================================================================
func (q *Queries) GetSiteFirewallRuleByPublicID(ctx context.Context, uuidTOBIN string) (GetSiteFirewallRuleByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteFirewallRuleByPublicID, uuidTOBIN)
	var i GetSiteFirewallRuleByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.RuleType,
		&i.Cidr,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteSSHKeysForVM = `-- name: GetSiteSSHKeysForVM :many


SELECT DISTINCT sk.public_key, sk.name, sk.fingerprint, a.email, a.name as user_name, a.github_username, BIN_TO_UUID(a.public_id) AS account_public_id
FROM ssh_keys sk
JOIN accounts a ON sk.account_id = a.id
WHERE sk.account_id IN (
    -- Site members (owner/developer with active status)
    SELECT account_id FROM site_members
    WHERE site_id = ? AND role IN ('owner', 'developer') AND status = 'active'

    UNION

    -- Project members (owner/developer with active status)
    SELECT pm.account_id FROM project_members pm
    JOIN sites s ON s.project_id = pm.project_id
    WHERE s.id = ? AND pm.role IN ('owner', 'developer') AND pm.status = 'active'

    UNION

    -- Org members (owner/developer with active status)
    SELECT om.account_id FROM organization_members om
    JOIN projects p ON p.organization_id = om.organization_id
    JOIN sites s ON s.project_id = p.id
    WHERE s.id = ? AND om.role IN ('owner', 'developer') AND om.status = 'active'

    UNION

    -- Members via org relationships (approved relationships)
    SELECT om.account_id FROM organization_members om
    JOIN relationships r ON r.source_organization_id = om.organization_id
    JOIN projects p ON p.organization_id = r.target_organization_id
    JOIN sites s ON s.project_id = p.id
    WHERE s.id = ? AND r.status = 'approved'
      AND om.role IN ('owner', 'developer') AND om.status = 'active'
)
`

type GetSiteSSHKeysForVMParams struct {
	SiteID int64 `json:"site_id"`
	ID     int64 `json:"id"`
	ID_2   int64 `json:"id_2"`
	ID_3   int64 `json:"id_3"`
}

type GetSiteSSHKeysForVMRow struct {
	PublicKey       string         `json:"public_key"`
	Name            sql.NullString `json:"name"`
	Fingerprint     sql.NullString `json:"fingerprint"`
	Email           string         `json:"email"`
	UserName        sql.NullString `json:"user_name"`
	GithubUsername  sql.NullString `json:"github_username"`
	AccountPublicID string         `json:"account_public_id"`
}

// =============================================================================
// MEMBERSHIP QUERIES FOR AUTHORIZATION
// =============================================================================
// Fetches all SSH keys that should be provisioned to a site VM
// Includes keys from site members, project members, org members, and relationship members
func (q *Queries) GetSiteSSHKeysForVM(ctx context.Context, arg GetSiteSSHKeysForVMParams) ([]GetSiteSSHKeysForVMRow, error) {
	rows, err := q.db.QueryContext(ctx, getSiteSSHKeysForVM,
		arg.SiteID,
		arg.ID,
		arg.ID_2,
		arg.ID_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSiteSSHKeysForVMRow{}
	for rows.Next() {
		var i GetSiteSSHKeysForVMRow
		if err := rows.Scan(
			&i.PublicKey,
			&i.Name,
			&i.Fingerprint,
			&i.Email,
			&i.UserName,
			&i.GithubUsername,
			&i.AccountPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiteSecretByID = `-- name: GetSiteSecretByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM site_secrets WHERE id = ? AND status != 'deleted'
`

type GetSiteSecretByIDRow struct {
	ID        int64                 `json:"id"`
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

func (q *Queries) GetSiteSecretByID(ctx context.Context, id int64) (GetSiteSecretByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteSecretByID, id)
	var i GetSiteSecretByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteSecretByName = `-- name: GetSiteSecretByName :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM site_secrets
WHERE site_id = ? AND name = ? AND status != 'deleted'
`

type GetSiteSecretByNameParams struct {
	SiteID int64  `json:"site_id"`
	Name   string `json:"name"`
}

type GetSiteSecretByNameRow struct {
	ID        int64                 `json:"id"`
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

func (q *Queries) GetSiteSecretByName(ctx context.Context, arg GetSiteSecretByNameParams) (GetSiteSecretByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteSecretByName, arg.SiteID, arg.Name)
	var i GetSiteSecretByNameRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteSecretByPublicID = `-- name: GetSiteSecretByPublicID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM site_secrets WHERE public_id = UUID_TO_BIN(?) AND status != 'deleted'
`

type GetSiteSecretByPublicIDRow struct {
	ID        int64                 `json:"id"`
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

func (q *Queries) GetSiteSecretByPublicID(ctx context.Context, publicID string) (GetSiteSecretByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteSecretByPublicID, publicID)
	var i GetSiteSecretByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteSecretsForVM = `-- name: GetSiteSecretsForVM :many
SELECT DISTINCT ss.name as ` + "`" + `key` + "`" + `, ss.vault_path as value
FROM site_secrets ss
WHERE ss.site_id = ?
UNION
SELECT DISTINCT ps.name as ` + "`" + `key` + "`" + `, ps.vault_path as value
FROM project_secrets ps
JOIN sites s ON s.project_id = ps.project_id
WHERE s.id = ?
UNION
SELECT DISTINCT os.name as ` + "`" + `key` + "`" + `, os.vault_path as value
FROM organization_secrets os
JOIN projects p ON p.organization_id = os.organization_id
JOIN sites st ON st.project_id = p.id
WHERE st.id = ?
`

type GetSiteSecretsForVMParams struct {
	SiteID int64 `json:"site_id"`
	ID     int64 `json:"id"`
	ID_2   int64 `json:"id_2"`
}

type GetSiteSecretsForVMRow struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// Fetches all secrets that should be provisioned to a site VM
// Includes secrets from site, project, and org levels
func (q *Queries) GetSiteSecretsForVM(ctx context.Context, arg GetSiteSecretsForVMParams) ([]GetSiteSecretsForVMRow, error) {
	rows, err := q.db.QueryContext(ctx, getSiteSecretsForVM, arg.SiteID, arg.ID, arg.ID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSiteSecretsForVMRow{}
	for rows.Next() {
		var i GetSiteSecretsForVMRow
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteDomains = `-- name: ListSiteDomains :many
SELECT id, site_id, domain, created_at FROM domains
WHERE site_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListSiteDomainsParams struct {
	SiteID int64 `json:"site_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSiteDomains(ctx context.Context, arg ListSiteDomainsParams) ([]Domain, error) {
	rows, err := q.db.QueryContext(ctx, listSiteDomains, arg.SiteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Domain{}
	for rows.Next() {
		var i Domain
		if err := rows.Scan(
			&i.ID,
			&i.SiteID,
			&i.Domain,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteFirewallRules = `-- name: ListSiteFirewallRules :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, rule_type, cidr, name, status, created_at, updated_at, created_by, updated_by
FROM site_firewall_rules
WHERE site_id = ? AND status != 'deleted'
ORDER BY created_at DESC
`

type ListSiteFirewallRulesRow struct {
	ID        int64                       `json:"id"`
	PublicID  string                      `json:"public_id"`
	SiteID    sql.NullInt64               `json:"site_id"`
	RuleType  SiteFirewallRulesRuleType   `json:"rule_type"`
	Cidr      string                      `json:"cidr"`
	Name      string                      `json:"name"`
	Status    NullSiteFirewallRulesStatus `json:"status"`
	CreatedAt sql.NullTime                `json:"created_at"`
	UpdatedAt sql.NullTime                `json:"updated_at"`
	CreatedBy sql.NullInt64               `json:"created_by"`
	UpdatedBy sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListSiteFirewallRules(ctx context.Context, siteID sql.NullInt64) ([]ListSiteFirewallRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, listSiteFirewallRules, siteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSiteFirewallRulesRow{}
	for rows.Next() {
		var i ListSiteFirewallRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SiteID,
			&i.RuleType,
			&i.Cidr,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteSecrets = `-- name: ListSiteSecrets :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM site_secrets
WHERE site_id = ? AND status != 'deleted'
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListSiteSecretsParams struct {
	SiteID int64 `json:"site_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSiteSecretsRow struct {
	ID        int64                 `json:"id"`
	PublicID  string                `json:"public_id"`
	SiteID    int64                 `json:"site_id"`
	Name      string                `json:"name"`
	VaultPath string                `json:"vault_path"`
	Status    NullSiteSecretsStatus `json:"status"`
	CreatedAt int64                 `json:"created_at"`
	UpdatedAt int64                 `json:"updated_at"`
	CreatedBy sql.NullInt64         `json:"created_by"`
	UpdatedBy sql.NullInt64         `json:"updated_by"`
}

func (q *Queries) ListSiteSecrets(ctx context.Context, arg ListSiteSecretsParams) ([]ListSiteSecretsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSiteSecrets, arg.SiteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSiteSecretsRow{}
	for rows.Next() {
		var i ListSiteSecretsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SiteID,
			&i.Name,
			&i.VaultPath,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteSshAccess = `-- name: ListSiteSshAccess :many


SELECT sa.id, sa.account_id, sa.site_id, sa.created_at, sa.updated_at,
       a.email, a.` + "`" + `name` + "`" + `, a.github_username
FROM ssh_access sa
JOIN accounts a ON sa.account_id = a.id
WHERE sa.site_id = ?
ORDER BY sa.created_at DESC
LIMIT ? OFFSET ?
`

type ListSiteSshAccessParams struct {
	SiteID int64 `json:"site_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSiteSshAccessRow struct {
	ID             int64          `json:"id"`
	AccountID      int64          `json:"account_id"`
	SiteID         int64          `json:"site_id"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	Email          string         `json:"email"`
	Name           sql.NullString `json:"name"`
	GithubUsername sql.NullString `json:"github_username"`
}

// =============================================================================
// Ssh ACCESS
// =============================================================================
func (q *Queries) ListSiteSshAccess(ctx context.Context, arg ListSiteSshAccessParams) ([]ListSiteSshAccessRow, error) {
	rows, err := q.db.QueryContext(ctx, listSiteSshAccess, arg.SiteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSiteSshAccessRow{}
	for rows.Next() {
		var i ListSiteSshAccessRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SiteID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSites = `-- name: ListSites :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, github_repository, github_ref, github_team_id, compose_path, compose_file, port, application_type, up_cmd, init_cmd, rollout_cmd, gcp_external_ip, status, created_at, updated_at, created_by, updated_by
FROM sites
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListSitesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSitesRow struct {
	ID               int64           `json:"id"`
	PublicID         string          `json:"public_id"`
	ProjectID        int64           `json:"project_id"`
	Name             string          `json:"name"`
	GithubRepository string          `json:"github_repository"`
	GithubRef        string          `json:"github_ref"`
	GithubTeamID     sql.NullString  `json:"github_team_id"`
	ComposePath      sql.NullString  `json:"compose_path"`
	ComposeFile      sql.NullString  `json:"compose_file"`
	Port             sql.NullInt32   `json:"port"`
	ApplicationType  sql.NullString  `json:"application_type"`
	UpCmd            types.RawJSON   `json:"up_cmd"`
	InitCmd          types.RawJSON   `json:"init_cmd"`
	RolloutCmd       types.RawJSON   `json:"rollout_cmd"`
	GcpExternalIp    sql.NullString  `json:"gcp_external_ip"`
	Status           NullSitesStatus `json:"status"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	CreatedBy        sql.NullInt64   `json:"created_by"`
	UpdatedBy        sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) ListSites(ctx context.Context, arg ListSitesParams) ([]ListSitesRow, error) {
	rows, err := q.db.QueryContext(ctx, listSites, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSitesRow{}
	for rows.Next() {
		var i ListSitesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.Name,
			&i.GithubRepository,
			&i.GithubRef,
			&i.GithubTeamID,
			&i.ComposePath,
			&i.ComposeFile,
			&i.Port,
			&i.ApplicationType,
			&i.UpCmd,
			&i.InitCmd,
			&i.RolloutCmd,
			&i.GcpExternalIp,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSshKeysBySite = `-- name: ListSshKeysBySite :many
SELECT DISTINCT sk.public_key
FROM ssh_keys sk
JOIN accounts a ON sk.account_id = a.id
JOIN (
    SELECT DISTINCT sm.account_id
    FROM site_members sm
    WHERE sm.site_id = (SELECT id FROM sites WHERE public_id = UUID_TO_BIN(?))
      AND sm.status = 'active'
      AND sm.role IN ('owner', 'developer')
    UNION
    SELECT DISTINCT pm.account_id
    FROM project_members pm
    JOIN sites s ON pm.project_id = s.project_id
    WHERE s.public_id = UUID_TO_BIN(?)
      AND pm.status = 'active'
      AND pm.role IN ('owner', 'developer')
    UNION
    SELECT DISTINCT om.account_id
    FROM organization_members om
    JOIN projects p ON om.organization_id = p.organization_id
    JOIN sites s ON s.project_id = p.id
    WHERE s.public_id = UUID_TO_BIN(?)
      AND om.status = 'active'
      AND om.role IN ('owner', 'developer')
    UNION
    -- Include members from related organizations with approved relationships
    SELECT DISTINCT om_related.account_id
    FROM organization_members om_related
    JOIN relationships r ON om_related.organization_id = r.target_organization_id
    JOIN projects p ON r.source_organization_id = p.organization_id
    JOIN sites s ON s.project_id = p.id
    WHERE s.public_id = UUID_TO_BIN(?)
      AND r.status = 'approved'
      AND om_related.status = 'active'
      AND om_related.role IN ('owner', 'developer')
) AS authorized_accounts ON a.id = authorized_accounts.account_id
ORDER BY sk.created_at DESC
`

type ListSshKeysBySiteParams struct {
	SitePublicID string `json:"site_public_id"`
}

func (q *Queries) ListSshKeysBySite(ctx context.Context, arg ListSshKeysBySiteParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listSshKeysBySite,
		arg.SitePublicID,
		arg.SitePublicID,
		arg.SitePublicID,
		arg.SitePublicID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var public_key string
		if err := rows.Scan(&public_key); err != nil {
			return nil, err
		}
		items = append(items, public_key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSites = `-- name: ListUserSites :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT s.id, BIN_TO_UUID(s.public_id) AS public_id, s.project_id, BIN_TO_UUID(p.public_id) AS project_public_id, BIN_TO_UUID(o.public_id) AS organization_public_id, s.name, s.github_repository, s.github_ref, s.github_team_id, s.compose_path, s.compose_file, s.port, s.application_type, s.up_cmd, s.init_cmd, s.rollout_cmd, s.overlay_volumes, s.os, s.is_production, s.gcp_external_ip, s.status, s.created_at, s.updated_at, s.created_by, s.updated_by
FROM sites s
JOIN projects p ON s.project_id = p.id
JOIN organizations o ON p.organization_id = o.id
LEFT JOIN site_members sm ON s.id = sm.site_id AND sm.account_id = ? AND sm.status = 'active'
LEFT JOIN project_members pm ON s.project_id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
WHERE (sm.id IS NOT NULL OR pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
AND (p.organization_id = ? OR ? IS NULL)
AND (s.project_id = ? OR ? IS NULL)
ORDER BY s.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserSitesParams struct {
	AccountID            int64         `json:"account_id"`
	FilterOrganizationID sql.NullInt64 `json:"filter_organization_id"`
	FilterProjectID      sql.NullInt64 `json:"filter_project_id"`
	Limit                int32         `json:"limit"`
	Offset               int32         `json:"offset"`
}

type ListUserSitesRow struct {
	ID                   int64           `json:"id"`
	PublicID             string          `json:"public_id"`
	ProjectID            int64           `json:"project_id"`
	ProjectPublicID      string          `json:"project_public_id"`
	OrganizationPublicID string          `json:"organization_public_id"`
	Name                 string          `json:"name"`
	GithubRepository     string          `json:"github_repository"`
	GithubRef            string          `json:"github_ref"`
	GithubTeamID         sql.NullString  `json:"github_team_id"`
	ComposePath          sql.NullString  `json:"compose_path"`
	ComposeFile          sql.NullString  `json:"compose_file"`
	Port                 sql.NullInt32   `json:"port"`
	ApplicationType      sql.NullString  `json:"application_type"`
	UpCmd                types.RawJSON   `json:"up_cmd"`
	InitCmd              types.RawJSON   `json:"init_cmd"`
	RolloutCmd           types.RawJSON   `json:"rollout_cmd"`
	OverlayVolumes       types.RawJSON   `json:"overlay_volumes"`
	Os                   sql.NullString  `json:"os"`
	IsProduction         sql.NullBool    `json:"is_production"`
	GcpExternalIp        sql.NullString  `json:"gcp_external_ip"`
	Status               NullSitesStatus `json:"status"`
	CreatedAt            sql.NullTime    `json:"created_at"`
	UpdatedAt            sql.NullTime    `json:"updated_at"`
	CreatedBy            sql.NullInt64   `json:"created_by"`
	UpdatedBy            sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) ListUserSites(ctx context.Context, arg ListUserSitesParams) ([]ListUserSitesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserSites,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.FilterOrganizationID,
		arg.FilterOrganizationID,
		arg.FilterProjectID,
		arg.FilterProjectID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSitesRow{}
	for rows.Next() {
		var i ListUserSitesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.ProjectPublicID,
			&i.OrganizationPublicID,
			&i.Name,
			&i.GithubRepository,
			&i.GithubRef,
			&i.GithubTeamID,
			&i.ComposePath,
			&i.ComposeFile,
			&i.Port,
			&i.ApplicationType,
			&i.UpCmd,
			&i.InitCmd,
			&i.RolloutCmd,
			&i.OverlayVolumes,
			&i.Os,
			&i.IsProduction,
			&i.GcpExternalIp,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSite = `-- name: UpdateSite :exec
UPDATE sites SET
  ` + "`" + `name` + "`" + ` = ?,
  github_repository = ?,
  github_ref = ?,
  github_team_id = ?,
  compose_path = ?,
  compose_file = ?,
  port = ?,
  application_type = ?,
  up_cmd = ?,
  init_cmd = ?,
  rollout_cmd = ?,
  overlay_volumes = ?,
  os = ?,
  is_production = ?,
  gcp_external_ip = ?,
  ` + "`" + `status` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateSiteParams struct {
	Name             string          `json:"name"`
	GithubRepository string          `json:"github_repository"`
	GithubRef        string          `json:"github_ref"`
	GithubTeamID     sql.NullString  `json:"github_team_id"`
	ComposePath      sql.NullString  `json:"compose_path"`
	ComposeFile      sql.NullString  `json:"compose_file"`
	Port             sql.NullInt32   `json:"port"`
	ApplicationType  sql.NullString  `json:"application_type"`
	UpCmd            types.RawJSON   `json:"up_cmd"`
	InitCmd          types.RawJSON   `json:"init_cmd"`
	RolloutCmd       types.RawJSON   `json:"rollout_cmd"`
	OverlayVolumes   types.RawJSON   `json:"overlay_volumes"`
	Os               sql.NullString  `json:"os"`
	IsProduction     sql.NullBool    `json:"is_production"`
	GcpExternalIp    sql.NullString  `json:"gcp_external_ip"`
	Status           NullSitesStatus `json:"status"`
	UpdatedBy        sql.NullInt64   `json:"updated_by"`
	PublicID         string          `json:"public_id"`
}

func (q *Queries) UpdateSite(ctx context.Context, arg UpdateSiteParams) error {
	_, err := q.db.ExecContext(ctx, updateSite,
		arg.Name,
		arg.GithubRepository,
		arg.GithubRef,
		arg.GithubTeamID,
		arg.ComposePath,
		arg.ComposeFile,
		arg.Port,
		arg.ApplicationType,
		arg.UpCmd,
		arg.InitCmd,
		arg.RolloutCmd,
		arg.OverlayVolumes,
		arg.Os,
		arg.IsProduction,
		arg.GcpExternalIp,
		arg.Status,
		arg.UpdatedBy,
		arg.PublicID,
	)
	return err
}

const updateSiteCheckIn = `-- name: UpdateSiteCheckIn :exec
UPDATE sites SET checkin_at = NOW() WHERE id = ?
`

// Updates the site's check-in timestamp (called by VM controller)
func (q *Queries) UpdateSiteCheckIn(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateSiteCheckIn, id)
	return err
}

const updateSiteSecret = `-- name: UpdateSiteSecret :exec
UPDATE site_secrets
SET vault_path = ?, updated_by = ?, updated_at = ?
WHERE id = ?
`

type UpdateSiteSecretParams struct {
	VaultPath string        `json:"vault_path"`
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateSiteSecret(ctx context.Context, arg UpdateSiteSecretParams) error {
	_, err := q.db.ExecContext(ctx, updateSiteSecret,
		arg.VaultPath,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
