// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organizations.sql

package db

import (
	"context"
	"database/sql"
)

const countOrganizationSecrets = `-- name: CountOrganizationSecrets :one
SELECT COUNT(*) FROM organization_secrets
WHERE organization_id = ? AND status != 'deleted'
`

func (q *Queries) CountOrganizationSecrets(ctx context.Context, organizationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrganizationSecrets, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserOrganizations = `-- name: CountUserOrganizations :one
SELECT COUNT(DISTINCT om.organization_id) as count
FROM organization_members om
WHERE om.account_id = ? AND om.status = 'active'
`

func (q *Queries) CountUserOrganizations(ctx context.Context, accountID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserOrganizations, accountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrganization = `-- name: CreateOrganization :exec
INSERT INTO organizations (
  public_id, ` + "`" + `name` + "`" + `, gcp_org_id, gcp_billing_account, gcp_parent, gcp_folder_id, ` + "`" + `status` + "`" + `, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateOrganizationParams struct {
	PublicID          string                  `json:"public_id"`
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	CreatedBy         sql.NullInt64           `json:"created_by"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, createOrganization,
		arg.PublicID,
		arg.Name,
		arg.GcpOrgID,
		arg.GcpBillingAccount,
		arg.GcpParent,
		arg.GcpFolderID,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createOrganizationFirewallRule = `-- name: CreateOrganizationFirewallRule :exec
INSERT INTO organization_firewall_rules (
  public_id, organization_id, name, rule_type, cidr, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?)
`

type CreateOrganizationFirewallRuleParams struct {
	OrganizationID sql.NullInt64                     `json:"organization_id"`
	Name           string                            `json:"name"`
	RuleType       OrganizationFirewallRulesRuleType `json:"rule_type"`
	Cidr           string                            `json:"cidr"`
	CreatedBy      sql.NullInt64                     `json:"created_by"`
	UpdatedBy      sql.NullInt64                     `json:"updated_by"`
}

func (q *Queries) CreateOrganizationFirewallRule(ctx context.Context, arg CreateOrganizationFirewallRuleParams) error {
	_, err := q.db.ExecContext(ctx, createOrganizationFirewallRule,
		arg.OrganizationID,
		arg.Name,
		arg.RuleType,
		arg.Cidr,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createOrganizationMember = `-- name: CreateOrganizationMember :exec
INSERT INTO organization_members (
  public_id, organization_id, account_id, ` + "`" + `role` + "`" + `, status, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateOrganizationMemberParams struct {
	OrganizationID int64                         `json:"organization_id"`
	AccountID      int64                         `json:"account_id"`
	Role           OrganizationMembersRole       `json:"role"`
	Status         NullOrganizationMembersStatus `json:"status"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

func (q *Queries) CreateOrganizationMember(ctx context.Context, arg CreateOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, createOrganizationMember,
		arg.OrganizationID,
		arg.AccountID,
		arg.Role,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createOrganizationSecret = `-- name: CreateOrganizationSecret :execresult


INSERT INTO organization_secrets (
    public_id, organization_id, name, vault_path, status, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateOrganizationSecretParams struct {
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

// =============================================================================
// EVENT QUEUE
// =============================================================================
func (q *Queries) CreateOrganizationSecret(ctx context.Context, arg CreateOrganizationSecretParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createOrganizationSecret,
		arg.PublicID,
		arg.OrganizationID,
		arg.Name,
		arg.VaultPath,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteOrganization(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteOrganization, publicID)
	return err
}

const deleteOrganizationFirewallRule = `-- name: DeleteOrganizationFirewallRule :exec
DELETE FROM organization_firewall_rules WHERE id = ?
`

func (q *Queries) DeleteOrganizationFirewallRule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationFirewallRule, id)
	return err
}

const deleteOrganizationFirewallRuleByPublicID = `-- name: DeleteOrganizationFirewallRuleByPublicID :exec
UPDATE organization_firewall_rules SET status = 'deleted', updated_at = CURRENT_TIMESTAMP WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteOrganizationFirewallRuleByPublicID(ctx context.Context, uuidTOBIN string) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationFirewallRuleByPublicID, uuidTOBIN)
	return err
}

const deleteOrganizationMember = `-- name: DeleteOrganizationMember :exec
DELETE FROM organization_members WHERE organization_id = ? AND account_id = ?
`

type DeleteOrganizationMemberParams struct {
	OrganizationID int64 `json:"organization_id"`
	AccountID      int64 `json:"account_id"`
}

func (q *Queries) DeleteOrganizationMember(ctx context.Context, arg DeleteOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationMember, arg.OrganizationID, arg.AccountID)
	return err
}

const deleteOrganizationSecret = `-- name: DeleteOrganizationSecret :exec
UPDATE organization_secrets
SET status = 'deleted', updated_by = ?, updated_at = ?
WHERE id = ?
`

type DeleteOrganizationSecretParams struct {
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) DeleteOrganizationSecret(ctx context.Context, arg DeleteOrganizationSecretParams) error {
	_, err := q.db.ExecContext(ctx, deleteOrganizationSecret, arg.UpdatedBy, arg.UpdatedAt, arg.ID)
	return err
}

const getOrganization = `-- name: GetOrganization :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, ` + "`" + `name` + "`" + `, gcp_org_id, gcp_billing_account, gcp_parent, gcp_folder_id, ` + "`" + `status` + "`" + `, gcp_project_id, gcp_project_number, created_at, updated_at, created_by, updated_by
FROM organizations WHERE public_id = UUID_TO_BIN(?)
`

type GetOrganizationRow struct {
	ID                int64                   `json:"id"`
	PublicID          string                  `json:"public_id"`
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	GcpProjectID      sql.NullString          `json:"gcp_project_id"`
	GcpProjectNumber  sql.NullString          `json:"gcp_project_number"`
	CreatedAt         sql.NullTime            `json:"created_at"`
	UpdatedAt         sql.NullTime            `json:"updated_at"`
	CreatedBy         sql.NullInt64           `json:"created_by"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) GetOrganization(ctx context.Context, publicID string) (GetOrganizationRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganization, publicID)
	var i GetOrganizationRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.GcpOrgID,
		&i.GcpBillingAccount,
		&i.GcpParent,
		&i.GcpFolderID,
		&i.Status,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationByGCPProjectID = `-- name: GetOrganizationByGCPProjectID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, ` + "`" + `name` + "`" + `, gcp_org_id, gcp_billing_account, gcp_parent, gcp_folder_id, ` + "`" + `status` + "`" + `, gcp_project_id, gcp_project_number, created_at, updated_at, created_by, updated_by
FROM organizations WHERE gcp_project_id = ?
`

type GetOrganizationByGCPProjectIDRow struct {
	ID                int64                   `json:"id"`
	PublicID          string                  `json:"public_id"`
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	GcpProjectID      sql.NullString          `json:"gcp_project_id"`
	GcpProjectNumber  sql.NullString          `json:"gcp_project_number"`
	CreatedAt         sql.NullTime            `json:"created_at"`
	UpdatedAt         sql.NullTime            `json:"updated_at"`
	CreatedBy         sql.NullInt64           `json:"created_by"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) GetOrganizationByGCPProjectID(ctx context.Context, gcpProjectID sql.NullString) (GetOrganizationByGCPProjectIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByGCPProjectID, gcpProjectID)
	var i GetOrganizationByGCPProjectIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.GcpOrgID,
		&i.GcpBillingAccount,
		&i.GcpParent,
		&i.GcpFolderID,
		&i.Status,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, ` + "`" + `name` + "`" + `, gcp_org_id, gcp_billing_account, gcp_parent, gcp_folder_id, ` + "`" + `status` + "`" + `, gcp_project_id, gcp_project_number, created_at, updated_at, created_by, updated_by
FROM organizations WHERE id = ?
`

type GetOrganizationByIDRow struct {
	ID                int64                   `json:"id"`
	PublicID          string                  `json:"public_id"`
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	GcpProjectID      sql.NullString          `json:"gcp_project_id"`
	GcpProjectNumber  sql.NullString          `json:"gcp_project_number"`
	CreatedAt         sql.NullTime            `json:"created_at"`
	UpdatedAt         sql.NullTime            `json:"updated_at"`
	CreatedBy         sql.NullInt64           `json:"created_by"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) GetOrganizationByID(ctx context.Context, id int64) (GetOrganizationByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByID, id)
	var i GetOrganizationByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.GcpOrgID,
		&i.GcpBillingAccount,
		&i.GcpParent,
		&i.GcpFolderID,
		&i.Status,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationFirewallRuleByPublicID = `-- name: GetOrganizationFirewallRuleByPublicID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, rule_type, cidr, name, status, created_at, updated_at, created_by, updated_by
FROM organization_firewall_rules WHERE public_id = UUID_TO_BIN(?)
`

type GetOrganizationFirewallRuleByPublicIDRow struct {
	ID             int64                               `json:"id"`
	PublicID       string                              `json:"public_id"`
	OrganizationID sql.NullInt64                       `json:"organization_id"`
	RuleType       OrganizationFirewallRulesRuleType   `json:"rule_type"`
	Cidr           string                              `json:"cidr"`
	Name           string                              `json:"name"`
	Status         NullOrganizationFirewallRulesStatus `json:"status"`
	CreatedAt      sql.NullTime                        `json:"created_at"`
	UpdatedAt      sql.NullTime                        `json:"updated_at"`
	CreatedBy      sql.NullInt64                       `json:"created_by"`
	UpdatedBy      sql.NullInt64                       `json:"updated_by"`
}

func (q *Queries) GetOrganizationFirewallRuleByPublicID(ctx context.Context, uuidTOBIN string) (GetOrganizationFirewallRuleByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationFirewallRuleByPublicID, uuidTOBIN)
	var i GetOrganizationFirewallRuleByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.RuleType,
		&i.Cidr,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationMember = `-- name: GetOrganizationMember :one


SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
FROM organization_members WHERE organization_id = ? AND account_id = ?
`

type GetOrganizationMemberParams struct {
	OrganizationID int64 `json:"organization_id"`
	AccountID      int64 `json:"account_id"`
}

type GetOrganizationMemberRow struct {
	ID             int64                   `json:"id"`
	PublicID       string                  `json:"public_id"`
	OrganizationID int64                   `json:"organization_id"`
	AccountID      int64                   `json:"account_id"`
	Role           OrganizationMembersRole `json:"role"`
	CreatedAt      sql.NullTime            `json:"created_at"`
	UpdatedAt      sql.NullTime            `json:"updated_at"`
	CreatedBy      sql.NullInt64           `json:"created_by"`
	UpdatedBy      sql.NullInt64           `json:"updated_by"`
}

// =============================================================================
// ACCOUNTS
// =============================================================================
func (q *Queries) GetOrganizationMember(ctx context.Context, arg GetOrganizationMemberParams) (GetOrganizationMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationMember, arg.OrganizationID, arg.AccountID)
	var i GetOrganizationMemberRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.AccountID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationMemberByAccountAndOrganization = `-- name: GetOrganizationMemberByAccountAndOrganization :one


SELECT id, public_id, organization_id, account_id, role, status, created_at, updated_at, created_by, updated_by FROM organization_members
WHERE account_id = ? AND organization_id = ? AND status = 'active'
`

type GetOrganizationMemberByAccountAndOrganizationParams struct {
	AccountID      int64 `json:"account_id"`
	OrganizationID int64 `json:"organization_id"`
}

// =============================================================================
// PROJECT SECRETS
// =============================================================================
func (q *Queries) GetOrganizationMemberByAccountAndOrganization(ctx context.Context, arg GetOrganizationMemberByAccountAndOrganizationParams) (OrganizationMember, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationMemberByAccountAndOrganization, arg.AccountID, arg.OrganizationID)
	var i OrganizationMember
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.AccountID,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationProjectByOrganizationID = `-- name: GetOrganizationProjectByOrganizationID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, ` + "`" + `name` + "`" + `,
       gcp_region, gcp_zone, machine_type, disk_size_gb, os, disk_type, stripe_subscription_item_id,
       promote_strategy,
       monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
       gcp_project_id, gcp_project_number, create_branch_sites, organization_project, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM projects
WHERE organization_id = ? AND organization_project = TRUE
LIMIT 1
`

type GetOrganizationProjectByOrganizationIDRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	Os                        sql.NullString              `json:"os"`
	DiskType                  sql.NullString              `json:"disk_type"`
	StripeSubscriptionItemID  sql.NullString              `json:"stripe_subscription_item_id"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) GetOrganizationProjectByOrganizationID(ctx context.Context, organizationID int64) (GetOrganizationProjectByOrganizationIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationProjectByOrganizationID, organizationID)
	var i GetOrganizationProjectByOrganizationIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.Os,
		&i.DiskType,
		&i.StripeSubscriptionItemID,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreateBranchSites,
		&i.OrganizationProject,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationSecretByID = `-- name: GetOrganizationSecretByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM organization_secrets WHERE id = ? AND status != 'deleted'
`

type GetOrganizationSecretByIDRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

func (q *Queries) GetOrganizationSecretByID(ctx context.Context, id int64) (GetOrganizationSecretByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationSecretByID, id)
	var i GetOrganizationSecretByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationSecretByName = `-- name: GetOrganizationSecretByName :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM organization_secrets
WHERE organization_id = ? AND name = ? AND status != 'deleted'
`

type GetOrganizationSecretByNameParams struct {
	OrganizationID int64  `json:"organization_id"`
	Name           string `json:"name"`
}

type GetOrganizationSecretByNameRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

func (q *Queries) GetOrganizationSecretByName(ctx context.Context, arg GetOrganizationSecretByNameParams) (GetOrganizationSecretByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationSecretByName, arg.OrganizationID, arg.Name)
	var i GetOrganizationSecretByNameRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOrganizationSecretByPublicID = `-- name: GetOrganizationSecretByPublicID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM organization_secrets WHERE public_id = UUID_TO_BIN(?) AND status != 'deleted'
`

type GetOrganizationSecretByPublicIDRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

func (q *Queries) GetOrganizationSecretByPublicID(ctx context.Context, publicID string) (GetOrganizationSecretByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationSecretByPublicID, publicID)
	var i GetOrganizationSecretByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectWithOrganization = `-- name: GetProjectWithOrganization :one


SELECT
    p.id, BIN_TO_UUID(p.public_id) AS public_id, p.organization_id, p.name,
    p.gcp_region, p.gcp_zone, p.machine_type, p.disk_size_gb, p.os, p.disk_type, p.stripe_subscription_item_id,
    p.promote_strategy,
    p.monitoring_enabled, p.monitoring_log_level, p.monitoring_metrics_enabled, p.monitoring_health_check_path,
    p.gcp_project_id, p.gcp_project_number, p.create_branch_sites, p.status,
    p.created_at, p.updated_at, p.created_by, p.updated_by,
    c.gcp_billing_account
FROM projects p
JOIN organizations c ON p.organization_id = c.id
WHERE p.public_id = UUID_TO_BIN(?)
`

type GetProjectWithOrganizationRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	Os                        sql.NullString              `json:"os"`
	DiskType                  sql.NullString              `json:"disk_type"`
	StripeSubscriptionItemID  sql.NullString              `json:"stripe_subscription_item_id"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
	GcpBillingAccount         string                      `json:"gcp_billing_account"`
}

// =============================================================================
// Ssh KEYS
// =============================================================================
func (q *Queries) GetProjectWithOrganization(ctx context.Context, publicID string) (GetProjectWithOrganizationRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectWithOrganization, publicID)
	var i GetProjectWithOrganizationRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.Os,
		&i.DiskType,
		&i.StripeSubscriptionItemID,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreateBranchSites,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.GcpBillingAccount,
	)
	return i, err
}

const getStripeSubscriptionByOrganizationID = `-- name: GetStripeSubscriptionByOrganizationID :one


SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, stripe_subscription_id, stripe_customer_id, stripe_checkout_session_id,
       status, current_period_start, current_period_end, trial_start, trial_end,
       cancel_at_period_end, canceled_at, machine_type, disk_size_gb, created_at, updated_at
FROM stripe_subscriptions WHERE organization_id = ?
`

type GetStripeSubscriptionByOrganizationIDRow struct {
	ID                      int64                     `json:"id"`
	PublicID                string                    `json:"public_id"`
	OrganizationID          int64                     `json:"organization_id"`
	StripeSubscriptionID    string                    `json:"stripe_subscription_id"`
	StripeCustomerID        string                    `json:"stripe_customer_id"`
	StripeCheckoutSessionID sql.NullString            `json:"stripe_checkout_session_id"`
	Status                  StripeSubscriptionsStatus `json:"status"`
	CurrentPeriodStart      sql.NullTime              `json:"current_period_start"`
	CurrentPeriodEnd        sql.NullTime              `json:"current_period_end"`
	TrialStart              sql.NullTime              `json:"trial_start"`
	TrialEnd                sql.NullTime              `json:"trial_end"`
	CancelAtPeriodEnd       sql.NullBool              `json:"cancel_at_period_end"`
	CanceledAt              sql.NullTime              `json:"canceled_at"`
	MachineType             sql.NullString            `json:"machine_type"`
	DiskSizeGb              sql.NullInt32             `json:"disk_size_gb"`
	CreatedAt               sql.NullTime              `json:"created_at"`
	UpdatedAt               sql.NullTime              `json:"updated_at"`
}

// =============================================================================
// ONBOARDING
// =============================================================================
func (q *Queries) GetStripeSubscriptionByOrganizationID(ctx context.Context, organizationID int64) (GetStripeSubscriptionByOrganizationIDRow, error) {
	row := q.db.QueryRowContext(ctx, getStripeSubscriptionByOrganizationID, organizationID)
	var i GetStripeSubscriptionByOrganizationIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.StripeSubscriptionID,
		&i.StripeCustomerID,
		&i.StripeCheckoutSessionID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.TrialStart,
		&i.TrialEnd,
		&i.CancelAtPeriodEnd,
		&i.CanceledAt,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hasUserProjectAccessInOrganization = `-- name: HasUserProjectAccessInOrganization :one
SELECT EXISTS (
    SELECT 1 FROM project_members pm
    JOIN projects p ON pm.project_id = p.id
    LEFT JOIN relationships r ON (
        r.source_organization_id = p.organization_id AND r.target_organization_id = ?
    )
    WHERE pm.account_id = ?
      AND (p.organization_id = ? OR (r.status = 'approved' AND r.id IS NOT NULL))
      AND pm.status = 'active'
    LIMIT 1
)
`

type HasUserProjectAccessInOrganizationParams struct {
	TargetOrganizationID int64 `json:"target_organization_id"`
	AccountID            int64 `json:"account_id"`
	OrganizationID       int64 `json:"organization_id"`
}

func (q *Queries) HasUserProjectAccessInOrganization(ctx context.Context, arg HasUserProjectAccessInOrganizationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserProjectAccessInOrganization, arg.TargetOrganizationID, arg.AccountID, arg.OrganizationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasUserRelationshipAccessToOrganization = `-- name: HasUserRelationshipAccessToOrganization :one
WITH RECURSIVE user_access AS (
    SELECT organization_id
    FROM organization_members
    WHERE account_id = ? AND status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_access ua ON r.source_organization_id = ua.organization_id
    WHERE r.status = 'approved'
)
SELECT EXISTS (
    SELECT 1 FROM user_access WHERE organization_id = ?
)
`

type HasUserRelationshipAccessToOrganizationParams struct {
	AccountID      int64 `json:"account_id"`
	OrganizationID int64 `json:"organization_id"`
}

func (q *Queries) HasUserRelationshipAccessToOrganization(ctx context.Context, arg HasUserRelationshipAccessToOrganizationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserRelationshipAccessToOrganization, arg.AccountID, arg.OrganizationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasUserSiteAccessInOrganization = `-- name: HasUserSiteAccessInOrganization :one
SELECT EXISTS (
    SELECT 1 FROM site_members sm
    JOIN sites s ON sm.site_id = s.id
    JOIN projects p ON s.project_id = p.id
    LEFT JOIN relationships r ON (
        r.source_organization_id = p.organization_id AND r.target_organization_id = ?
    )
    WHERE sm.account_id = ?
      AND (p.organization_id = ? OR (r.status = 'approved' AND r.id IS NOT NULL))
      AND sm.status = 'active'
    LIMIT 1
)
`

type HasUserSiteAccessInOrganizationParams struct {
	TargetOrganizationID int64 `json:"target_organization_id"`
	AccountID            int64 `json:"account_id"`
	OrganizationID       int64 `json:"organization_id"`
}

func (q *Queries) HasUserSiteAccessInOrganization(ctx context.Context, arg HasUserSiteAccessInOrganizationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserSiteAccessInOrganization, arg.TargetOrganizationID, arg.AccountID, arg.OrganizationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listAccountOrganizations = `-- name: ListAccountOrganizations :many
SELECT c.id, BIN_TO_UUID(c.public_id) AS public_id, c.` + "`" + `name` + "`" + `, cm.` + "`" + `role` + "`" + `
FROM organization_members cm
JOIN organizations c ON cm.organization_id = c.id
WHERE cm.account_id = ?
ORDER BY c.created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountOrganizationsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListAccountOrganizationsRow struct {
	ID       int64                   `json:"id"`
	PublicID string                  `json:"public_id"`
	Name     string                  `json:"name"`
	Role     OrganizationMembersRole `json:"role"`
}

func (q *Queries) ListAccountOrganizations(ctx context.Context, arg ListAccountOrganizationsParams) ([]ListAccountOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccountOrganizations, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountOrganizationsRow{}
	for rows.Next() {
		var i ListAccountOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllOrganizations = `-- name: ListAllOrganizations :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, ` + "`" + `name` + "`" + `, gcp_org_id, gcp_billing_account, gcp_parent, gcp_folder_id, ` + "`" + `status` + "`" + `, gcp_project_id, gcp_project_number, created_at, updated_at, created_by, updated_by
FROM organizations
ORDER BY created_at DESC
`

type ListAllOrganizationsRow struct {
	ID                int64                   `json:"id"`
	PublicID          string                  `json:"public_id"`
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	GcpProjectID      sql.NullString          `json:"gcp_project_id"`
	GcpProjectNumber  sql.NullString          `json:"gcp_project_number"`
	CreatedAt         sql.NullTime            `json:"created_at"`
	UpdatedAt         sql.NullTime            `json:"updated_at"`
	CreatedBy         sql.NullInt64           `json:"created_by"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
}

func (q *Queries) ListAllOrganizations(ctx context.Context) ([]ListAllOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllOrganizationsRow{}
	for rows.Next() {
		var i ListAllOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.GcpOrgID,
			&i.GcpBillingAccount,
			&i.GcpParent,
			&i.GcpFolderID,
			&i.Status,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApprovedRelatedOrganizationsForAccount = `-- name: ListApprovedRelatedOrganizationsForAccount :many
WITH user_orgs AS (
    SELECT organization_id FROM organization_members WHERE account_id = ? AND status = 'active'
)
SELECT r.id, BIN_TO_UUID(r.public_id) AS public_id, r.source_organization_id, r.target_organization_id,
       r.relationship_type, r.` + "`" + `status` + "`" + `, r.created_at, r.resolved_at, r.resolved_by,
       BIN_TO_UUID(target_org.public_id) AS target_org_public_id
FROM relationships r
INNER JOIN organizations target_org ON r.target_organization_id = target_org.id
WHERE r.source_organization_id = ?
  AND r.` + "`" + `status` + "`" + ` = 'approved'
  AND r.target_organization_id IN (SELECT organization_id FROM user_orgs)
ORDER BY r.created_at DESC
`

type ListApprovedRelatedOrganizationsForAccountParams struct {
	AccountID            int64 `json:"account_id"`
	SourceOrganizationID int64 `json:"source_organization_id"`
}

type ListApprovedRelatedOrganizationsForAccountRow struct {
	ID                   int64                         `json:"id"`
	PublicID             string                        `json:"public_id"`
	SourceOrganizationID int64                         `json:"source_organization_id"`
	TargetOrganizationID int64                         `json:"target_organization_id"`
	RelationshipType     RelationshipsRelationshipType `json:"relationship_type"`
	Status               RelationshipsStatus           `json:"status"`
	CreatedAt            sql.NullTime                  `json:"created_at"`
	ResolvedAt           sql.NullTime                  `json:"resolved_at"`
	ResolvedBy           sql.NullInt64                 `json:"resolved_by"`
	TargetOrgPublicID    string                        `json:"target_org_public_id"`
}

// Get all approved relationships for a source org where the account has access to the target org
func (q *Queries) ListApprovedRelatedOrganizationsForAccount(ctx context.Context, arg ListApprovedRelatedOrganizationsForAccountParams) ([]ListApprovedRelatedOrganizationsForAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listApprovedRelatedOrganizationsForAccount, arg.AccountID, arg.SourceOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListApprovedRelatedOrganizationsForAccountRow{}
	for rows.Next() {
		var i ListApprovedRelatedOrganizationsForAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceOrganizationID,
			&i.TargetOrganizationID,
			&i.RelationshipType,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ResolvedBy,
			&i.TargetOrgPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationFirewallRules = `-- name: ListOrganizationFirewallRules :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, rule_type, cidr, name, status, created_at, updated_at, created_by, updated_by
FROM organization_firewall_rules
WHERE organization_id = ? AND status != 'deleted'
ORDER BY created_at DESC
`

type ListOrganizationFirewallRulesRow struct {
	ID             int64                               `json:"id"`
	PublicID       string                              `json:"public_id"`
	OrganizationID sql.NullInt64                       `json:"organization_id"`
	RuleType       OrganizationFirewallRulesRuleType   `json:"rule_type"`
	Cidr           string                              `json:"cidr"`
	Name           string                              `json:"name"`
	Status         NullOrganizationFirewallRulesStatus `json:"status"`
	CreatedAt      sql.NullTime                        `json:"created_at"`
	UpdatedAt      sql.NullTime                        `json:"updated_at"`
	CreatedBy      sql.NullInt64                       `json:"created_by"`
	UpdatedBy      sql.NullInt64                       `json:"updated_by"`
}

func (q *Queries) ListOrganizationFirewallRules(ctx context.Context, organizationID sql.NullInt64) ([]ListOrganizationFirewallRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationFirewallRules, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationFirewallRulesRow{}
	for rows.Next() {
		var i ListOrganizationFirewallRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.RuleType,
			&i.Cidr,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationMembers = `-- name: ListOrganizationMembers :many
SELECT cm.id, BIN_TO_UUID(cm.public_id) AS public_id, cm.organization_id, cm.account_id, cm.` + "`" + `role` + "`" + `, cm.status, cm.created_at, cm.updated_at,
       BIN_TO_UUID(a.public_id) AS account_public_id, a.email, a.` + "`" + `name` + "`" + `, a.github_username, a.verified, a.auth_method
FROM organization_members cm
JOIN accounts a ON cm.account_id = a.id
WHERE cm.organization_id = ?
ORDER BY cm.created_at DESC
LIMIT ? OFFSET ?
`

type ListOrganizationMembersParams struct {
	OrganizationID int64 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

type ListOrganizationMembersRow struct {
	ID              int64                         `json:"id"`
	PublicID        string                        `json:"public_id"`
	OrganizationID  int64                         `json:"organization_id"`
	AccountID       int64                         `json:"account_id"`
	Role            OrganizationMembersRole       `json:"role"`
	Status          NullOrganizationMembersStatus `json:"status"`
	CreatedAt       sql.NullTime                  `json:"created_at"`
	UpdatedAt       sql.NullTime                  `json:"updated_at"`
	AccountPublicID string                        `json:"account_public_id"`
	Email           string                        `json:"email"`
	Name            sql.NullString                `json:"name"`
	GithubUsername  sql.NullString                `json:"github_username"`
	Verified        bool                          `json:"verified"`
	AuthMethod      AccountsAuthMethod            `json:"auth_method"`
}

func (q *Queries) ListOrganizationMembers(ctx context.Context, arg ListOrganizationMembersParams) ([]ListOrganizationMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationMembers, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationMembersRow{}
	for rows.Next() {
		var i ListOrganizationMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.AccountID,
			&i.Role,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountPublicID,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
			&i.Verified,
			&i.AuthMethod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationProjects = `-- name: ListOrganizationProjects :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, gcp_region, gcp_zone, machine_type, disk_size_gb, os, disk_type, stripe_subscription_item_id, promote_strategy, monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path, gcp_project_id, gcp_project_number, organization_project, create_branch_sites, status, created_at, updated_at, created_by, updated_by
FROM projects
WHERE organization_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListOrganizationProjectsParams struct {
	OrganizationID int64 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

type ListOrganizationProjectsRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	Os                        sql.NullString              `json:"os"`
	DiskType                  sql.NullString              `json:"disk_type"`
	StripeSubscriptionItemID  sql.NullString              `json:"stripe_subscription_item_id"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListOrganizationProjects(ctx context.Context, arg ListOrganizationProjectsParams) ([]ListOrganizationProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationProjects, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationProjectsRow{}
	for rows.Next() {
		var i ListOrganizationProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.Name,
			&i.GcpRegion,
			&i.GcpZone,
			&i.MachineType,
			&i.DiskSizeGb,
			&i.Os,
			&i.DiskType,
			&i.StripeSubscriptionItemID,
			&i.PromoteStrategy,
			&i.MonitoringEnabled,
			&i.MonitoringLogLevel,
			&i.MonitoringMetricsEnabled,
			&i.MonitoringHealthCheckPath,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.OrganizationProject,
			&i.CreateBranchSites,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationRelationships = `-- name: ListOrganizationRelationships :many


SELECT r.id, BIN_TO_UUID(r.public_id) AS public_id, r.source_organization_id, r.target_organization_id,
       r.relationship_type, r.` + "`" + `status` + "`" + `, r.created_at, r.resolved_at, r.resolved_by
FROM relationships r
WHERE r.source_organization_id = ? OR r.target_organization_id = ?
ORDER BY r.created_at DESC
`

type ListOrganizationRelationshipsParams struct {
	SourceOrganizationID int64 `json:"source_organization_id"`
	TargetOrganizationID int64 `json:"target_organization_id"`
}

type ListOrganizationRelationshipsRow struct {
	ID                   int64                         `json:"id"`
	PublicID             string                        `json:"public_id"`
	SourceOrganizationID int64                         `json:"source_organization_id"`
	TargetOrganizationID int64                         `json:"target_organization_id"`
	RelationshipType     RelationshipsRelationshipType `json:"relationship_type"`
	Status               RelationshipsStatus           `json:"status"`
	CreatedAt            sql.NullTime                  `json:"created_at"`
	ResolvedAt           sql.NullTime                  `json:"resolved_at"`
	ResolvedBy           sql.NullInt64                 `json:"resolved_by"`
}

// =============================================================================
// PROJECT FIREWALL RULES
// =============================================================================
func (q *Queries) ListOrganizationRelationships(ctx context.Context, arg ListOrganizationRelationshipsParams) ([]ListOrganizationRelationshipsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationRelationships, arg.SourceOrganizationID, arg.TargetOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationRelationshipsRow{}
	for rows.Next() {
		var i ListOrganizationRelationshipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceOrganizationID,
			&i.TargetOrganizationID,
			&i.RelationshipType,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ResolvedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationSecrets = `-- name: ListOrganizationSecrets :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM organization_secrets
WHERE organization_id = ? AND status != 'deleted'
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListOrganizationSecretsParams struct {
	OrganizationID int64 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

type ListOrganizationSecretsRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	OrganizationID int64                         `json:"organization_id"`
	Name           string                        `json:"name"`
	VaultPath      string                        `json:"vault_path"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	CreatedBy      sql.NullInt64                 `json:"created_by"`
	UpdatedBy      sql.NullInt64                 `json:"updated_by"`
}

func (q *Queries) ListOrganizationSecrets(ctx context.Context, arg ListOrganizationSecretsParams) ([]ListOrganizationSecretsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationSecrets, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationSecretsRow{}
	for rows.Next() {
		var i ListOrganizationSecretsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.Name,
			&i.VaultPath,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizations = `-- name: ListOrganizations :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE account_id = ? AND status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT o.id, BIN_TO_UUID(o.public_id) AS public_id, o.name, o.gcp_org_id, o.gcp_billing_account, o.gcp_parent, o.location, o.region, o.gcp_folder_id, o.status, o.gcp_project_id, o.gcp_project_number, o.created_at, o.updated_at, o.created_by, o.updated_by
FROM organizations o
INNER JOIN user_orgs uo ON o.id = uo.organization_id
ORDER BY o.created_at DESC
LIMIT ? OFFSET ?
`

type ListOrganizationsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListOrganizationsRow struct {
	ID                int64                     `json:"id"`
	PublicID          string                    `json:"public_id"`
	Name              string                    `json:"name"`
	GcpOrgID          string                    `json:"gcp_org_id"`
	GcpBillingAccount string                    `json:"gcp_billing_account"`
	GcpParent         string                    `json:"gcp_parent"`
	Location          NullOrganizationsLocation `json:"location"`
	Region            sql.NullString            `json:"region"`
	GcpFolderID       sql.NullString            `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus   `json:"status"`
	GcpProjectID      sql.NullString            `json:"gcp_project_id"`
	GcpProjectNumber  sql.NullString            `json:"gcp_project_number"`
	CreatedAt         sql.NullTime              `json:"created_at"`
	UpdatedAt         sql.NullTime              `json:"updated_at"`
	CreatedBy         sql.NullInt64             `json:"created_by"`
	UpdatedBy         sql.NullInt64             `json:"updated_by"`
}

func (q *Queries) ListOrganizations(ctx context.Context, arg ListOrganizationsParams) ([]ListOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizations, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationsRow{}
	for rows.Next() {
		var i ListOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.GcpOrgID,
			&i.GcpBillingAccount,
			&i.GcpParent,
			&i.Location,
			&i.Region,
			&i.GcpFolderID,
			&i.Status,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrganizations = `-- name: ListUserOrganizations :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT o.id, BIN_TO_UUID(o.public_id) AS public_id, o.name,
       COALESCE(om.role, 'read') AS role
FROM organizations o
JOIN user_orgs uo ON o.id = uo.organization_id
LEFT JOIN organization_members om ON o.id = om.organization_id AND om.account_id = ?
ORDER BY o.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserOrganizationsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListUserOrganizationsRow struct {
	ID       int64                   `json:"id"`
	PublicID string                  `json:"public_id"`
	Name     string                  `json:"name"`
	Role     OrganizationMembersRole `json:"role"`
}

func (q *Queries) ListUserOrganizations(ctx context.Context, arg ListUserOrganizationsParams) ([]ListUserOrganizationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserOrganizations,
		arg.AccountID,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserOrganizationsRow{}
	for rows.Next() {
		var i ListUserOrganizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrganization = `-- name: UpdateOrganization :exec
UPDATE organizations SET
  ` + "`" + `name` + "`" + ` = ?,
  gcp_org_id = ?,
  gcp_billing_account = ?,
  gcp_parent = ?,
  gcp_folder_id = ?,
  ` + "`" + `status` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateOrganizationParams struct {
	Name              string                  `json:"name"`
	GcpOrgID          string                  `json:"gcp_org_id"`
	GcpBillingAccount string                  `json:"gcp_billing_account"`
	GcpParent         string                  `json:"gcp_parent"`
	GcpFolderID       sql.NullString          `json:"gcp_folder_id"`
	Status            NullOrganizationsStatus `json:"status"`
	UpdatedBy         sql.NullInt64           `json:"updated_by"`
	PublicID          string                  `json:"public_id"`
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganization,
		arg.Name,
		arg.GcpOrgID,
		arg.GcpBillingAccount,
		arg.GcpParent,
		arg.GcpFolderID,
		arg.Status,
		arg.UpdatedBy,
		arg.PublicID,
	)
	return err
}

const updateOrganizationMember = `-- name: UpdateOrganizationMember :exec
UPDATE organization_members SET
  ` + "`" + `role` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE organization_id = ? AND account_id = ?
`

type UpdateOrganizationMemberParams struct {
	Role           OrganizationMembersRole `json:"role"`
	UpdatedBy      sql.NullInt64           `json:"updated_by"`
	OrganizationID int64                   `json:"organization_id"`
	AccountID      int64                   `json:"account_id"`
}

func (q *Queries) UpdateOrganizationMember(ctx context.Context, arg UpdateOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationMember,
		arg.Role,
		arg.UpdatedBy,
		arg.OrganizationID,
		arg.AccountID,
	)
	return err
}

const updateOrganizationMemberStatus = `-- name: UpdateOrganizationMemberStatus :exec
UPDATE organization_members
SET status = ?, updated_at = NOW()
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateOrganizationMemberStatusParams struct {
	Status    NullOrganizationMembersStatus `json:"status"`
	UUIDTOBIN string                        `json:"UUID_TO_BIN"`
}

// Updates organization member status (e.g., provisioning  active)
func (q *Queries) UpdateOrganizationMemberStatus(ctx context.Context, arg UpdateOrganizationMemberStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationMemberStatus, arg.Status, arg.UUIDTOBIN)
	return err
}

const updateOrganizationSecret = `-- name: UpdateOrganizationSecret :exec
UPDATE organization_secrets
SET vault_path = ?, updated_by = ?, updated_at = ?
WHERE id = ?
`

type UpdateOrganizationSecretParams struct {
	VaultPath string        `json:"vault_path"`
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateOrganizationSecret(ctx context.Context, arg UpdateOrganizationSecretParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganizationSecret,
		arg.VaultPath,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
