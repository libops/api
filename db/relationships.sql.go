// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: relationships.sql

package db

import (
	"context"
	"database/sql"
)

const approveRelationship = `-- name: ApproveRelationship :execresult
UPDATE relationships SET
  ` + "`" + `status` + "`" + ` = 'approved',
  resolved_at = CURRENT_TIMESTAMP,
  resolved_by = ?
WHERE public_id = UUID_TO_BIN(?) AND ` + "`" + `status` + "`" + ` = 'pending'
`

type ApproveRelationshipParams struct {
	ResolvedBy sql.NullInt64 `json:"resolved_by"`
	PublicID   string        `json:"public_id"`
}

func (q *Queries) ApproveRelationship(ctx context.Context, arg ApproveRelationshipParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, approveRelationship, arg.ResolvedBy, arg.PublicID)
}

const createRelationship = `-- name: CreateRelationship :execresult
INSERT INTO relationships (
  public_id, source_organization_id, target_organization_id, relationship_type, ` + "`" + `status` + "`" + `, created_at
) VALUES (
  UUID_TO_BIN(UUID_V7()), ?, ?, ?, 'pending', CURRENT_TIMESTAMP
)
`

type CreateRelationshipParams struct {
	SourceOrganizationID int64                         `json:"source_organization_id"`
	TargetOrganizationID int64                         `json:"target_organization_id"`
	RelationshipType     RelationshipsRelationshipType `json:"relationship_type"`
}

func (q *Queries) CreateRelationship(ctx context.Context, arg CreateRelationshipParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createRelationship, arg.SourceOrganizationID, arg.TargetOrganizationID, arg.RelationshipType)
}

const getRelationship = `-- name: GetRelationship :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, source_organization_id, target_organization_id,
       relationship_type, ` + "`" + `status` + "`" + `, created_at, resolved_at, resolved_by
FROM relationships WHERE public_id = UUID_TO_BIN(?)
`

type GetRelationshipRow struct {
	ID                   int64                         `json:"id"`
	PublicID             string                        `json:"public_id"`
	SourceOrganizationID int64                         `json:"source_organization_id"`
	TargetOrganizationID int64                         `json:"target_organization_id"`
	RelationshipType     RelationshipsRelationshipType `json:"relationship_type"`
	Status               RelationshipsStatus           `json:"status"`
	CreatedAt            sql.NullTime                  `json:"created_at"`
	ResolvedAt           sql.NullTime                  `json:"resolved_at"`
	ResolvedBy           sql.NullInt64                 `json:"resolved_by"`
}

func (q *Queries) GetRelationship(ctx context.Context, publicID string) (GetRelationshipRow, error) {
	row := q.db.QueryRowContext(ctx, getRelationship, publicID)
	var i GetRelationshipRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SourceOrganizationID,
		&i.TargetOrganizationID,
		&i.RelationshipType,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
		&i.ResolvedBy,
	)
	return i, err
}

const rejectRelationship = `-- name: RejectRelationship :execresult
UPDATE relationships SET
  ` + "`" + `status` + "`" + ` = 'rejected',
  resolved_at = CURRENT_TIMESTAMP,
  resolved_by = ?
WHERE public_id = UUID_TO_BIN(?) AND ` + "`" + `status` + "`" + ` = 'pending'
`

type RejectRelationshipParams struct {
	ResolvedBy sql.NullInt64 `json:"resolved_by"`
	PublicID   string        `json:"public_id"`
}

func (q *Queries) RejectRelationship(ctx context.Context, arg RejectRelationshipParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, rejectRelationship, arg.ResolvedBy, arg.PublicID)
}
