// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const enqueueEvent = `-- name: EnqueueEvent :exec

INSERT INTO event_queue (
    event_id,
    event_type,
    event_source,
    event_subject,
    event_data,
    content_type,
    organization_id,
    project_id,
    site_id,
    created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
`

type EnqueueEventParams struct {
	EventID        string         `json:"event_id"`
	EventType      string         `json:"event_type"`
	EventSource    string         `json:"event_source"`
	EventSubject   sql.NullString `json:"event_subject"`
	EventData      []byte         `json:"event_data"`
	ContentType    string         `json:"content_type"`
	OrganizationID sql.NullInt64  `json:"organization_id"`
	ProjectID      sql.NullInt64  `json:"project_id"`
	SiteID         sql.NullInt64  `json:"site_id"`
}

// EVENT QUEUE
func (q *Queries) EnqueueEvent(ctx context.Context, arg EnqueueEventParams) error {
	_, err := q.db.ExecContext(ctx, enqueueEvent,
		arg.EventID,
		arg.EventType,
		arg.EventSource,
		arg.EventSubject,
		arg.EventData,
		arg.ContentType,
		arg.OrganizationID,
		arg.ProjectID,
		arg.SiteID,
	)
	return err
}

const getPendingEvents = `-- name: GetPendingEvents :many
SELECT id, event_id, event_type, event_source, event_subject, event_data, content_type,
        organization_id, project_id, site_id, created_at
FROM event_queue
WHERE status = 'pending'
ORDER BY created_at ASC
LIMIT ?
`

type GetPendingEventsRow struct {
	ID             int64          `json:"id"`
	EventID        string         `json:"event_id"`
	EventType      string         `json:"event_type"`
	EventSource    string         `json:"event_source"`
	EventSubject   sql.NullString `json:"event_subject"`
	EventData      []byte         `json:"event_data"`
	ContentType    string         `json:"content_type"`
	OrganizationID sql.NullInt64  `json:"organization_id"`
	ProjectID      sql.NullInt64  `json:"project_id"`
	SiteID         sql.NullInt64  `json:"site_id"`
	CreatedAt      time.Time      `json:"created_at"`
}

func (q *Queries) GetPendingEvents(ctx context.Context, limit int32) ([]GetPendingEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingEventsRow{}
	for rows.Next() {
		var i GetPendingEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.EventType,
			&i.EventSource,
			&i.EventSubject,
			&i.EventData,
			&i.ContentType,
			&i.OrganizationID,
			&i.ProjectID,
			&i.SiteID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueueStats = `-- name: GetQueueStats :one
SELECT
    COUNT(*) as total_events,
    SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending_events,
    SUM(CASE WHEN status = 'sent' THEN 1 ELSE 0 END) as sent_events,
    SUM(CASE WHEN status = 'dead_letter' THEN 1 ELSE 0 END) as dead_letter_events
FROM event_queue
`

type GetQueueStatsRow struct {
	TotalEvents      int64       `json:"total_events"`
	PendingEvents    interface{} `json:"pending_events"`
	SentEvents       interface{} `json:"sent_events"`
	DeadLetterEvents interface{} `json:"dead_letter_events"`
}

func (q *Queries) GetQueueStats(ctx context.Context) (GetQueueStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getQueueStats)
	var i GetQueueStatsRow
	err := row.Scan(
		&i.TotalEvents,
		&i.PendingEvents,
		&i.SentEvents,
		&i.DeadLetterEvents,
	)
	return i, err
}

const markEventCollapsed = `-- name: MarkEventCollapsed :exec
UPDATE event_queue
SET status = 'collapsed',
    collapsed_into_run_id = ?,
    processed_at = NOW()
WHERE event_id = ?
`

type MarkEventCollapsedParams struct {
	CollapsedIntoRunID sql.NullString `json:"collapsed_into_run_id"`
	EventID            string         `json:"event_id"`
}

func (q *Queries) MarkEventCollapsed(ctx context.Context, arg MarkEventCollapsedParams) error {
	_, err := q.db.ExecContext(ctx, markEventCollapsed, arg.CollapsedIntoRunID, arg.EventID)
	return err
}

const markEventDeadLetter = `-- name: MarkEventDeadLetter :exec
UPDATE event_queue
SET status = 'dead_letter',
    processed_at = NOW()
WHERE event_id = ?
`

func (q *Queries) MarkEventDeadLetter(ctx context.Context, eventID string) error {
	_, err := q.db.ExecContext(ctx, markEventDeadLetter, eventID)
	return err
}

const markEventExecuted = `-- name: MarkEventExecuted :exec
UPDATE event_queue
SET status = 'executed',
    created_run_id = ?,
    processed_at = NOW()
WHERE event_id = ?
`

type MarkEventExecutedParams struct {
	CreatedRunID sql.NullString `json:"created_run_id"`
	EventID      string         `json:"event_id"`
}

func (q *Queries) MarkEventExecuted(ctx context.Context, arg MarkEventExecutedParams) error {
	_, err := q.db.ExecContext(ctx, markEventExecuted, arg.CreatedRunID, arg.EventID)
	return err
}

const markEventSent = `-- name: MarkEventSent :exec
UPDATE event_queue
SET status = 'sent',
    sent_at = NOW()
WHERE id = ?
`

func (q *Queries) MarkEventSent(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markEventSent, id)
	return err
}

const markEventSentOrStatus = `-- name: MarkEventSentOrStatus :exec
UPDATE event_queue
SET status = CASE
    WHEN status IN ('executed', 'collapsed') THEN status
    ELSE 'sent'
END,
sent_at = CASE
    WHEN status IN ('executed', 'collapsed') THEN sent_at
    ELSE NOW()
END
WHERE event_id = ? AND status = 'pending'
`

func (q *Queries) MarkEventSentOrStatus(ctx context.Context, eventID string) error {
	_, err := q.db.ExecContext(ctx, markEventSentOrStatus, eventID)
	return err
}
