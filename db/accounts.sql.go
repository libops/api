// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const cleanupExpiredVerificationTokens = `-- name: CleanupExpiredVerificationTokens :exec
DELETE FROM email_verification_tokens
WHERE expires_at < NOW()
`

func (q *Queries) CleanupExpiredVerificationTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredVerificationTokens)
	return err
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO accounts (
  public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id, auth_method, verified, verified_at, created_at, updated_at
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
`

type CreateAccountParams struct {
	Email          string             `json:"email"`
	Name           sql.NullString     `json:"name"`
	GithubUsername sql.NullString     `json:"github_username"`
	VaultEntityID  sql.NullString     `json:"vault_entity_id"`
	AuthMethod     AccountsAuthMethod `json:"auth_method"`
	Verified       bool               `json:"verified"`
	VerifiedAt     sql.NullTime       `json:"verified_at"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount,
		arg.Email,
		arg.Name,
		arg.GithubUsername,
		arg.VaultEntityID,
		arg.AuthMethod,
		arg.Verified,
		arg.VerifiedAt,
	)
	return err
}

const createEmailVerificationToken = `-- name: CreateEmailVerificationToken :exec
INSERT INTO email_verification_tokens (
    email,
    token,
    password_hash,
    expires_at
) VALUES (?, ?, ?, ?)
`

type CreateEmailVerificationTokenParams struct {
	Email        string    `json:"email"`
	Token        string    `json:"token"`
	PasswordHash string    `json:"password_hash"`
	ExpiresAt    time.Time `json:"expires_at"`
}

func (q *Queries) CreateEmailVerificationToken(ctx context.Context, arg CreateEmailVerificationTokenParams) error {
	_, err := q.db.ExecContext(ctx, createEmailVerificationToken,
		arg.Email,
		arg.Token,
		arg.PasswordHash,
		arg.ExpiresAt,
	)
	return err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteAccount(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteAccount, publicID)
	return err
}

const deleteEmailVerificationToken = `-- name: DeleteEmailVerificationToken :exec
DELETE FROM email_verification_tokens
WHERE email = ?
`

func (q *Queries) DeleteEmailVerificationToken(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deleteEmailVerificationToken, email)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id,
       auth_method, verified, verified_at, onboarding_completed, onboarding_session_id, created_at, updated_at
FROM accounts WHERE public_id = UUID_TO_BIN(?)
`

type GetAccountRow struct {
	ID                  int64              `json:"id"`
	PublicID            string             `json:"public_id"`
	Email               string             `json:"email"`
	Name                sql.NullString     `json:"name"`
	GithubUsername      sql.NullString     `json:"github_username"`
	VaultEntityID       sql.NullString     `json:"vault_entity_id"`
	AuthMethod          AccountsAuthMethod `json:"auth_method"`
	Verified            bool               `json:"verified"`
	VerifiedAt          sql.NullTime       `json:"verified_at"`
	OnboardingCompleted bool               `json:"onboarding_completed"`
	OnboardingSessionID sql.NullString     `json:"onboarding_session_id"`
	CreatedAt           sql.NullTime       `json:"created_at"`
	UpdatedAt           sql.NullTime       `json:"updated_at"`
}

func (q *Queries) GetAccount(ctx context.Context, publicID string) (GetAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getAccount, publicID)
	var i GetAccountRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Email,
		&i.Name,
		&i.GithubUsername,
		&i.VaultEntityID,
		&i.AuthMethod,
		&i.Verified,
		&i.VerifiedAt,
		&i.OnboardingCompleted,
		&i.OnboardingSessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByEmail = `-- name: GetAccountByEmail :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id,
       auth_method, verified, verified_at, failed_login_attempts, last_failed_login_at,
       onboarding_completed, onboarding_session_id, created_at, updated_at
FROM accounts WHERE email = ?
`

type GetAccountByEmailRow struct {
	ID                  int64              `json:"id"`
	PublicID            string             `json:"public_id"`
	Email               string             `json:"email"`
	Name                sql.NullString     `json:"name"`
	GithubUsername      sql.NullString     `json:"github_username"`
	VaultEntityID       sql.NullString     `json:"vault_entity_id"`
	AuthMethod          AccountsAuthMethod `json:"auth_method"`
	Verified            bool               `json:"verified"`
	VerifiedAt          sql.NullTime       `json:"verified_at"`
	FailedLoginAttempts int32              `json:"failed_login_attempts"`
	LastFailedLoginAt   sql.NullTime       `json:"last_failed_login_at"`
	OnboardingCompleted bool               `json:"onboarding_completed"`
	OnboardingSessionID sql.NullString     `json:"onboarding_session_id"`
	CreatedAt           sql.NullTime       `json:"created_at"`
	UpdatedAt           sql.NullTime       `json:"updated_at"`
}

func (q *Queries) GetAccountByEmail(ctx context.Context, email string) (GetAccountByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountByEmail, email)
	var i GetAccountByEmailRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Email,
		&i.Name,
		&i.GithubUsername,
		&i.VaultEntityID,
		&i.AuthMethod,
		&i.Verified,
		&i.VerifiedAt,
		&i.FailedLoginAttempts,
		&i.LastFailedLoginAt,
		&i.OnboardingCompleted,
		&i.OnboardingSessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id,
       auth_method, verified, verified_at, onboarding_completed, onboarding_session_id, created_at, updated_at
FROM accounts WHERE id = ?
`

type GetAccountByIDRow struct {
	ID                  int64              `json:"id"`
	PublicID            string             `json:"public_id"`
	Email               string             `json:"email"`
	Name                sql.NullString     `json:"name"`
	GithubUsername      sql.NullString     `json:"github_username"`
	VaultEntityID       sql.NullString     `json:"vault_entity_id"`
	AuthMethod          AccountsAuthMethod `json:"auth_method"`
	Verified            bool               `json:"verified"`
	VerifiedAt          sql.NullTime       `json:"verified_at"`
	OnboardingCompleted bool               `json:"onboarding_completed"`
	OnboardingSessionID sql.NullString     `json:"onboarding_session_id"`
	CreatedAt           sql.NullTime       `json:"created_at"`
	UpdatedAt           sql.NullTime       `json:"updated_at"`
}

func (q *Queries) GetAccountByID(ctx context.Context, id int64) (GetAccountByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountByID, id)
	var i GetAccountByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Email,
		&i.Name,
		&i.GithubUsername,
		&i.VaultEntityID,
		&i.AuthMethod,
		&i.Verified,
		&i.VerifiedAt,
		&i.OnboardingCompleted,
		&i.OnboardingSessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByVaultEntityID = `-- name: GetAccountByVaultEntityID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, email, ` + "`" + `name` + "`" + `, github_username, vault_entity_id,
       auth_method, verified, verified_at, onboarding_completed, onboarding_session_id, created_at, updated_at
FROM accounts WHERE vault_entity_id = ?
`

type GetAccountByVaultEntityIDRow struct {
	ID                  int64              `json:"id"`
	PublicID            string             `json:"public_id"`
	Email               string             `json:"email"`
	Name                sql.NullString     `json:"name"`
	GithubUsername      sql.NullString     `json:"github_username"`
	VaultEntityID       sql.NullString     `json:"vault_entity_id"`
	AuthMethod          AccountsAuthMethod `json:"auth_method"`
	Verified            bool               `json:"verified"`
	VerifiedAt          sql.NullTime       `json:"verified_at"`
	OnboardingCompleted bool               `json:"onboarding_completed"`
	OnboardingSessionID sql.NullString     `json:"onboarding_session_id"`
	CreatedAt           sql.NullTime       `json:"created_at"`
	UpdatedAt           sql.NullTime       `json:"updated_at"`
}

func (q *Queries) GetAccountByVaultEntityID(ctx context.Context, vaultEntityID sql.NullString) (GetAccountByVaultEntityIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountByVaultEntityID, vaultEntityID)
	var i GetAccountByVaultEntityIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Email,
		&i.Name,
		&i.GithubUsername,
		&i.VaultEntityID,
		&i.AuthMethod,
		&i.Verified,
		&i.VerifiedAt,
		&i.OnboardingCompleted,
		&i.OnboardingSessionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmailVerificationToken = `-- name: GetEmailVerificationToken :one
SELECT id, email, token, password_hash, created_at, expires_at
FROM email_verification_tokens
WHERE email = ? AND token = ?
  AND expires_at > NOW()
`

type GetEmailVerificationTokenParams struct {
	Email string `json:"email"`
	Token string `json:"token"`
}

func (q *Queries) GetEmailVerificationToken(ctx context.Context, arg GetEmailVerificationTokenParams) (EmailVerificationToken, error) {
	row := q.db.QueryRowContext(ctx, getEmailVerificationToken, arg.Email, arg.Token)
	var i EmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Token,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getEmailVerificationTokenByEmail = `-- name: GetEmailVerificationTokenByEmail :one
SELECT id, email, token, password_hash, created_at, expires_at
FROM email_verification_tokens
WHERE email = ?
  AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetEmailVerificationTokenByEmail(ctx context.Context, email string) (EmailVerificationToken, error) {
	row := q.db.QueryRowContext(ctx, getEmailVerificationTokenByEmail, email)
	var i EmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Token,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getOnboardingSessionByAccountID = `-- name: GetOnboardingSessionByAccountID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, account_id, org_name,
       CASE WHEN organization_public_id IS NULL THEN NULL ELSE BIN_TO_UUID(organization_public_id) END AS organization_public_id,
       machine_type, machine_price_id, disk_size_gb,
       stripe_checkout_session_id, stripe_checkout_url, stripe_subscription_id, organization_id,
       project_name, gcp_country, gcp_region, site_name, github_repo_url, port, firewall_ip,
       current_step, completed, expires_at, created_at, updated_at
FROM onboarding_sessions WHERE account_id = ? AND completed = FALSE ORDER BY created_at DESC LIMIT 1
`

type GetOnboardingSessionByAccountIDRow struct {
	ID                      int64          `json:"id"`
	PublicID                string         `json:"public_id"`
	AccountID               int64          `json:"account_id"`
	OrgName                 sql.NullString `json:"org_name"`
	OrganizationPublicID    interface{}    `json:"organization_public_id"`
	MachineType             sql.NullString `json:"machine_type"`
	MachinePriceID          sql.NullString `json:"machine_price_id"`
	DiskSizeGb              sql.NullInt32  `json:"disk_size_gb"`
	StripeCheckoutSessionID sql.NullString `json:"stripe_checkout_session_id"`
	StripeCheckoutUrl       sql.NullString `json:"stripe_checkout_url"`
	StripeSubscriptionID    sql.NullString `json:"stripe_subscription_id"`
	OrganizationID          sql.NullInt64  `json:"organization_id"`
	ProjectName             sql.NullString `json:"project_name"`
	GcpCountry              sql.NullString `json:"gcp_country"`
	GcpRegion               sql.NullString `json:"gcp_region"`
	SiteName                sql.NullString `json:"site_name"`
	GithubRepoUrl           sql.NullString `json:"github_repo_url"`
	Port                    sql.NullInt32  `json:"port"`
	FirewallIp              sql.NullString `json:"firewall_ip"`
	CurrentStep             sql.NullInt32  `json:"current_step"`
	Completed               sql.NullBool   `json:"completed"`
	ExpiresAt               sql.NullTime   `json:"expires_at"`
	CreatedAt               sql.NullTime   `json:"created_at"`
	UpdatedAt               sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetOnboardingSessionByAccountID(ctx context.Context, accountID int64) (GetOnboardingSessionByAccountIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOnboardingSessionByAccountID, accountID)
	var i GetOnboardingSessionByAccountIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.AccountID,
		&i.OrgName,
		&i.OrganizationPublicID,
		&i.MachineType,
		&i.MachinePriceID,
		&i.DiskSizeGb,
		&i.StripeCheckoutSessionID,
		&i.StripeCheckoutUrl,
		&i.StripeSubscriptionID,
		&i.OrganizationID,
		&i.ProjectName,
		&i.GcpCountry,
		&i.GcpRegion,
		&i.SiteName,
		&i.GithubRepoUrl,
		&i.Port,
		&i.FirewallIp,
		&i.CurrentStep,
		&i.Completed,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectMemberByAccountAndProject = `-- name: GetProjectMemberByAccountAndProject :one


SELECT id, public_id, project_id, account_id, role, status, created_at, updated_at, created_by, updated_by FROM project_members
WHERE account_id = ? AND project_id = ? AND status = 'active'
`

type GetProjectMemberByAccountAndProjectParams struct {
	AccountID int64 `json:"account_id"`
	ProjectID int64 `json:"project_id"`
}

// =============================================================================
// ORGANIZATION SECRETS
// =============================================================================
func (q *Queries) GetProjectMemberByAccountAndProject(ctx context.Context, arg GetProjectMemberByAccountAndProjectParams) (ProjectMember, error) {
	row := q.db.QueryRowContext(ctx, getProjectMemberByAccountAndProject, arg.AccountID, arg.ProjectID)
	var i ProjectMember
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.AccountID,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteMemberByAccountAndSite = `-- name: GetSiteMemberByAccountAndSite :one
SELECT id, public_id, site_id, account_id, role, status, created_at, updated_at, created_by, updated_by FROM site_members
WHERE account_id = ? AND site_id = ? AND status = 'active'
`

type GetSiteMemberByAccountAndSiteParams struct {
	AccountID int64 `json:"account_id"`
	SiteID    int64 `json:"site_id"`
}

func (q *Queries) GetSiteMemberByAccountAndSite(ctx context.Context, arg GetSiteMemberByAccountAndSiteParams) (SiteMember, error) {
	row := q.db.QueryRowContext(ctx, getSiteMemberByAccountAndSite, arg.AccountID, arg.SiteID)
	var i SiteMember
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.AccountID,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const incrementFailedLoginAttempts = `-- name: IncrementFailedLoginAttempts :exec
UPDATE accounts SET
  failed_login_attempts = failed_login_attempts + 1,
  last_failed_login_at = NOW()
WHERE id = ?
`

func (q *Queries) IncrementFailedLoginAttempts(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementFailedLoginAttempts, id)
	return err
}

const listAPIKeysByAccount = `-- name: ListAPIKeysByAccount :many


SELECT id, BIN_TO_UUID(public_id) AS public_id, account_id, ` + "`" + `name` + "`" + `, description,
       COALESCE(scopes, '[]') as scopes,
       created_at, last_used_at, expires_at, active, created_by
FROM api_keys
WHERE account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAPIKeysByAccountParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListAPIKeysByAccountRow struct {
	ID          int64           `json:"id"`
	PublicID    string          `json:"public_id"`
	AccountID   int64           `json:"account_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Scopes      json.RawMessage `json:"scopes"`
	CreatedAt   sql.NullTime    `json:"created_at"`
	LastUsedAt  sql.NullTime    `json:"last_used_at"`
	ExpiresAt   sql.NullTime    `json:"expires_at"`
	Active      bool            `json:"active"`
	CreatedBy   sql.NullInt64   `json:"created_by"`
}

// =============================================================================
// API KEYS
// =============================================================================
func (q *Queries) ListAPIKeysByAccount(ctx context.Context, arg ListAPIKeysByAccountParams) ([]ListAPIKeysByAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listAPIKeysByAccount, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAPIKeysByAccountRow{}
	for rows.Next() {
		var i ListAPIKeysByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.AccountID,
			&i.Name,
			&i.Description,
			&i.Scopes,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.ExpiresAt,
			&i.Active,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountProjects = `-- name: ListAccountProjects :many
SELECT p.id, BIN_TO_UUID(p.public_id) AS public_id, p.` + "`" + `name` + "`" + `, pm.` + "`" + `role` + "`" + `
FROM project_members pm
JOIN projects p ON pm.project_id = p.id
WHERE pm.account_id = ?
ORDER BY p.created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountProjectsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListAccountProjectsRow struct {
	ID       int64              `json:"id"`
	PublicID string             `json:"public_id"`
	Name     string             `json:"name"`
	Role     ProjectMembersRole `json:"role"`
}

func (q *Queries) ListAccountProjects(ctx context.Context, arg ListAccountProjectsParams) ([]ListAccountProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccountProjects, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountProjectsRow{}
	for rows.Next() {
		var i ListAccountProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountSites = `-- name: ListAccountSites :many


SELECT s.id, BIN_TO_UUID(s.public_id) AS public_id, s.` + "`" + `name` + "`" + `, sm.` + "`" + `role` + "`" + `
FROM site_members sm
JOIN sites s ON sm.site_id = s.id
WHERE sm.account_id = ?
ORDER BY s.created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountSitesParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListAccountSitesRow struct {
	ID       int64           `json:"id"`
	PublicID string          `json:"public_id"`
	Name     string          `json:"name"`
	Role     SiteMembersRole `json:"role"`
}

// =============================================================================
// MACHINE TYPES
// =============================================================================
func (q *Queries) ListAccountSites(ctx context.Context, arg ListAccountSitesParams) ([]ListAccountSitesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccountSites, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountSitesRow{}
	for rows.Next() {
		var i ListAccountSitesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountSshAccess = `-- name: ListAccountSshAccess :many


SELECT id, account_id, site_id, created_at, updated_at, created_by, updated_by FROM ssh_access
WHERE account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountSshAccessParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

// =============================================================================
// DOMAINS
// =============================================================================
func (q *Queries) ListAccountSshAccess(ctx context.Context, arg ListAccountSshAccessParams) ([]SshAccess, error) {
	rows, err := q.db.QueryContext(ctx, listAccountSshAccess, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SshAccess{}
	for rows.Next() {
		var i SshAccess
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SiteID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, email, name, github_username, vault_entity_id, auth_method, verified, verified_at, failed_login_attempts, last_failed_login_at, created_at, updated_at
FROM accounts
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAccountsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAccountsRow struct {
	ID                  int64              `json:"id"`
	PublicID            string             `json:"public_id"`
	Email               string             `json:"email"`
	Name                sql.NullString     `json:"name"`
	GithubUsername      sql.NullString     `json:"github_username"`
	VaultEntityID       sql.NullString     `json:"vault_entity_id"`
	AuthMethod          AccountsAuthMethod `json:"auth_method"`
	Verified            bool               `json:"verified"`
	VerifiedAt          sql.NullTime       `json:"verified_at"`
	FailedLoginAttempts int32              `json:"failed_login_attempts"`
	LastFailedLoginAt   sql.NullTime       `json:"last_failed_login_at"`
	CreatedAt           sql.NullTime       `json:"created_at"`
	UpdatedAt           sql.NullTime       `json:"updated_at"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]ListAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountsRow{}
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
			&i.VaultEntityID,
			&i.AuthMethod,
			&i.Verified,
			&i.VerifiedAt,
			&i.FailedLoginAttempts,
			&i.LastFailedLoginAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSshKeysByAccount = `-- name: ListSshKeysByAccount :many
SELECT sk.id, BIN_TO_UUID(sk.public_id) AS public_id,
       BIN_TO_UUID(a.public_id) AS account_public_id,
       sk.public_key, sk.` + "`" + `name` + "`" + `, sk.fingerprint,
       sk.created_at, sk.updated_at
FROM ssh_keys sk
JOIN accounts a ON sk.account_id = a.id
WHERE a.public_id = UUID_TO_BIN(?)
ORDER BY sk.created_at DESC
`

type ListSshKeysByAccountRow struct {
	ID              int64          `json:"id"`
	PublicID        string         `json:"public_id"`
	AccountPublicID string         `json:"account_public_id"`
	PublicKey       string         `json:"public_key"`
	Name            sql.NullString `json:"name"`
	Fingerprint     sql.NullString `json:"fingerprint"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
}

func (q *Queries) ListSshKeysByAccount(ctx context.Context, publicID string) ([]ListSshKeysByAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listSshKeysByAccount, publicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSshKeysByAccountRow{}
	for rows.Next() {
		var i ListSshKeysByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.AccountPublicID,
			&i.PublicKey,
			&i.Name,
			&i.Fingerprint,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetFailedLoginAttempts = `-- name: ResetFailedLoginAttempts :exec
UPDATE accounts SET
  failed_login_attempts = 0
WHERE id = ?
`

func (q *Queries) ResetFailedLoginAttempts(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, resetFailedLoginAttempts, id)
	return err
}

const updateAccount = `-- name: UpdateAccount :exec
UPDATE accounts SET
  email = ?,
  ` + "`" + `name` + "`" + ` = ?,
  github_username = ?,
  vault_entity_id = ?,
  auth_method = ?,
  verified = ?,
  verified_at = ?,
  updated_at = NOW()
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateAccountParams struct {
	Email          string             `json:"email"`
	Name           sql.NullString     `json:"name"`
	GithubUsername sql.NullString     `json:"github_username"`
	VaultEntityID  sql.NullString     `json:"vault_entity_id"`
	AuthMethod     AccountsAuthMethod `json:"auth_method"`
	Verified       bool               `json:"verified"`
	VerifiedAt     sql.NullTime       `json:"verified_at"`
	PublicID       string             `json:"public_id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) error {
	_, err := q.db.ExecContext(ctx, updateAccount,
		arg.Email,
		arg.Name,
		arg.GithubUsername,
		arg.VaultEntityID,
		arg.AuthMethod,
		arg.Verified,
		arg.VerifiedAt,
		arg.PublicID,
	)
	return err
}

const updateAccountOnboarding = `-- name: UpdateAccountOnboarding :exec
UPDATE accounts SET
  onboarding_completed = ?,
  onboarding_session_id = ?,
  updated_at = NOW()
WHERE id = ?
`

type UpdateAccountOnboardingParams struct {
	OnboardingCompleted bool           `json:"onboarding_completed"`
	OnboardingSessionID sql.NullString `json:"onboarding_session_id"`
	ID                  int64          `json:"id"`
}

func (q *Queries) UpdateAccountOnboarding(ctx context.Context, arg UpdateAccountOnboardingParams) error {
	_, err := q.db.ExecContext(ctx, updateAccountOnboarding, arg.OnboardingCompleted, arg.OnboardingSessionID, arg.ID)
	return err
}
