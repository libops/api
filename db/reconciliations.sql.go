// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reconciliations.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/libops/api/db/types"
)

const appendEventIDsToRun = `-- name: AppendEventIDsToRun :exec
UPDATE reconciliations
SET event_ids = JSON_ARRAY_APPEND(event_ids, '$', ?),
    last_event_at = ?
WHERE run_id = ?
`

type AppendEventIDsToRunParams struct {
	JSONARRAYAPPEND interface{} `json:"JSON_ARRAY_APPEND"`
	LastEventAt     time.Time   `json:"last_event_at"`
	RunID           string      `json:"run_id"`
}

func (q *Queries) AppendEventIDsToRun(ctx context.Context, arg AppendEventIDsToRunParams) error {
	_, err := q.db.ExecContext(ctx, appendEventIDsToRun, arg.JSONARRAYAPPEND, arg.LastEventAt, arg.RunID)
	return err
}

const clearStaleLocks = `-- name: ClearStaleLocks :execresult
UPDATE reconciliations
SET status = 'failed',
    error_message = 'Lock expired after 30 minutes',
    completed_at = CURRENT_TIMESTAMP
WHERE status = 'running'
  AND started_at < NOW() - INTERVAL 30 MINUTE
`

func (q *Queries) ClearStaleLocks(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, clearStaleLocks)
}

const createReconciliationResult = `-- name: CreateReconciliationResult :execresult

INSERT INTO reconciliation_results (
    run_id,
    result_type,
    module_type,
    site_id,
    resource_id,
    status,
    output,
    error_message,
    started_at,
    completed_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateReconciliationResultParams struct {
	RunID        string                          `json:"run_id"`
	ResultType   ReconciliationResultsResultType `json:"result_type"`
	ModuleType   sql.NullString                  `json:"module_type"`
	SiteID       sql.NullInt64                   `json:"site_id"`
	ResourceID   sql.NullInt64                   `json:"resource_id"`
	Status       ReconciliationResultsStatus     `json:"status"`
	Output       sql.NullString                  `json:"output"`
	ErrorMessage sql.NullString                  `json:"error_message"`
	StartedAt    time.Time                       `json:"started_at"`
	CompletedAt  time.Time                       `json:"completed_at"`
}

// Reconciliation result queries
func (q *Queries) CreateReconciliationResult(ctx context.Context, arg CreateReconciliationResultParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createReconciliationResult,
		arg.RunID,
		arg.ResultType,
		arg.ModuleType,
		arg.SiteID,
		arg.ResourceID,
		arg.Status,
		arg.Output,
		arg.ErrorMessage,
		arg.StartedAt,
		arg.CompletedAt,
	)
}

const createReconciliationRun = `-- name: CreateReconciliationRun :execresult

INSERT INTO reconciliations (
    run_id,
    organization_id,
    project_id,
    site_id,
    run_type,
    reconciliation_type,
    modules,
    target_site_ids,
    event_ids,
    first_event_at,
    last_event_at,
    status
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending')
`

type CreateReconciliationRunParams struct {
	RunID              string                                `json:"run_id"`
	OrganizationID     sql.NullInt64                         `json:"organization_id"`
	ProjectID          sql.NullInt64                         `json:"project_id"`
	SiteID             sql.NullInt64                         `json:"site_id"`
	RunType            ReconciliationsRunType                `json:"run_type"`
	ReconciliationType NullReconciliationsReconciliationType `json:"reconciliation_type"`
	Modules            types.RawJSON                         `json:"modules"`
	TargetSiteIds      types.RawJSON                         `json:"target_site_ids"`
	EventIds           json.RawMessage                       `json:"event_ids"`
	FirstEventAt       time.Time                             `json:"first_event_at"`
	LastEventAt        time.Time                             `json:"last_event_at"`
}

// Reconciliation run queries (supports both terraform and VM reconciliation)
func (q *Queries) CreateReconciliationRun(ctx context.Context, arg CreateReconciliationRunParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createReconciliationRun,
		arg.RunID,
		arg.OrganizationID,
		arg.ProjectID,
		arg.SiteID,
		arg.RunType,
		arg.ReconciliationType,
		arg.Modules,
		arg.TargetSiteIds,
		arg.EventIds,
		arg.FirstEventAt,
		arg.LastEventAt,
	)
}

const getPendingReconciliationRunByOrg = `-- name: GetPendingReconciliationRunByOrg :one
SELECT id, run_id, organization_id, project_id, site_id, run_type, reconciliation_type, modules, target_site_ids, event_ids, first_event_at, last_event_at, status, error_message, created_at, triggered_at, started_at, completed_at FROM reconciliations
WHERE organization_id = ? AND status IN ('pending', 'running')
LIMIT 1
`

func (q *Queries) GetPendingReconciliationRunByOrg(ctx context.Context, organizationID sql.NullInt64) (Reconciliation, error) {
	row := q.db.QueryRowContext(ctx, getPendingReconciliationRunByOrg, organizationID)
	var i Reconciliation
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.SiteID,
		&i.RunType,
		&i.ReconciliationType,
		&i.Modules,
		&i.TargetSiteIds,
		&i.EventIds,
		&i.FirstEventAt,
		&i.LastEventAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.TriggeredAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getPendingReconciliationRunByProject = `-- name: GetPendingReconciliationRunByProject :one
SELECT id, run_id, organization_id, project_id, site_id, run_type, reconciliation_type, modules, target_site_ids, event_ids, first_event_at, last_event_at, status, error_message, created_at, triggered_at, started_at, completed_at FROM reconciliations
WHERE project_id = ? AND status IN ('pending', 'running')
LIMIT 1
`

func (q *Queries) GetPendingReconciliationRunByProject(ctx context.Context, projectID sql.NullInt64) (Reconciliation, error) {
	row := q.db.QueryRowContext(ctx, getPendingReconciliationRunByProject, projectID)
	var i Reconciliation
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.SiteID,
		&i.RunType,
		&i.ReconciliationType,
		&i.Modules,
		&i.TargetSiteIds,
		&i.EventIds,
		&i.FirstEventAt,
		&i.LastEventAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.TriggeredAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getPendingReconciliationRunByResource = `-- name: GetPendingReconciliationRunByResource :one
SELECT id, run_id, organization_id, project_id, site_id, run_type, reconciliation_type, modules, target_site_ids, event_ids, first_event_at, last_event_at, status, error_message, created_at, triggered_at, started_at, completed_at FROM reconciliations
WHERE organization_id = COALESCE(?, organization_id)
  AND project_id = COALESCE(?, project_id)
  AND site_id = COALESCE(?, site_id)
  AND status IN ('pending', 'running')
LIMIT 1
`

type GetPendingReconciliationRunByResourceParams struct {
	OrganizationID sql.NullInt64 `json:"organization_id"`
	ProjectID      sql.NullInt64 `json:"project_id"`
	SiteID         sql.NullInt64 `json:"site_id"`
}

func (q *Queries) GetPendingReconciliationRunByResource(ctx context.Context, arg GetPendingReconciliationRunByResourceParams) (Reconciliation, error) {
	row := q.db.QueryRowContext(ctx, getPendingReconciliationRunByResource, arg.OrganizationID, arg.ProjectID, arg.SiteID)
	var i Reconciliation
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.SiteID,
		&i.RunType,
		&i.ReconciliationType,
		&i.Modules,
		&i.TargetSiteIds,
		&i.EventIds,
		&i.FirstEventAt,
		&i.LastEventAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.TriggeredAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getPendingReconciliationRunBySite = `-- name: GetPendingReconciliationRunBySite :one
SELECT id, run_id, organization_id, project_id, site_id, run_type, reconciliation_type, modules, target_site_ids, event_ids, first_event_at, last_event_at, status, error_message, created_at, triggered_at, started_at, completed_at FROM reconciliations
WHERE site_id = ? AND status IN ('pending', 'running')
LIMIT 1
`

func (q *Queries) GetPendingReconciliationRunBySite(ctx context.Context, siteID sql.NullInt64) (Reconciliation, error) {
	row := q.db.QueryRowContext(ctx, getPendingReconciliationRunBySite, siteID)
	var i Reconciliation
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.SiteID,
		&i.RunType,
		&i.ReconciliationType,
		&i.Modules,
		&i.TargetSiteIds,
		&i.EventIds,
		&i.FirstEventAt,
		&i.LastEventAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.TriggeredAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getReconciliationResults = `-- name: GetReconciliationResults :many
SELECT id, run_id, result_type, module_type, site_id, resource_id, status, output, error_message, started_at, completed_at FROM reconciliation_results
WHERE run_id = ?
ORDER BY started_at ASC
`

func (q *Queries) GetReconciliationResults(ctx context.Context, runID string) ([]ReconciliationResult, error) {
	rows, err := q.db.QueryContext(ctx, getReconciliationResults, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReconciliationResult{}
	for rows.Next() {
		var i ReconciliationResult
		if err := rows.Scan(
			&i.ID,
			&i.RunID,
			&i.ResultType,
			&i.ModuleType,
			&i.SiteID,
			&i.ResourceID,
			&i.Status,
			&i.Output,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReconciliationResultsBySite = `-- name: GetReconciliationResultsBySite :many
SELECT id, run_id, result_type, module_type, site_id, resource_id, status, output, error_message, started_at, completed_at FROM reconciliation_results
WHERE run_id = ? AND site_id = ?
ORDER BY started_at ASC
`

type GetReconciliationResultsBySiteParams struct {
	RunID  string        `json:"run_id"`
	SiteID sql.NullInt64 `json:"site_id"`
}

func (q *Queries) GetReconciliationResultsBySite(ctx context.Context, arg GetReconciliationResultsBySiteParams) ([]ReconciliationResult, error) {
	rows, err := q.db.QueryContext(ctx, getReconciliationResultsBySite, arg.RunID, arg.SiteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReconciliationResult{}
	for rows.Next() {
		var i ReconciliationResult
		if err := rows.Scan(
			&i.ID,
			&i.RunID,
			&i.ResultType,
			&i.ModuleType,
			&i.SiteID,
			&i.ResourceID,
			&i.Status,
			&i.Output,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReconciliationRunByID = `-- name: GetReconciliationRunByID :one
SELECT id, run_id, organization_id, project_id, site_id, run_type, reconciliation_type, modules, target_site_ids, event_ids, first_event_at, last_event_at, status, error_message, created_at, triggered_at, started_at, completed_at FROM reconciliations
WHERE run_id = ?
LIMIT 1
`

func (q *Queries) GetReconciliationRunByID(ctx context.Context, runID string) (Reconciliation, error) {
	row := q.db.QueryRowContext(ctx, getReconciliationRunByID, runID)
	var i Reconciliation
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.SiteID,
		&i.RunType,
		&i.ReconciliationType,
		&i.Modules,
		&i.TargetSiteIds,
		&i.EventIds,
		&i.FirstEventAt,
		&i.LastEventAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.TriggeredAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getRunningReconciliations = `-- name: GetRunningReconciliations :many
SELECT run_id, organization_id, project_id, site_id, run_type
FROM reconciliations
WHERE status IN ('pending', 'running')
ORDER BY
  CASE
    WHEN organization_id IS NOT NULL AND project_id IS NULL AND site_id IS NULL THEN 1
    WHEN project_id IS NOT NULL AND site_id IS NULL THEN 2
    WHEN site_id IS NOT NULL THEN 3
  END ASC
LIMIT 1
`

type GetRunningReconciliationsRow struct {
	RunID          string                 `json:"run_id"`
	OrganizationID sql.NullInt64          `json:"organization_id"`
	ProjectID      sql.NullInt64          `json:"project_id"`
	SiteID         sql.NullInt64          `json:"site_id"`
	RunType        ReconciliationsRunType `json:"run_type"`
}

func (q *Queries) GetRunningReconciliations(ctx context.Context) ([]GetRunningReconciliationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRunningReconciliations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRunningReconciliationsRow{}
	for rows.Next() {
		var i GetRunningReconciliationsRow
		if err := rows.Scan(
			&i.RunID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.SiteID,
			&i.RunType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiteIDsByOrganization = `-- name: GetSiteIDsByOrganization :many
SELECT s.id FROM sites s
JOIN projects p ON s.project_id = p.id
WHERE p.organization_id = ?
  AND s.gcp_external_ip IS NOT NULL
  AND s.checkin_at > NOW() - INTERVAL 15 MINUTE
`

func (q *Queries) GetSiteIDsByOrganization(ctx context.Context, organizationID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getSiteIDsByOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiteIDsByProject = `-- name: GetSiteIDsByProject :many
SELECT id FROM sites
WHERE project_id = ?
  AND gcp_external_ip IS NOT NULL
  AND checkin_at > NOW() - INTERVAL 15 MINUTE
`

func (q *Queries) GetSiteIDsByProject(ctx context.Context, projectID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getSiteIDsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiteIDsBySite = `-- name: GetSiteIDsBySite :many
SELECT id FROM sites
WHERE id = ?
  AND gcp_external_ip IS NOT NULL
  AND checkin_at > NOW() - INTERVAL 15 MINUTE
`

func (q *Queries) GetSiteIDsBySite(ctx context.Context, id int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getSiteIDsBySite, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleReconciliationRuns = `-- name: GetStaleReconciliationRuns :many
SELECT id, run_id, organization_id, project_id, site_id, run_type, reconciliation_type, modules, target_site_ids, event_ids, first_event_at, last_event_at, status, error_message, created_at, triggered_at, started_at, completed_at FROM reconciliations
WHERE status = 'running'
  AND started_at < NOW() - INTERVAL 30 MINUTE
`

func (q *Queries) GetStaleReconciliationRuns(ctx context.Context) ([]Reconciliation, error) {
	rows, err := q.db.QueryContext(ctx, getStaleReconciliationRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reconciliation{}
	for rows.Next() {
		var i Reconciliation
		if err := rows.Scan(
			&i.ID,
			&i.RunID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.SiteID,
			&i.RunType,
			&i.ReconciliationType,
			&i.Modules,
			&i.TargetSiteIds,
			&i.EventIds,
			&i.FirstEventAt,
			&i.LastEventAt,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.TriggeredAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReconciliationRunCompleted = `-- name: UpdateReconciliationRunCompleted :exec
UPDATE reconciliations
SET status = 'completed',
    completed_at = CURRENT_TIMESTAMP
WHERE run_id = ?
`

func (q *Queries) UpdateReconciliationRunCompleted(ctx context.Context, runID string) error {
	_, err := q.db.ExecContext(ctx, updateReconciliationRunCompleted, runID)
	return err
}

const updateReconciliationRunFailed = `-- name: UpdateReconciliationRunFailed :exec
UPDATE reconciliations
SET status = 'failed',
    completed_at = CURRENT_TIMESTAMP,
    error_message = ?
WHERE run_id = ?
`

type UpdateReconciliationRunFailedParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	RunID        string         `json:"run_id"`
}

func (q *Queries) UpdateReconciliationRunFailed(ctx context.Context, arg UpdateReconciliationRunFailedParams) error {
	_, err := q.db.ExecContext(ctx, updateReconciliationRunFailed, arg.ErrorMessage, arg.RunID)
	return err
}

const updateReconciliationRunStarted = `-- name: UpdateReconciliationRunStarted :exec
UPDATE reconciliations
SET status = 'running',
    started_at = CURRENT_TIMESTAMP
WHERE run_id = ?
`

func (q *Queries) UpdateReconciliationRunStarted(ctx context.Context, runID string) error {
	_, err := q.db.ExecContext(ctx, updateReconciliationRunStarted, runID)
	return err
}

const updateReconciliationRunStatus = `-- name: UpdateReconciliationRunStatus :exec
UPDATE reconciliations
SET status = CAST(? AS CHAR),
    triggered_at = CASE WHEN ? = 'triggered' THEN CURRENT_TIMESTAMP ELSE triggered_at END,
    started_at = CASE WHEN ? = 'running' THEN CURRENT_TIMESTAMP ELSE started_at END,
    completed_at = CASE WHEN sqlc.arg(status) IN ('completed', 'failed') THEN CURRENT_TIMESTAMP ELSE completed_at END,
    error_message = ?
WHERE run_id = ?
`

type UpdateReconciliationRunStatusParams struct {
	Status       interface{}    `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	RunID        string         `json:"run_id"`
}

func (q *Queries) UpdateReconciliationRunStatus(ctx context.Context, arg UpdateReconciliationRunStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateReconciliationRunStatus,
		arg.Status,
		arg.Status,
		arg.Status,
		arg.ErrorMessage,
		arg.RunID,
	)
	return err
}

const updateReconciliationRunTriggered = `-- name: UpdateReconciliationRunTriggered :exec
UPDATE reconciliations
SET status = 'triggered',
    triggered_at = CURRENT_TIMESTAMP
WHERE run_id = ?
`

func (q *Queries) UpdateReconciliationRunTriggered(ctx context.Context, runID string) error {
	_, err := q.db.ExecContext(ctx, updateReconciliationRunTriggered, runID)
	return err
}

const upgradeReconciliationRunScope = `-- name: UpgradeReconciliationRunScope :exec
UPDATE reconciliations
SET organization_id = COALESCE(?, organization_id),
    project_id = COALESCE(?, project_id),
    site_id = COALESCE(?, site_id),
    modules = COALESCE(?, modules),
    target_site_ids = COALESCE(?, target_site_ids),
    event_ids = JSON_ARRAY_APPEND(event_ids, '$', ?),
    last_event_at = ?
WHERE run_id = ?
`

type UpgradeReconciliationRunScopeParams struct {
	OrganizationID  sql.NullInt64 `json:"organization_id"`
	ProjectID       sql.NullInt64 `json:"project_id"`
	SiteID          sql.NullInt64 `json:"site_id"`
	Modules         types.RawJSON `json:"modules"`
	TargetSiteIds   types.RawJSON `json:"target_site_ids"`
	JSONARRAYAPPEND interface{}   `json:"JSON_ARRAY_APPEND"`
	LastEventAt     time.Time     `json:"last_event_at"`
	RunID           string        `json:"run_id"`
}

func (q *Queries) UpgradeReconciliationRunScope(ctx context.Context, arg UpgradeReconciliationRunScopeParams) error {
	_, err := q.db.ExecContext(ctx, upgradeReconciliationRunScope,
		arg.OrganizationID,
		arg.ProjectID,
		arg.SiteID,
		arg.Modules,
		arg.TargetSiteIds,
		arg.JSONARRAYAPPEND,
		arg.LastEventAt,
		arg.RunID,
	)
	return err
}
