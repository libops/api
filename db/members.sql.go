// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: members.sql

package db

import (
	"context"
	"database/sql"
)

const createProjectMember = `-- name: CreateProjectMember :exec
INSERT INTO project_members (
  public_id, project_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateProjectMemberParams struct {
	ProjectID int64              `json:"project_id"`
	AccountID int64              `json:"account_id"`
	Role      ProjectMembersRole `json:"role"`
	CreatedBy sql.NullInt64      `json:"created_by"`
	UpdatedBy sql.NullInt64      `json:"updated_by"`
}

func (q *Queries) CreateProjectMember(ctx context.Context, arg CreateProjectMemberParams) error {
	_, err := q.db.ExecContext(ctx, createProjectMember,
		arg.ProjectID,
		arg.AccountID,
		arg.Role,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createSiteMember = `-- name: CreateSiteMember :exec
INSERT INTO site_members (
  public_id, site_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateSiteMemberParams struct {
	SiteID    int64           `json:"site_id"`
	AccountID int64           `json:"account_id"`
	Role      SiteMembersRole `json:"role"`
	CreatedBy sql.NullInt64   `json:"created_by"`
	UpdatedBy sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) CreateSiteMember(ctx context.Context, arg CreateSiteMemberParams) error {
	_, err := q.db.ExecContext(ctx, createSiteMember,
		arg.SiteID,
		arg.AccountID,
		arg.Role,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const deleteProjectMember = `-- name: DeleteProjectMember :exec
DELETE FROM project_members WHERE project_id = ? AND account_id = ?
`

type DeleteProjectMemberParams struct {
	ProjectID int64 `json:"project_id"`
	AccountID int64 `json:"account_id"`
}

func (q *Queries) DeleteProjectMember(ctx context.Context, arg DeleteProjectMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteProjectMember, arg.ProjectID, arg.AccountID)
	return err
}

const deleteSiteMember = `-- name: DeleteSiteMember :exec
DELETE FROM site_members WHERE site_id = ? AND account_id = ?
`

type DeleteSiteMemberParams struct {
	SiteID    int64 `json:"site_id"`
	AccountID int64 `json:"account_id"`
}

func (q *Queries) DeleteSiteMember(ctx context.Context, arg DeleteSiteMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteSiteMember, arg.SiteID, arg.AccountID)
	return err
}

const getOrganizationsByAccountID = `-- name: GetOrganizationsByAccountID :many
SELECT DISTINCT o.id
FROM organizations o
WHERE o.id IN (
    SELECT om.organization_id FROM organization_members om WHERE om.account_id = ? AND om.status = 'active'
    UNION
    SELECT p.organization_id FROM project_members pm JOIN projects p ON pm.project_id = p.id WHERE pm.account_id = ? AND pm.status = 'active'
    UNION
    SELECT p.organization_id FROM site_members sm JOIN sites s ON sm.site_id = s.id JOIN projects p ON s.project_id = p.id WHERE sm.account_id = ? AND sm.status = 'active'
)
`

type GetOrganizationsByAccountIDParams struct {
	AccountID int64 `json:"account_id"`
}

func (q *Queries) GetOrganizationsByAccountID(ctx context.Context, arg GetOrganizationsByAccountIDParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getOrganizationsByAccountID, arg.AccountID, arg.AccountID, arg.AccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectMember = `-- name: GetProjectMember :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
FROM project_members WHERE project_id = ? AND account_id = ?
`

type GetProjectMemberParams struct {
	ProjectID int64 `json:"project_id"`
	AccountID int64 `json:"account_id"`
}

type GetProjectMemberRow struct {
	ID        int64              `json:"id"`
	PublicID  string             `json:"public_id"`
	ProjectID int64              `json:"project_id"`
	AccountID int64              `json:"account_id"`
	Role      ProjectMembersRole `json:"role"`
	CreatedAt sql.NullTime       `json:"created_at"`
	UpdatedAt sql.NullTime       `json:"updated_at"`
	CreatedBy sql.NullInt64      `json:"created_by"`
	UpdatedBy sql.NullInt64      `json:"updated_by"`
}

func (q *Queries) GetProjectMember(ctx context.Context, arg GetProjectMemberParams) (GetProjectMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectMember, arg.ProjectID, arg.AccountID)
	var i GetProjectMemberRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.AccountID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteMember = `-- name: GetSiteMember :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, site_id, account_id, ` + "`" + `role` + "`" + `, created_at, updated_at, created_by, updated_by
FROM site_members WHERE site_id = ? AND account_id = ?
`

type GetSiteMemberParams struct {
	SiteID    int64 `json:"site_id"`
	AccountID int64 `json:"account_id"`
}

type GetSiteMemberRow struct {
	ID        int64           `json:"id"`
	PublicID  string          `json:"public_id"`
	SiteID    int64           `json:"site_id"`
	AccountID int64           `json:"account_id"`
	Role      SiteMembersRole `json:"role"`
	CreatedAt sql.NullTime    `json:"created_at"`
	UpdatedAt sql.NullTime    `json:"updated_at"`
	CreatedBy sql.NullInt64   `json:"created_by"`
	UpdatedBy sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) GetSiteMember(ctx context.Context, arg GetSiteMemberParams) (GetSiteMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteMember, arg.SiteID, arg.AccountID)
	var i GetSiteMemberRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SiteID,
		&i.AccountID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const listProjectMembers = `-- name: ListProjectMembers :many
SELECT pm.id, BIN_TO_UUID(pm.public_id) AS public_id, pm.project_id, pm.account_id, pm.` + "`" + `role` + "`" + `, pm.status, pm.created_at, pm.updated_at,
       BIN_TO_UUID(a.public_id) AS account_public_id, a.email, a.` + "`" + `name` + "`" + `, a.github_username
FROM project_members pm
JOIN accounts a ON pm.account_id = a.id
WHERE pm.project_id = ?
ORDER BY pm.created_at DESC
LIMIT ? OFFSET ?
`

type ListProjectMembersParams struct {
	ProjectID int64 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListProjectMembersRow struct {
	ID              int64                    `json:"id"`
	PublicID        string                   `json:"public_id"`
	ProjectID       int64                    `json:"project_id"`
	AccountID       int64                    `json:"account_id"`
	Role            ProjectMembersRole       `json:"role"`
	Status          NullProjectMembersStatus `json:"status"`
	CreatedAt       sql.NullTime             `json:"created_at"`
	UpdatedAt       sql.NullTime             `json:"updated_at"`
	AccountPublicID string                   `json:"account_public_id"`
	Email           string                   `json:"email"`
	Name            sql.NullString           `json:"name"`
	GithubUsername  sql.NullString           `json:"github_username"`
}

func (q *Queries) ListProjectMembers(ctx context.Context, arg ListProjectMembersParams) ([]ListProjectMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectMembers, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectMembersRow{}
	for rows.Next() {
		var i ListProjectMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.AccountID,
			&i.Role,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountPublicID,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteMembers = `-- name: ListSiteMembers :many
SELECT sm.id, BIN_TO_UUID(sm.public_id) AS public_id, sm.site_id, sm.account_id, sm.` + "`" + `role` + "`" + `, sm.status, sm.created_at, sm.updated_at,
       BIN_TO_UUID(a.public_id) AS account_public_id, a.email, a.` + "`" + `name` + "`" + `, a.github_username
FROM site_members sm
JOIN accounts a ON sm.account_id = a.id
WHERE sm.site_id = ?
ORDER BY sm.created_at DESC
LIMIT ? OFFSET ?
`

type ListSiteMembersParams struct {
	SiteID int64 `json:"site_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSiteMembersRow struct {
	ID              int64                 `json:"id"`
	PublicID        string                `json:"public_id"`
	SiteID          int64                 `json:"site_id"`
	AccountID       int64                 `json:"account_id"`
	Role            SiteMembersRole       `json:"role"`
	Status          NullSiteMembersStatus `json:"status"`
	CreatedAt       sql.NullTime          `json:"created_at"`
	UpdatedAt       sql.NullTime          `json:"updated_at"`
	AccountPublicID string                `json:"account_public_id"`
	Email           string                `json:"email"`
	Name            sql.NullString        `json:"name"`
	GithubUsername  sql.NullString        `json:"github_username"`
}

func (q *Queries) ListSiteMembers(ctx context.Context, arg ListSiteMembersParams) ([]ListSiteMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listSiteMembers, arg.SiteID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSiteMembersRow{}
	for rows.Next() {
		var i ListSiteMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SiteID,
			&i.AccountID,
			&i.Role,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountPublicID,
			&i.Email,
			&i.Name,
			&i.GithubUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserMemberships = `-- name: ListUserMemberships :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT id, public_id, status, created_at, updated_at, role, email, user_name, account_public_id, parent_type, parent_name, parent_public_id FROM (
    SELECT
        om.id, BIN_TO_UUID(om.public_id) AS public_id, om.status, om.created_at, om.updated_at, om.role,
        a.email, a.name AS user_name, BIN_TO_UUID(a.public_id) AS account_public_id,
        'organization' AS parent_type,
        o.name AS parent_name,
        BIN_TO_UUID(o.public_id) AS parent_public_id
    FROM organization_members om
    JOIN organizations o ON om.organization_id = o.id
    JOIN accounts a ON om.account_id = a.id
    JOIN user_orgs uo ON o.id = uo.organization_id
    WHERE om.status != 'deleted'

    UNION ALL

    SELECT
        pm.id, BIN_TO_UUID(pm.public_id) AS public_id, pm.status, pm.created_at, pm.updated_at, pm.role,
        a.email, a.name AS user_name, BIN_TO_UUID(a.public_id) AS account_public_id,
        'project' AS parent_type,
        p.name AS parent_name,
        BIN_TO_UUID(p.public_id) AS parent_public_id
    FROM project_members pm
    JOIN projects p ON pm.project_id = p.id
    JOIN accounts a ON pm.account_id = a.id
    LEFT JOIN project_members pm_auth ON p.id = pm_auth.project_id AND pm_auth.account_id = ? AND pm_auth.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE pm.status != 'deleted'
    AND (pm_auth.id IS NOT NULL OR uo.organization_id IS NOT NULL)

    UNION ALL

    SELECT
        sm.id, BIN_TO_UUID(sm.public_id) AS public_id, sm.status, sm.created_at, sm.updated_at, sm.role,
        a.email, a.name AS user_name, BIN_TO_UUID(a.public_id) AS account_public_id,
        'site' AS parent_type,
        s.name AS parent_name,
        BIN_TO_UUID(s.public_id) AS parent_public_id
    FROM site_members sm
    JOIN sites s ON sm.site_id = s.id
    JOIN projects p ON s.project_id = p.id
    JOIN accounts a ON sm.account_id = a.id
    LEFT JOIN site_members sm_auth ON s.id = sm_auth.site_id AND sm_auth.account_id = ? AND sm_auth.status = 'active'
    LEFT JOIN project_members pm_auth ON p.id = pm_auth.project_id AND pm_auth.account_id = ? AND pm_auth.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE sm.status != 'deleted'
    AND (sm_auth.id IS NOT NULL OR pm_auth.id IS NOT NULL OR uo.organization_id IS NOT NULL)
) AS all_members
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListUserMembershipsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListUserMembershipsRow struct {
	ID              int64                         `json:"id"`
	PublicID        string                        `json:"public_id"`
	Status          NullOrganizationMembersStatus `json:"status"`
	CreatedAt       sql.NullTime                  `json:"created_at"`
	UpdatedAt       sql.NullTime                  `json:"updated_at"`
	Role            OrganizationMembersRole       `json:"role"`
	Email           string                        `json:"email"`
	UserName        sql.NullString                `json:"user_name"`
	AccountPublicID string                        `json:"account_public_id"`
	ParentType      string                        `json:"parent_type"`
	ParentName      string                        `json:"parent_name"`
	ParentPublicID  string                        `json:"parent_public_id"`
}

func (q *Queries) ListUserMemberships(ctx context.Context, arg ListUserMembershipsParams) ([]ListUserMembershipsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserMemberships,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserMembershipsRow{}
	for rows.Next() {
		var i ListUserMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
			&i.Email,
			&i.UserName,
			&i.AccountPublicID,
			&i.ParentType,
			&i.ParentName,
			&i.ParentPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProjectMember = `-- name: UpdateProjectMember :exec
UPDATE project_members SET
  ` + "`" + `role` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE project_id = ? AND account_id = ?
`

type UpdateProjectMemberParams struct {
	Role      ProjectMembersRole `json:"role"`
	UpdatedBy sql.NullInt64      `json:"updated_by"`
	ProjectID int64              `json:"project_id"`
	AccountID int64              `json:"account_id"`
}

func (q *Queries) UpdateProjectMember(ctx context.Context, arg UpdateProjectMemberParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectMember,
		arg.Role,
		arg.UpdatedBy,
		arg.ProjectID,
		arg.AccountID,
	)
	return err
}

const updateProjectMemberStatus = `-- name: UpdateProjectMemberStatus :exec
UPDATE project_members
SET status = ?, updated_at = NOW()
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateProjectMemberStatusParams struct {
	Status    NullProjectMembersStatus `json:"status"`
	UUIDTOBIN string                   `json:"UUID_TO_BIN"`
}

// Updates project member status (e.g., provisioning → active)
func (q *Queries) UpdateProjectMemberStatus(ctx context.Context, arg UpdateProjectMemberStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectMemberStatus, arg.Status, arg.UUIDTOBIN)
	return err
}

const updateSiteMember = `-- name: UpdateSiteMember :exec
UPDATE site_members SET
  ` + "`" + `role` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE site_id = ? AND account_id = ?
`

type UpdateSiteMemberParams struct {
	Role      SiteMembersRole `json:"role"`
	UpdatedBy sql.NullInt64   `json:"updated_by"`
	SiteID    int64           `json:"site_id"`
	AccountID int64           `json:"account_id"`
}

func (q *Queries) UpdateSiteMember(ctx context.Context, arg UpdateSiteMemberParams) error {
	_, err := q.db.ExecContext(ctx, updateSiteMember,
		arg.Role,
		arg.UpdatedBy,
		arg.SiteID,
		arg.AccountID,
	)
	return err
}

const updateSiteMemberStatus = `-- name: UpdateSiteMemberStatus :exec
UPDATE site_members
SET status = ?, updated_at = NOW()
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateSiteMemberStatusParams struct {
	Status    NullSiteMembersStatus `json:"status"`
	UUIDTOBIN string                `json:"UUID_TO_BIN"`
}

// Updates site member status (e.g., provisioning → active)
func (q *Queries) UpdateSiteMemberStatus(ctx context.Context, arg UpdateSiteMemberStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSiteMemberStatus, arg.Status, arg.UUIDTOBIN)
	return err
}
