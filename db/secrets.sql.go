// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: secrets.sql

package db

import (
	"context"
)

const listUserSecrets = `-- name: ListUserSecrets :many

WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT id, public_id, name, status, created_at, updated_at, parent_type, parent_name, parent_public_id FROM (
    SELECT
        os.id, BIN_TO_UUID(os.public_id) AS public_id, os.name, os.status, os.created_at, os.updated_at,
        'organization' AS parent_type,
        o.name AS parent_name,
        BIN_TO_UUID(o.public_id) AS parent_public_id
    FROM organization_secrets os
    JOIN organizations o ON os.organization_id = o.id
    JOIN user_orgs uo ON o.id = uo.organization_id
    WHERE os.status != 'deleted'

    UNION ALL

    SELECT
        ps.id, BIN_TO_UUID(ps.public_id) AS public_id, ps.name, ps.status, ps.created_at, ps.updated_at,
        'project' AS parent_type,
        p.name AS parent_name,
        BIN_TO_UUID(p.public_id) AS parent_public_id
    FROM project_secrets ps
    JOIN projects p ON ps.project_id = p.id
    LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE ps.status != 'deleted'
    AND (pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)

    UNION ALL

    SELECT
        ss.id, BIN_TO_UUID(ss.public_id) AS public_id, ss.name, ss.status, ss.created_at, ss.updated_at,
        'site' AS parent_type,
        s.name AS parent_name,
        BIN_TO_UUID(s.public_id) AS parent_public_id
    FROM site_secrets ss
    JOIN sites s ON ss.site_id = s.id
    JOIN projects p ON s.project_id = p.id
    LEFT JOIN site_members sm ON s.id = sm.site_id AND sm.account_id = ? AND sm.status = 'active'
    LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
    LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
    WHERE ss.status != 'deleted'
    AND (sm.id IS NOT NULL OR pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
) AS all_secrets
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListUserSecretsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListUserSecretsRow struct {
	ID             int64                         `json:"id"`
	PublicID       string                        `json:"public_id"`
	Name           string                        `json:"name"`
	Status         NullOrganizationSecretsStatus `json:"status"`
	CreatedAt      int64                         `json:"created_at"`
	UpdatedAt      int64                         `json:"updated_at"`
	ParentType     string                        `json:"parent_type"`
	ParentName     string                        `json:"parent_name"`
	ParentPublicID string                        `json:"parent_public_id"`
}

func (q *Queries) ListUserSecrets(ctx context.Context, arg ListUserSecretsParams) ([]ListUserSecretsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserSecrets,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSecretsRow{}
	for rows.Next() {
		var i ListUserSecretsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParentType,
			&i.ParentName,
			&i.ParentPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
