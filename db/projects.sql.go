// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package db

import (
	"context"
	"database/sql"

	"github.com/libops/api/db/types"
)

const countOrganizationProjects = `-- name: CountOrganizationProjects :one
SELECT COUNT(*) as count
FROM projects
WHERE organization_id = ? AND status != 'deleted'
`

func (q *Queries) CountOrganizationProjects(ctx context.Context, organizationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrganizationProjects, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectSecrets = `-- name: CountProjectSecrets :one
SELECT COUNT(*) FROM project_secrets
WHERE project_id = ? AND status != 'deleted'
`

func (q *Queries) CountProjectSecrets(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProjectSecrets, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProject = `-- name: CreateProject :exec
INSERT INTO projects (
  public_id, organization_id, ` + "`" + `name` + "`" + `,
  gcp_region, gcp_zone, machine_type, disk_size_gb, os, disk_type, stripe_subscription_item_id,
  monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
  gcp_project_id, gcp_project_number, create_branch_sites, ` + "`" + `status` + "`" + `,
  created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), ?, ?)
`

type CreateProjectParams struct {
	PublicID                  string             `json:"public_id"`
	OrganizationID            int64              `json:"organization_id"`
	Name                      string             `json:"name"`
	GcpRegion                 sql.NullString     `json:"gcp_region"`
	GcpZone                   sql.NullString     `json:"gcp_zone"`
	MachineType               sql.NullString     `json:"machine_type"`
	DiskSizeGb                sql.NullInt32      `json:"disk_size_gb"`
	Os                        sql.NullString     `json:"os"`
	DiskType                  sql.NullString     `json:"disk_type"`
	StripeSubscriptionItemID  sql.NullString     `json:"stripe_subscription_item_id"`
	MonitoringEnabled         sql.NullBool       `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString     `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool       `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString     `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString     `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString     `json:"gcp_project_number"`
	CreateBranchSites         sql.NullBool       `json:"create_branch_sites"`
	Status                    NullProjectsStatus `json:"status"`
	CreatedBy                 sql.NullInt64      `json:"created_by"`
	UpdatedBy                 sql.NullInt64      `json:"updated_by"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) error {
	_, err := q.db.ExecContext(ctx, createProject,
		arg.PublicID,
		arg.OrganizationID,
		arg.Name,
		arg.GcpRegion,
		arg.GcpZone,
		arg.MachineType,
		arg.DiskSizeGb,
		arg.Os,
		arg.DiskType,
		arg.StripeSubscriptionItemID,
		arg.MonitoringEnabled,
		arg.MonitoringLogLevel,
		arg.MonitoringMetricsEnabled,
		arg.MonitoringHealthCheckPath,
		arg.GcpProjectID,
		arg.GcpProjectNumber,
		arg.CreateBranchSites,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createProjectFirewallRule = `-- name: CreateProjectFirewallRule :exec
INSERT INTO project_firewall_rules (
  public_id, project_id, name, rule_type, cidr, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(UUID_V7()), ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?, ?)
`

type CreateProjectFirewallRuleParams struct {
	ProjectID sql.NullInt64                `json:"project_id"`
	Name      string                       `json:"name"`
	RuleType  ProjectFirewallRulesRuleType `json:"rule_type"`
	Cidr      string                       `json:"cidr"`
	CreatedBy sql.NullInt64                `json:"created_by"`
	UpdatedBy sql.NullInt64                `json:"updated_by"`
}

func (q *Queries) CreateProjectFirewallRule(ctx context.Context, arg CreateProjectFirewallRuleParams) error {
	_, err := q.db.ExecContext(ctx, createProjectFirewallRule,
		arg.ProjectID,
		arg.Name,
		arg.RuleType,
		arg.Cidr,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createProjectSecret = `-- name: CreateProjectSecret :execresult


INSERT INTO project_secrets (
    public_id, project_id, name, vault_path, status, created_at, updated_at, created_by, updated_by
) VALUES (UUID_TO_BIN(?), ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateProjectSecretParams struct {
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

// =============================================================================
// SITE FIREWALL RULES
// =============================================================================
func (q *Queries) CreateProjectSecret(ctx context.Context, arg CreateProjectSecretParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProjectSecret,
		arg.PublicID,
		arg.ProjectID,
		arg.Name,
		arg.VaultPath,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteProject(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteProject, publicID)
	return err
}

const deleteProjectFirewallRule = `-- name: DeleteProjectFirewallRule :exec
DELETE FROM project_firewall_rules WHERE id = ?
`

func (q *Queries) DeleteProjectFirewallRule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProjectFirewallRule, id)
	return err
}

const deleteProjectFirewallRuleByPublicID = `-- name: DeleteProjectFirewallRuleByPublicID :exec
UPDATE project_firewall_rules SET status = 'deleted', updated_at = CURRENT_TIMESTAMP WHERE public_id = UUID_TO_BIN(?)
`

func (q *Queries) DeleteProjectFirewallRuleByPublicID(ctx context.Context, uuidTOBIN string) error {
	_, err := q.db.ExecContext(ctx, deleteProjectFirewallRuleByPublicID, uuidTOBIN)
	return err
}

const deleteProjectSecret = `-- name: DeleteProjectSecret :exec
UPDATE project_secrets
SET status = 'deleted', updated_by = ?, updated_at = ?
WHERE id = ?
`

type DeleteProjectSecretParams struct {
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) DeleteProjectSecret(ctx context.Context, arg DeleteProjectSecretParams) error {
	_, err := q.db.ExecContext(ctx, deleteProjectSecret, arg.UpdatedBy, arg.UpdatedAt, arg.ID)
	return err
}

const getProject = `-- name: GetProject :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, ` + "`" + `name` + "`" + `,
       gcp_region, gcp_zone, machine_type, disk_size_gb, os, disk_type, stripe_subscription_item_id,
       promote_strategy,
       monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
       gcp_project_id, gcp_project_number, create_branch_sites, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM projects WHERE public_id = UUID_TO_BIN(?)
`

type GetProjectRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	Os                        sql.NullString              `json:"os"`
	DiskType                  sql.NullString              `json:"disk_type"`
	StripeSubscriptionItemID  sql.NullString              `json:"stripe_subscription_item_id"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) GetProject(ctx context.Context, publicID string) (GetProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getProject, publicID)
	var i GetProjectRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.Os,
		&i.DiskType,
		&i.StripeSubscriptionItemID,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreateBranchSites,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectByGCPProjectID = `-- name: GetProjectByGCPProjectID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, ` + "`" + `name` + "`" + `,
       gcp_region, gcp_zone, machine_type, disk_size_gb, os, disk_type, stripe_subscription_item_id,
       promote_strategy,
       monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
       gcp_project_id, gcp_project_number, create_branch_sites, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM projects WHERE gcp_project_id = ?
`

type GetProjectByGCPProjectIDRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	Os                        sql.NullString              `json:"os"`
	DiskType                  sql.NullString              `json:"disk_type"`
	StripeSubscriptionItemID  sql.NullString              `json:"stripe_subscription_item_id"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) GetProjectByGCPProjectID(ctx context.Context, gcpProjectID sql.NullString) (GetProjectByGCPProjectIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectByGCPProjectID, gcpProjectID)
	var i GetProjectByGCPProjectIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.Os,
		&i.DiskType,
		&i.StripeSubscriptionItemID,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreateBranchSites,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, ` + "`" + `name` + "`" + `,
       gcp_region, gcp_zone, machine_type, disk_size_gb, os, disk_type, stripe_subscription_item_id,
       promote_strategy,
       monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path,
       gcp_project_id, gcp_project_number, create_branch_sites, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM projects WHERE id = ?
`

type GetProjectByIDRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	Os                        sql.NullString              `json:"os"`
	DiskType                  sql.NullString              `json:"disk_type"`
	StripeSubscriptionItemID  sql.NullString              `json:"stripe_subscription_item_id"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) GetProjectByID(ctx context.Context, id int64) (GetProjectByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, id)
	var i GetProjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OrganizationID,
		&i.Name,
		&i.GcpRegion,
		&i.GcpZone,
		&i.MachineType,
		&i.DiskSizeGb,
		&i.Os,
		&i.DiskType,
		&i.StripeSubscriptionItemID,
		&i.PromoteStrategy,
		&i.MonitoringEnabled,
		&i.MonitoringLogLevel,
		&i.MonitoringMetricsEnabled,
		&i.MonitoringHealthCheckPath,
		&i.GcpProjectID,
		&i.GcpProjectNumber,
		&i.CreateBranchSites,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectFirewallRuleByPublicID = `-- name: GetProjectFirewallRuleByPublicID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, rule_type, cidr, name, status, created_at, updated_at, created_by, updated_by
FROM project_firewall_rules WHERE public_id = UUID_TO_BIN(?)
`

type GetProjectFirewallRuleByPublicIDRow struct {
	ID        int64                          `json:"id"`
	PublicID  string                         `json:"public_id"`
	ProjectID sql.NullInt64                  `json:"project_id"`
	RuleType  ProjectFirewallRulesRuleType   `json:"rule_type"`
	Cidr      string                         `json:"cidr"`
	Name      string                         `json:"name"`
	Status    NullProjectFirewallRulesStatus `json:"status"`
	CreatedAt sql.NullTime                   `json:"created_at"`
	UpdatedAt sql.NullTime                   `json:"updated_at"`
	CreatedBy sql.NullInt64                  `json:"created_by"`
	UpdatedBy sql.NullInt64                  `json:"updated_by"`
}

func (q *Queries) GetProjectFirewallRuleByPublicID(ctx context.Context, uuidTOBIN string) (GetProjectFirewallRuleByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectFirewallRuleByPublicID, uuidTOBIN)
	var i GetProjectFirewallRuleByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.RuleType,
		&i.Cidr,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectSecretByID = `-- name: GetProjectSecretByID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM project_secrets WHERE id = ? AND status != 'deleted'
`

type GetProjectSecretByIDRow struct {
	ID        int64                    `json:"id"`
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

func (q *Queries) GetProjectSecretByID(ctx context.Context, id int64) (GetProjectSecretByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectSecretByID, id)
	var i GetProjectSecretByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectSecretByName = `-- name: GetProjectSecretByName :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM project_secrets
WHERE project_id = ? AND name = ? AND status != 'deleted'
`

type GetProjectSecretByNameParams struct {
	ProjectID int64  `json:"project_id"`
	Name      string `json:"name"`
}

type GetProjectSecretByNameRow struct {
	ID        int64                    `json:"id"`
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

func (q *Queries) GetProjectSecretByName(ctx context.Context, arg GetProjectSecretByNameParams) (GetProjectSecretByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectSecretByName, arg.ProjectID, arg.Name)
	var i GetProjectSecretByNameRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProjectSecretByPublicID = `-- name: GetProjectSecretByPublicID :one
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM project_secrets WHERE public_id = UUID_TO_BIN(?) AND status != 'deleted'
`

type GetProjectSecretByPublicIDRow struct {
	ID        int64                    `json:"id"`
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

func (q *Queries) GetProjectSecretByPublicID(ctx context.Context, publicID string) (GetProjectSecretByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectSecretByPublicID, publicID)
	var i GetProjectSecretByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.VaultPath,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getSiteByProjectAndName = `-- name: GetSiteByProjectAndName :one


SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, ` + "`" + `name` + "`" + `, github_repository, github_ref, github_team_id, compose_path, compose_file, port, application_type, up_cmd, init_cmd, rollout_cmd, overlay_volumes, os, is_production, gcp_external_ip, ` + "`" + `status` + "`" + `,
       created_at, updated_at, created_by, updated_by
FROM sites WHERE project_id = ? AND ` + "`" + `name` + "`" + ` = ?
`

type GetSiteByProjectAndNameParams struct {
	ProjectID int64  `json:"project_id"`
	Name      string `json:"name"`
}

type GetSiteByProjectAndNameRow struct {
	ID               int64           `json:"id"`
	PublicID         string          `json:"public_id"`
	ProjectID        int64           `json:"project_id"`
	Name             string          `json:"name"`
	GithubRepository string          `json:"github_repository"`
	GithubRef        string          `json:"github_ref"`
	GithubTeamID     sql.NullString  `json:"github_team_id"`
	ComposePath      sql.NullString  `json:"compose_path"`
	ComposeFile      sql.NullString  `json:"compose_file"`
	Port             sql.NullInt32   `json:"port"`
	ApplicationType  sql.NullString  `json:"application_type"`
	UpCmd            types.RawJSON   `json:"up_cmd"`
	InitCmd          types.RawJSON   `json:"init_cmd"`
	RolloutCmd       types.RawJSON   `json:"rollout_cmd"`
	OverlayVolumes   types.RawJSON   `json:"overlay_volumes"`
	Os               sql.NullString  `json:"os"`
	IsProduction     sql.NullBool    `json:"is_production"`
	GcpExternalIp    sql.NullString  `json:"gcp_external_ip"`
	Status           NullSitesStatus `json:"status"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	CreatedBy        sql.NullInt64   `json:"created_by"`
	UpdatedBy        sql.NullInt64   `json:"updated_by"`
}

// =============================================================================
// SITES
// =============================================================================
func (q *Queries) GetSiteByProjectAndName(ctx context.Context, arg GetSiteByProjectAndNameParams) (GetSiteByProjectAndNameRow, error) {
	row := q.db.QueryRowContext(ctx, getSiteByProjectAndName, arg.ProjectID, arg.Name)
	var i GetSiteByProjectAndNameRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectID,
		&i.Name,
		&i.GithubRepository,
		&i.GithubRef,
		&i.GithubTeamID,
		&i.ComposePath,
		&i.ComposeFile,
		&i.Port,
		&i.ApplicationType,
		&i.UpCmd,
		&i.InitCmd,
		&i.RolloutCmd,
		&i.OverlayVolumes,
		&i.Os,
		&i.IsProduction,
		&i.GcpExternalIp,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const hasUserSiteAccessInProject = `-- name: HasUserSiteAccessInProject :one


SELECT EXISTS (
    SELECT 1 FROM site_members sm
    JOIN sites s ON sm.site_id = s.id
    JOIN projects p ON s.project_id = p.id
    JOIN projects p_target ON p_target.id = ?
    LEFT JOIN relationships r ON (
        r.source_organization_id = p.organization_id AND r.target_organization_id = p_target.organization_id
    )
    WHERE sm.account_id = ?
      AND (s.project_id = ? OR (r.status = 'approved' AND r.id IS NOT NULL))
      AND sm.status = 'active'
    LIMIT 1
)
`

type HasUserSiteAccessInProjectParams struct {
	ID        int64 `json:"id"`
	AccountID int64 `json:"account_id"`
	ProjectID int64 `json:"project_id"`
}

// =============================================================================
// SITE SECRETS
// =============================================================================
func (q *Queries) HasUserSiteAccessInProject(ctx context.Context, arg HasUserSiteAccessInProjectParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasUserSiteAccessInProject, arg.ID, arg.AccountID, arg.ProjectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listProjectFirewallRules = `-- name: ListProjectFirewallRules :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, rule_type, cidr, name, status, created_at, updated_at, created_by, updated_by
FROM project_firewall_rules
WHERE project_id = ? AND status != 'deleted'
ORDER BY created_at DESC
`

type ListProjectFirewallRulesRow struct {
	ID        int64                          `json:"id"`
	PublicID  string                         `json:"public_id"`
	ProjectID sql.NullInt64                  `json:"project_id"`
	RuleType  ProjectFirewallRulesRuleType   `json:"rule_type"`
	Cidr      string                         `json:"cidr"`
	Name      string                         `json:"name"`
	Status    NullProjectFirewallRulesStatus `json:"status"`
	CreatedAt sql.NullTime                   `json:"created_at"`
	UpdatedAt sql.NullTime                   `json:"updated_at"`
	CreatedBy sql.NullInt64                  `json:"created_by"`
	UpdatedBy sql.NullInt64                  `json:"updated_by"`
}

func (q *Queries) ListProjectFirewallRules(ctx context.Context, projectID sql.NullInt64) ([]ListProjectFirewallRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectFirewallRules, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectFirewallRulesRow{}
	for rows.Next() {
		var i ListProjectFirewallRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.RuleType,
			&i.Cidr,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectSecrets = `-- name: ListProjectSecrets :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, vault_path, status,
       created_at, updated_at, created_by, updated_by
FROM project_secrets
WHERE project_id = ? AND status != 'deleted'
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListProjectSecretsParams struct {
	ProjectID int64 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListProjectSecretsRow struct {
	ID        int64                    `json:"id"`
	PublicID  string                   `json:"public_id"`
	ProjectID int64                    `json:"project_id"`
	Name      string                   `json:"name"`
	VaultPath string                   `json:"vault_path"`
	Status    NullProjectSecretsStatus `json:"status"`
	CreatedAt int64                    `json:"created_at"`
	UpdatedAt int64                    `json:"updated_at"`
	CreatedBy sql.NullInt64            `json:"created_by"`
	UpdatedBy sql.NullInt64            `json:"updated_by"`
}

func (q *Queries) ListProjectSecrets(ctx context.Context, arg ListProjectSecretsParams) ([]ListProjectSecretsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectSecrets, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectSecretsRow{}
	for rows.Next() {
		var i ListProjectSecretsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.Name,
			&i.VaultPath,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectSites = `-- name: ListProjectSites :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, project_id, name, github_repository, github_ref, github_team_id, compose_path, compose_file, port, application_type, up_cmd, init_cmd, rollout_cmd, overlay_volumes, os, is_production, gcp_external_ip, status, created_at, updated_at, created_by, updated_by
FROM sites
WHERE project_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListProjectSitesParams struct {
	ProjectID int64 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListProjectSitesRow struct {
	ID               int64           `json:"id"`
	PublicID         string          `json:"public_id"`
	ProjectID        int64           `json:"project_id"`
	Name             string          `json:"name"`
	GithubRepository string          `json:"github_repository"`
	GithubRef        string          `json:"github_ref"`
	GithubTeamID     sql.NullString  `json:"github_team_id"`
	ComposePath      sql.NullString  `json:"compose_path"`
	ComposeFile      sql.NullString  `json:"compose_file"`
	Port             sql.NullInt32   `json:"port"`
	ApplicationType  sql.NullString  `json:"application_type"`
	UpCmd            types.RawJSON   `json:"up_cmd"`
	InitCmd          types.RawJSON   `json:"init_cmd"`
	RolloutCmd       types.RawJSON   `json:"rollout_cmd"`
	OverlayVolumes   types.RawJSON   `json:"overlay_volumes"`
	Os               sql.NullString  `json:"os"`
	IsProduction     sql.NullBool    `json:"is_production"`
	GcpExternalIp    sql.NullString  `json:"gcp_external_ip"`
	Status           NullSitesStatus `json:"status"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	CreatedBy        sql.NullInt64   `json:"created_by"`
	UpdatedBy        sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) ListProjectSites(ctx context.Context, arg ListProjectSitesParams) ([]ListProjectSitesRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectSites, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectSitesRow{}
	for rows.Next() {
		var i ListProjectSitesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.Name,
			&i.GithubRepository,
			&i.GithubRef,
			&i.GithubTeamID,
			&i.ComposePath,
			&i.ComposeFile,
			&i.Port,
			&i.ApplicationType,
			&i.UpCmd,
			&i.InitCmd,
			&i.RolloutCmd,
			&i.OverlayVolumes,
			&i.Os,
			&i.IsProduction,
			&i.GcpExternalIp,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, BIN_TO_UUID(public_id) AS public_id, organization_id, name, gcp_region, gcp_zone, machine_type, disk_size_gb, stripe_subscription_item_id, promote_strategy, monitoring_enabled, monitoring_log_level, monitoring_metrics_enabled, monitoring_health_check_path, gcp_project_id, gcp_project_number, organization_project, create_branch_sites, status, created_at, updated_at, created_by, updated_by
FROM projects
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListProjectsRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	Name                      string                      `json:"name"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	StripeSubscriptionItemID  sql.NullString              `json:"stripe_subscription_item_id"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListProjects(ctx context.Context, arg ListProjectsParams) ([]ListProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectsRow{}
	for rows.Next() {
		var i ListProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.Name,
			&i.GcpRegion,
			&i.GcpZone,
			&i.MachineType,
			&i.DiskSizeGb,
			&i.StripeSubscriptionItemID,
			&i.PromoteStrategy,
			&i.MonitoringEnabled,
			&i.MonitoringLogLevel,
			&i.MonitoringMetricsEnabled,
			&i.MonitoringHealthCheckPath,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.OrganizationProject,
			&i.CreateBranchSites,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSshKeysByProject = `-- name: ListSshKeysByProject :many
SELECT DISTINCT sk.public_key
FROM ssh_keys sk
JOIN accounts a ON sk.account_id = a.id
JOIN (
    SELECT DISTINCT pm.account_id
    FROM project_members pm
    WHERE pm.project_id = (SELECT id FROM projects WHERE public_id = UUID_TO_BIN(?))
      AND pm.status = 'active'
      AND pm.role IN ('owner', 'developer')
    UNION
    SELECT DISTINCT om.account_id
    FROM organization_members om
    JOIN projects p ON om.organization_id = p.organization_id
    WHERE p.public_id = UUID_TO_BIN(?)
      AND om.status = 'active'
      AND om.role IN ('owner', 'developer')
    UNION
    -- Include members from related organizations with approved relationships
    SELECT DISTINCT om_related.account_id
    FROM organization_members om_related
    JOIN relationships r ON om_related.organization_id = r.target_organization_id
    JOIN projects p ON r.source_organization_id = p.organization_id
    WHERE p.public_id = UUID_TO_BIN(?)
      AND r.status = 'approved'
      AND om_related.status = 'active'
      AND om_related.role IN ('owner', 'developer')
) AS authorized_accounts ON a.id = authorized_accounts.account_id
ORDER BY sk.created_at DESC
`

type ListSshKeysByProjectParams struct {
	ProjectPublicID string `json:"project_public_id"`
}

func (q *Queries) ListSshKeysByProject(ctx context.Context, arg ListSshKeysByProjectParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listSshKeysByProject, arg.ProjectPublicID, arg.ProjectPublicID, arg.ProjectPublicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var public_key string
		if err := rows.Scan(&public_key); err != nil {
			return nil, err
		}
		items = append(items, public_key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProjects = `-- name: ListUserProjects :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT p.id, BIN_TO_UUID(p.public_id) AS public_id, p.organization_id, BIN_TO_UUID(o.public_id) AS organization_public_id, p.name, p.gcp_region, p.gcp_zone, p.machine_type, p.disk_size_gb, p.os, p.disk_type, p.stripe_subscription_item_id, p.promote_strategy, p.monitoring_enabled, p.monitoring_log_level, p.monitoring_metrics_enabled, p.monitoring_health_check_path, p.gcp_project_id, p.gcp_project_number, p.organization_project, p.create_branch_sites, p.status, p.created_at, p.updated_at, p.created_by, p.updated_by
FROM projects p
JOIN organizations o ON p.organization_id = o.id
LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
WHERE (pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
AND (p.organization_id = ? OR ? IS NULL)
ORDER BY p.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserProjectsParams struct {
	AccountID            int64         `json:"account_id"`
	FilterOrganizationID sql.NullInt64 `json:"filter_organization_id"`
	Limit                int32         `json:"limit"`
	Offset               int32         `json:"offset"`
}

type ListUserProjectsRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	OrganizationPublicID      string                      `json:"organization_public_id"`
	Name                      string                      `json:"name"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	Os                        sql.NullString              `json:"os"`
	DiskType                  sql.NullString              `json:"disk_type"`
	StripeSubscriptionItemID  sql.NullString              `json:"stripe_subscription_item_id"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListUserProjects(ctx context.Context, arg ListUserProjectsParams) ([]ListUserProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserProjects,
		arg.AccountID,
		arg.AccountID,
		arg.FilterOrganizationID,
		arg.FilterOrganizationID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserProjectsRow{}
	for rows.Next() {
		var i ListUserProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.OrganizationPublicID,
			&i.Name,
			&i.GcpRegion,
			&i.GcpZone,
			&i.MachineType,
			&i.DiskSizeGb,
			&i.Os,
			&i.DiskType,
			&i.StripeSubscriptionItemID,
			&i.PromoteStrategy,
			&i.MonitoringEnabled,
			&i.MonitoringLogLevel,
			&i.MonitoringMetricsEnabled,
			&i.MonitoringHealthCheckPath,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.OrganizationProject,
			&i.CreateBranchSites,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProjectsWithOrg = `-- name: ListUserProjectsWithOrg :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT p.id, BIN_TO_UUID(p.public_id) AS public_id, p.organization_id, BIN_TO_UUID(o.public_id) AS organization_public_id, o.name AS organization_name, p.name, p.gcp_region, p.gcp_zone, p.machine_type, p.disk_size_gb, p.stripe_subscription_item_id, p.promote_strategy, p.monitoring_enabled, p.monitoring_log_level, p.monitoring_metrics_enabled, p.monitoring_health_check_path, p.gcp_project_id, p.gcp_project_number, p.organization_project, p.create_branch_sites, p.status, p.created_at, p.updated_at, p.created_by, p.updated_by
FROM projects p
JOIN organizations o ON p.organization_id = o.id
LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
WHERE (pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
AND (p.organization_id = ? OR ? IS NULL)
ORDER BY p.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserProjectsWithOrgParams struct {
	AccountID            int64         `json:"account_id"`
	FilterOrganizationID sql.NullInt64 `json:"filter_organization_id"`
	Limit                int32         `json:"limit"`
	Offset               int32         `json:"offset"`
}

type ListUserProjectsWithOrgRow struct {
	ID                        int64                       `json:"id"`
	PublicID                  string                      `json:"public_id"`
	OrganizationID            int64                       `json:"organization_id"`
	OrganizationPublicID      string                      `json:"organization_public_id"`
	OrganizationName          string                      `json:"organization_name"`
	Name                      string                      `json:"name"`
	GcpRegion                 sql.NullString              `json:"gcp_region"`
	GcpZone                   sql.NullString              `json:"gcp_zone"`
	MachineType               sql.NullString              `json:"machine_type"`
	DiskSizeGb                sql.NullInt32               `json:"disk_size_gb"`
	StripeSubscriptionItemID  sql.NullString              `json:"stripe_subscription_item_id"`
	PromoteStrategy           NullProjectsPromoteStrategy `json:"promote_strategy"`
	MonitoringEnabled         sql.NullBool                `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString              `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool                `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString              `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString              `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString              `json:"gcp_project_number"`
	OrganizationProject       sql.NullBool                `json:"organization_project"`
	CreateBranchSites         sql.NullBool                `json:"create_branch_sites"`
	Status                    NullProjectsStatus          `json:"status"`
	CreatedAt                 sql.NullTime                `json:"created_at"`
	UpdatedAt                 sql.NullTime                `json:"updated_at"`
	CreatedBy                 sql.NullInt64               `json:"created_by"`
	UpdatedBy                 sql.NullInt64               `json:"updated_by"`
}

func (q *Queries) ListUserProjectsWithOrg(ctx context.Context, arg ListUserProjectsWithOrgParams) ([]ListUserProjectsWithOrgRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserProjectsWithOrg,
		arg.AccountID,
		arg.AccountID,
		arg.FilterOrganizationID,
		arg.FilterOrganizationID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserProjectsWithOrgRow{}
	for rows.Next() {
		var i ListUserProjectsWithOrgRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OrganizationID,
			&i.OrganizationPublicID,
			&i.OrganizationName,
			&i.Name,
			&i.GcpRegion,
			&i.GcpZone,
			&i.MachineType,
			&i.DiskSizeGb,
			&i.StripeSubscriptionItemID,
			&i.PromoteStrategy,
			&i.MonitoringEnabled,
			&i.MonitoringLogLevel,
			&i.MonitoringMetricsEnabled,
			&i.MonitoringHealthCheckPath,
			&i.GcpProjectID,
			&i.GcpProjectNumber,
			&i.OrganizationProject,
			&i.CreateBranchSites,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSitesWithProject = `-- name: ListUserSitesWithProject :many
WITH RECURSIVE user_orgs AS (
    SELECT organization_id FROM organization_members WHERE organization_members.account_id = ? AND organization_members.status = 'active'
    UNION DISTINCT
    SELECT r.target_organization_id
    FROM relationships r
    INNER JOIN user_orgs uo ON r.source_organization_id = uo.organization_id
    WHERE r.status = 'approved'
)
SELECT DISTINCT s.id, BIN_TO_UUID(s.public_id) AS public_id, s.project_id, BIN_TO_UUID(p.public_id) AS project_public_id, p.name AS project_name, BIN_TO_UUID(o.public_id) AS organization_public_id, s.name, s.github_repository, s.github_ref, s.github_team_id, s.compose_path, s.compose_file, s.port, s.application_type, s.up_cmd, s.init_cmd, s.rollout_cmd, s.gcp_external_ip, s.status, s.created_at, s.updated_at, s.created_by, s.updated_by
FROM sites s
JOIN projects p ON s.project_id = p.id
JOIN organizations o ON p.organization_id = o.id
LEFT JOIN site_members sm ON s.id = sm.site_id AND sm.account_id = ? AND sm.status = 'active'
LEFT JOIN project_members pm ON s.project_id = pm.project_id AND pm.account_id = ? AND pm.status = 'active'
LEFT JOIN user_orgs uo ON p.organization_id = uo.organization_id
WHERE (sm.id IS NOT NULL OR pm.id IS NOT NULL OR uo.organization_id IS NOT NULL)
AND (p.organization_id = ? OR ? IS NULL)
AND (s.project_id = ? OR ? IS NULL)
ORDER BY s.created_at DESC
LIMIT ? OFFSET ?
`

type ListUserSitesWithProjectParams struct {
	AccountID            int64         `json:"account_id"`
	FilterOrganizationID sql.NullInt64 `json:"filter_organization_id"`
	FilterProjectID      sql.NullInt64 `json:"filter_project_id"`
	Limit                int32         `json:"limit"`
	Offset               int32         `json:"offset"`
}

type ListUserSitesWithProjectRow struct {
	ID                   int64           `json:"id"`
	PublicID             string          `json:"public_id"`
	ProjectID            int64           `json:"project_id"`
	ProjectPublicID      string          `json:"project_public_id"`
	ProjectName          string          `json:"project_name"`
	OrganizationPublicID string          `json:"organization_public_id"`
	Name                 string          `json:"name"`
	GithubRepository     string          `json:"github_repository"`
	GithubRef            string          `json:"github_ref"`
	GithubTeamID         sql.NullString  `json:"github_team_id"`
	ComposePath          sql.NullString  `json:"compose_path"`
	ComposeFile          sql.NullString  `json:"compose_file"`
	Port                 sql.NullInt32   `json:"port"`
	ApplicationType      sql.NullString  `json:"application_type"`
	UpCmd                types.RawJSON   `json:"up_cmd"`
	InitCmd              types.RawJSON   `json:"init_cmd"`
	RolloutCmd           types.RawJSON   `json:"rollout_cmd"`
	GcpExternalIp        sql.NullString  `json:"gcp_external_ip"`
	Status               NullSitesStatus `json:"status"`
	CreatedAt            sql.NullTime    `json:"created_at"`
	UpdatedAt            sql.NullTime    `json:"updated_at"`
	CreatedBy            sql.NullInt64   `json:"created_by"`
	UpdatedBy            sql.NullInt64   `json:"updated_by"`
}

func (q *Queries) ListUserSitesWithProject(ctx context.Context, arg ListUserSitesWithProjectParams) ([]ListUserSitesWithProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserSitesWithProject,
		arg.AccountID,
		arg.AccountID,
		arg.AccountID,
		arg.FilterOrganizationID,
		arg.FilterOrganizationID,
		arg.FilterProjectID,
		arg.FilterProjectID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSitesWithProjectRow{}
	for rows.Next() {
		var i ListUserSitesWithProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ProjectID,
			&i.ProjectPublicID,
			&i.ProjectName,
			&i.OrganizationPublicID,
			&i.Name,
			&i.GithubRepository,
			&i.GithubRef,
			&i.GithubTeamID,
			&i.ComposePath,
			&i.ComposeFile,
			&i.Port,
			&i.ApplicationType,
			&i.UpCmd,
			&i.InitCmd,
			&i.RolloutCmd,
			&i.GcpExternalIp,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :exec
UPDATE projects SET
  ` + "`" + `name` + "`" + ` = ?,
  gcp_region = ?,
  gcp_zone = ?,
  machine_type = ?,
  disk_size_gb = ?,
  os = ?,
  disk_type = ?,
  stripe_subscription_item_id = ?,
  monitoring_enabled = ?,
  monitoring_log_level = ?,
  monitoring_metrics_enabled = ?,
  monitoring_health_check_path = ?,
  gcp_project_id = ?,
  gcp_project_number = ?,
  create_branch_sites = ?,
  ` + "`" + `status` + "`" + ` = ?,
  updated_at = NOW(),
  updated_by = ?
WHERE public_id = UUID_TO_BIN(?)
`

type UpdateProjectParams struct {
	Name                      string             `json:"name"`
	GcpRegion                 sql.NullString     `json:"gcp_region"`
	GcpZone                   sql.NullString     `json:"gcp_zone"`
	MachineType               sql.NullString     `json:"machine_type"`
	DiskSizeGb                sql.NullInt32      `json:"disk_size_gb"`
	Os                        sql.NullString     `json:"os"`
	DiskType                  sql.NullString     `json:"disk_type"`
	StripeSubscriptionItemID  sql.NullString     `json:"stripe_subscription_item_id"`
	MonitoringEnabled         sql.NullBool       `json:"monitoring_enabled"`
	MonitoringLogLevel        sql.NullString     `json:"monitoring_log_level"`
	MonitoringMetricsEnabled  sql.NullBool       `json:"monitoring_metrics_enabled"`
	MonitoringHealthCheckPath sql.NullString     `json:"monitoring_health_check_path"`
	GcpProjectID              sql.NullString     `json:"gcp_project_id"`
	GcpProjectNumber          sql.NullString     `json:"gcp_project_number"`
	CreateBranchSites         sql.NullBool       `json:"create_branch_sites"`
	Status                    NullProjectsStatus `json:"status"`
	UpdatedBy                 sql.NullInt64      `json:"updated_by"`
	PublicID                  string             `json:"public_id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.ExecContext(ctx, updateProject,
		arg.Name,
		arg.GcpRegion,
		arg.GcpZone,
		arg.MachineType,
		arg.DiskSizeGb,
		arg.Os,
		arg.DiskType,
		arg.StripeSubscriptionItemID,
		arg.MonitoringEnabled,
		arg.MonitoringLogLevel,
		arg.MonitoringMetricsEnabled,
		arg.MonitoringHealthCheckPath,
		arg.GcpProjectID,
		arg.GcpProjectNumber,
		arg.CreateBranchSites,
		arg.Status,
		arg.UpdatedBy,
		arg.PublicID,
	)
	return err
}

const updateProjectSecret = `-- name: UpdateProjectSecret :exec
UPDATE project_secrets
SET vault_path = ?, updated_by = ?, updated_at = ?
WHERE id = ?
`

type UpdateProjectSecretParams struct {
	VaultPath string        `json:"vault_path"`
	UpdatedBy sql.NullInt64 `json:"updated_by"`
	UpdatedAt int64         `json:"updated_at"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateProjectSecret(ctx context.Context, arg UpdateProjectSecretParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectSecret,
		arg.VaultPath,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
